
chdir(/usr/share/vim)
fchdir() to previous dir
ladataan $VIM/vimrc
rivi 1: " All system-wide defaults are set in $VIMRUNTIME/debian.vim and sourced by
rivi 2: " the call to :runtime you can find below.  If you wish to change any of those
rivi 3: " settings, you should do it in this file (/etc/vim/vimrc), since debian.vim
rivi 4: " will be overwritten everytime an upgrade of the vim packages is performed.
rivi 5: " It is recommended to make changes after sourcing debian.vim since it alters
rivi 6: " the value of the 'compatible' option.
rivi 7: 
rivi 8: " This line should not be removed as it ensures that various options are
rivi 9: " properly set to work with the Vim-related packages available in Debian.
rivi 10: runtime! debian.vim
Etsitään ilmausta debian.vim kohteesta /home/ollpu/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/home/ollpu/.vim/after
Etsitään ilmausta /home/ollpu/.vim/debian.vim
Etsitään ilmausta /usr/share/vim/vimfiles/debian.vim
Etsitään ilmausta /usr/share/vim/vim74/debian.vim
chdir(/usr/share/vim/vim74)
fchdir() to previous dir
rivi 10: ladataan /usr/share/vim/vim74/debian.vim
rivi 1: " Debian system-wide default configuration Vim
rivi 2: 
rivi 3: set runtimepath=~/.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,~/.vim/after
rivi 4: 
rivi 5: " Normally we use vim-extensions. If you want true vi-compatibility
rivi 6: " remove change the following statements
rivi 7: set nocompatible^I" Use Vim defaults instead of 100% vi compatibility
rivi 8: set backspace=indent,eol,start^I" more powerful backspacing
rivi 9: 
rivi 10: " Now we set some defaults for the editor
rivi 11: set history=50^I^I" keep 50 lines of command line history
rivi 12: set ruler^I^I" show the cursor position all the time
rivi 13: 
rivi 14: " modelines have historically been a source of security/resource
rivi 15: " vulnerabilities -- disable by default, even when 'nocompatible' is set
rivi 16: set nomodeline
rivi 17: 
rivi 18: " Suffixes that get lower priority when doing tab completion for filenames.
rivi 19: " These are files we are not likely to want to edit or read.
rivi 20: set suffixes=.bak,~,.swp,.o,.info,.aux,.log,.dvi,.bbl,.blg,.brf,.cb,.ind,.idx,.ilg,.inx,.out,.toc
rivi 21: 
rivi 22: " We know xterm-debian is a color terminal
rivi 23: if &term =~ "xterm-debian" || &term =~ "xterm-xfree86"
rivi 24:   set t_Co=16
rivi 25:   set t_Sf=^[[3%dm
rivi 26:   set t_Sb=^[[4%dm
rivi 27: endif
rivi 28: 
rivi 29: " Some Debian-specific things
rivi 30: if has("autocmd")
rivi 31:   " set mail filetype for reportbug's temp files
rivi 32:   augroup debian
rivi 33:     au BufRead reportbug-*^I^Iset ft=mail
rivi 34:   augroup END
rivi 35:   if has('gui')
rivi 36:     " Make shift-insert work like in Xterm
rivi 37:     autocmd GUIEnter * if empty(maparg("<S-Insert>", "nvso")) | execute "map <S-Insert> <MiddleMouse>" | endif
rivi 38:     autocmd GUIEnter * if empty(maparg("<S-Insert>", "ic")) | execute "map! <S-Insert> <MiddleMouse>" | endif
rivi 39:   endif
rivi 40: endif
rivi 41: 
rivi 42: " Set paper size from /etc/papersize if available (Debian-specific)
rivi 43: if filereadable("/etc/papersize")
rivi 44:   let s:papersize = matchstr(readfile('/etc/papersize', '', 1), '\p*')
rivi 45:   if strlen(s:papersize)
rivi 46:     exe "set printoptions+=paper:" . s:papersize
rivi 46: set printoptions+=paper:a4
rivi 47:   endif
rivi 48: endif
rivi 49: 
ladattu /usr/share/vim/vim74/debian.vim
jatkaa kohdassa /usr/share/vim/vimrc
Etsitään ilmausta /usr/share/vim/vimfiles/after/debian.vim
Etsitään ilmausta /home/ollpu/.vim/after/debian.vim
rivi 11: 
rivi 12: " Uncomment the next line to make Vim more Vi-compatible
rivi 13: " NOTE: debian.vim sets 'nocompatible'.  Setting 'compatible' changes numerous
rivi 14: " options, so any other options should be set AFTER setting 'compatible'.
rivi 15: "set compatible
rivi 16: 
rivi 17: " Vim5 and later versions support syntax highlighting. Uncommenting the next
rivi 18: " line enables syntax highlighting by default.
rivi 19: if has("syntax")
rivi 20:   syntax on
rivi 20: so $VIMRUNTIME/syntax/syntax.vim
chdir(/usr/share/vim/vim74/syntax)
fchdir() to previous dir
rivi 20: ladataan /usr/share/vim/vim74/syntax/syntax.vim
rivi 1: " Vim syntax support file
rivi 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
rivi 3: " Last Change:^I2001 Sep 04
rivi 4: 
rivi 5: " This file is used for ":syntax on".
rivi 6: " It installs the autocommands and starts highlighting for all buffers.
rivi 7: 
rivi 8: if !has("syntax")
rivi 9:   finish
rivi 10: endif
rivi 11: 
rivi 12: " If Syntax highlighting appears to be on already, turn it off first, so that
rivi 13: " any leftovers are cleared.
rivi 14: if exists("syntax_on") || exists("syntax_manual")
rivi 15:   so <sfile>:p:h/nosyntax.vim
rivi 16: endif
rivi 17: 
rivi 18: " Load the Syntax autocommands and set the default methods for highlighting.
rivi 19: runtime syntax/synload.vim
Etsitään ilmausta syntax/synload.vim kohteesta /home/ollpu/.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/ollpu/.vim/after
Etsitään ilmausta /home/ollpu/.vim/syntax/synload.vim
Etsitään ilmausta /var/lib/vim/addons/syntax/synload.vim
Etsitään ilmausta /usr/share/vim/vimfiles/syntax/synload.vim
Etsitään ilmausta /usr/share/vim/vim74/syntax/synload.vim
chdir(/usr/share/vim/vim74/syntax)
fchdir() to previous dir
rivi 19: ladataan /usr/share/vim/vim74/syntax/synload.vim
rivi 1: " Vim syntax support file
rivi 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
rivi 3: " Last Change:^I2012 Sep 25
rivi 4: 
rivi 5: " This file sets up for syntax highlighting.
rivi 6: " It is loaded from "syntax.vim" and "manual.vim".
rivi 7: " 1. Set the default highlight groups.
rivi 8: " 2. Install Syntax autocommands for all the available syntax files.
rivi 9: 
rivi 10: if !has("syntax")
rivi 11:   finish
rivi 12: endif
rivi 13: 
rivi 14: " let others know that syntax has been switched on
rivi 15: let syntax_on = 1
rivi 16: 
rivi 17: " Set the default highlighting colors.  Use a color scheme if specified.
rivi 18: if exists("colors_name")
rivi 19:   exe "colors " . colors_name
rivi 20: else
rivi 21:   runtime! syntax/syncolor.vim
Etsitään ilmausta syntax/syncolor.vim kohteesta /home/ollpu/.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/ollpu/.vim/after
Etsitään ilmausta /home/ollpu/.vim/syntax/syncolor.vim
Etsitään ilmausta /var/lib/vim/addons/syntax/syncolor.vim
Etsitään ilmausta /usr/share/vim/vimfiles/syntax/syncolor.vim
Etsitään ilmausta /usr/share/vim/vim74/syntax/syncolor.vim
chdir(/usr/share/vim/vim74/syntax)
fchdir() to previous dir
rivi 21: ladataan /usr/share/vim/vim74/syntax/syncolor.vim
rivi 1: " Vim syntax support file
rivi 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
rivi 3: " Last Change:^I2001 Sep 12
rivi 4: 
rivi 5: " This file sets up the default methods for highlighting.
rivi 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
rivi 7: " Also used from init_highlight().
rivi 8: 
rivi 9: if !exists("syntax_cmd") || syntax_cmd == "on"
rivi 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
rivi 11:   command -nargs=* SynColor hi <args>
rivi 12:   command -nargs=* SynLink hi link <args>
rivi 13: else
rivi 14:   if syntax_cmd == "enable"
rivi 15:     " ":syntax enable" keeps any existing colors
rivi 16:     command -nargs=* SynColor hi def <args>
rivi 17:     command -nargs=* SynLink hi def link <args>
rivi 18:   elseif syntax_cmd == "reset"
rivi 19:     " ":syntax reset" resets all colors to the default
rivi 20:     command -nargs=* SynColor hi <args>
rivi 21:     command -nargs=* SynLink hi! link <args>
rivi 22:   else
rivi 23:     " User defined syncolor file has already set the colors.
rivi 24:     finish
rivi 25:   endif
rivi 26: endif
rivi 27: 
rivi 28: " Many terminals can only use six different colors (plus black and white).
rivi 29: " Therefore the number of colors used is kept low. It doesn't look nice with
rivi 30: " too many colors anyway.
rivi 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
rivi 32: " There are two sets of defaults: for a dark and a light background.
rivi 33: if &background == "dark"
rivi 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
rivi 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
rivi 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
rivi 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
rivi 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
rivi 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
rivi 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
rivi 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
rivi 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
rivi 43: else
rivi 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
rivi 44: hi Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
rivi 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
rivi 45: hi Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
rivi 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
rivi 46: hi Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
rivi 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
rivi 47: hi Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
rivi 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
rivi 48: hi Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
rivi 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
rivi 49: hi PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
rivi 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
rivi 50: hi Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
rivi 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
rivi 51: hi Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
rivi 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
rivi 52: hi Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
rivi 53: endif
rivi 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
rivi 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
rivi 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
rivi 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
rivi 56: 
rivi 57: " Common groups that link to default highlighting.
rivi 58: " You can specify other highlighting easily.
rivi 59: SynLink String^I^IConstant
rivi 59: hi link String^I^IConstant
rivi 60: SynLink Character^IConstant
rivi 60: hi link Character^IConstant
rivi 61: SynLink Number^I^IConstant
rivi 61: hi link Number^I^IConstant
rivi 62: SynLink Boolean^I^IConstant
rivi 62: hi link Boolean^I^IConstant
rivi 63: SynLink Float^I^INumber
rivi 63: hi link Float^I^INumber
rivi 64: SynLink Function^IIdentifier
rivi 64: hi link Function^IIdentifier
rivi 65: SynLink Conditional^IStatement
rivi 65: hi link Conditional^IStatement
rivi 66: SynLink Repeat^I^IStatement
rivi 66: hi link Repeat^I^IStatement
rivi 67: SynLink Label^I^IStatement
rivi 67: hi link Label^I^IStatement
rivi 68: SynLink Operator^IStatement
rivi 68: hi link Operator^IStatement
rivi 69: SynLink Keyword^I^IStatement
rivi 69: hi link Keyword^I^IStatement
rivi 70: SynLink Exception^IStatement
rivi 70: hi link Exception^IStatement
rivi 71: SynLink Include^I^IPreProc
rivi 71: hi link Include^I^IPreProc
rivi 72: SynLink Define^I^IPreProc
rivi 72: hi link Define^I^IPreProc
rivi 73: SynLink Macro^I^IPreProc
rivi 73: hi link Macro^I^IPreProc
rivi 74: SynLink PreCondit^IPreProc
rivi 74: hi link PreCondit^IPreProc
rivi 75: SynLink StorageClass^IType
rivi 75: hi link StorageClass^IType
rivi 76: SynLink Structure^IType
rivi 76: hi link Structure^IType
rivi 77: SynLink Typedef^I^IType
rivi 77: hi link Typedef^I^IType
rivi 78: SynLink Tag^I^ISpecial
rivi 78: hi link Tag^I^ISpecial
rivi 79: SynLink SpecialChar^ISpecial
rivi 79: hi link SpecialChar^ISpecial
rivi 80: SynLink Delimiter^ISpecial
rivi 80: hi link Delimiter^ISpecial
rivi 81: SynLink SpecialComment^ISpecial
rivi 81: hi link SpecialComment^ISpecial
rivi 82: SynLink Debug^I^ISpecial
rivi 82: hi link Debug^I^ISpecial
rivi 83: 
rivi 84: delcommand SynColor
rivi 85: delcommand SynLink
ladattu /usr/share/vim/vim74/syntax/syncolor.vim
jatkaa kohdassa /usr/share/vim/vim74/syntax/synload.vim
Etsitään ilmausta /usr/share/vim/vimfiles/after/syntax/syncolor.vim
Etsitään ilmausta /var/lib/vim/addons/after/syntax/syncolor.vim
Etsitään ilmausta /home/ollpu/.vim/after/syntax/syncolor.vim
rivi 22: endif
rivi 23: 
rivi 24: " Line continuation is used here, remove 'C' from 'cpoptions'
rivi 25: let s:cpo_save = &cpo
rivi 26: set cpo&vim
rivi 27: 
rivi 28: " First remove all old syntax autocommands.
rivi 29: au! Syntax
rivi 30: 
rivi 31: au Syntax *^I^Icall s:SynSet()
rivi 32: 
rivi 33: fun! s:SynSet()
rivi 61: 
rivi 62: 
rivi 63: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
rivi 68: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif
rivi 69: 
rivi 70: 
rivi 71: " Source the user-specified syntax highlighting file
rivi 72: if exists("mysyntaxfile") && filereadable(expand(mysyntaxfile))
rivi 73:   execute "source " . mysyntaxfile
rivi 74: endif
rivi 75: 
rivi 76: " Restore 'cpoptions'
rivi 77: let &cpo = s:cpo_save
rivi 78: unlet s:cpo_save
ladattu /usr/share/vim/vim74/syntax/synload.vim
jatkaa kohdassa /usr/share/vim/vim74/syntax/syntax.vim
rivi 20: 
rivi 21: " Load the FileType autocommands if not done yet.
rivi 22: if exists("did_load_filetypes")
rivi 23:   let s:did_ft = 1
rivi 24: else
rivi 25:   filetype on
Etsitään ilmausta filetype.vim kohteesta /home/ollpu/.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/ollpu/.vim/after
Etsitään ilmausta /home/ollpu/.vim/filetype.vim
Etsitään ilmausta /var/lib/vim/addons/filetype.vim
Etsitään ilmausta /usr/share/vim/vimfiles/filetype.vim
Etsitään ilmausta /usr/share/vim/vim74/filetype.vim
chdir(/usr/share/vim/vim74)
fchdir() to previous dir
rivi 25: ladataan /usr/share/vim/vim74/filetype.vim
rivi 1: " Vim support file to detect file types
rivi 2: "
rivi 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
rivi 4: " Last Change:^I2015 Dec 03
rivi 5: 
rivi 6: " Listen very carefully, I will say this only once
rivi 7: if exists("did_load_filetypes")
rivi 8:   finish
rivi 9: endif
rivi 10: let did_load_filetypes = 1
rivi 11: 
rivi 12: " Line continuation is used here, remove 'C' from 'cpoptions'
rivi 13: let s:cpo_save = &cpo
rivi 14: set cpo&vim
rivi 15: 
rivi 16: augroup filetypedetect
rivi 17: 
rivi 18: " Ignored extensions
rivi 19: if exists("*fnameescape")
rivi 21: au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
rivi 28: au BufNewFile,BufRead *~ let s:name = expand("<afile>") | let s:short = substitute(s:name, '\~$', '', '') | if s:name != s:short && s:short != "" |   exe "doau filetypedetect BufRead " . fnameescape(s:short) | endif | unlet! s:name s:short
rivi 32: au BufNewFile,BufRead ?\+.in if expand("<afile>:t") != "configure.in" |   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) | endif
rivi 33: elseif &verbose > 0
rivi 34:   echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
rivi 35: endif
rivi 36: 
rivi 37: " Pattern used to match file names which should not be inspected.
rivi 38: " Currently finds compressed files.
rivi 39: if !exists("g:ft_ignore_pat")
rivi 40:   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
rivi 41: endif
rivi 42: 
rivi 43: " Function used for patterns that end in a star: don't set the filetype if the
rivi 44: " file name matches ft_ignore_pat.
rivi 45: func! s:StarSetf(ft)
rivi 50: 
rivi 51: " Abaqus or Trasys
rivi 52: au BufNewFile,BufRead *.inp^I^I^Icall s:Check_inp()
rivi 53: 
rivi 54: func! s:Check_inp()
rivi 73: 
rivi 74: " A-A-P recipe
rivi 75: au BufNewFile,BufRead *.aap^I^I^Isetf aap
rivi 76: 
rivi 77: " A2ps printing utility
rivi 78: au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps
rivi 79: 
rivi 80: " ABAB/4
rivi 81: au BufNewFile,BufRead *.abap^I^I^Isetf abap
rivi 82: 
rivi 83: " ABC music notation
rivi 84: au BufNewFile,BufRead *.abc^I^I^Isetf abc
rivi 85: 
rivi 86: " ABEL
rivi 87: au BufNewFile,BufRead *.abl^I^I^Isetf abel
rivi 88: 
rivi 89: " AceDB
rivi 90: au BufNewFile,BufRead *.wrm^I^I^Isetf acedb
rivi 91: 
rivi 92: " Ada (83, 9X, 95)
rivi 93: au BufNewFile,BufRead *.adb,*.ads,*.ada^I^Isetf ada
rivi 94: if has("vms")
rivi 95:   au BufNewFile,BufRead *.gpr,*.ada_m,*.adc^Isetf ada
rivi 96: else
rivi 97:   au BufNewFile,BufRead *.gpr^I^I^Isetf ada
rivi 98: endif
rivi 99: 
rivi 100: " AHDL
rivi 101: au BufNewFile,BufRead *.tdf^I^I^Isetf ahdl
rivi 102: 
rivi 103: " AMPL
rivi 104: au BufNewFile,BufRead *.run^I^I^Isetf ampl
rivi 105: 
rivi 106: " Ant
rivi 107: au BufNewFile,BufRead build.xml^I^I^Isetf ant
rivi 108: 
rivi 109: " Arduino
rivi 110: au BufNewFile,BufRead *.ino,*.pde^I^Isetf arduino
rivi 111: 
rivi 112: " Apache style config file
rivi 113: au BufNewFile,BufRead proftpd.conf*^I^Icall s:StarSetf('apachestyle')
rivi 114: 
rivi 115: " Apache config file
rivi 116: au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf^I^Isetf apache
rivi 117: 
rivi 118: " XA65 MOS6510 cross assembler
rivi 119: au BufNewFile,BufRead *.a65^I^I^Isetf a65
rivi 120: 
rivi 121: " Applescript
rivi 122: au BufNewFile,BufRead *.scpt^I^I^Isetf applescript
rivi 123: 
rivi 124: " Applix ELF
rivi 126: au BufNewFile,BufRead *.am if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif
rivi 127: 
rivi 128: " ALSA configuration
rivi 129: au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf
rivi 130: 
rivi 131: " Arc Macro Language
rivi 132: au BufNewFile,BufRead *.aml^I^I^Isetf aml
rivi 133: 
rivi 134: " APT config file
rivi 135: au BufNewFile,BufRead apt.conf^I^I       setf aptconf
rivi 136: au BufNewFile,BufRead */.aptitude/config       setf aptconf
rivi 137: au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf
rivi 138: 
rivi 139: " Arch Inventory file
rivi 140: au BufNewFile,BufRead .arch-inventory,=tagging-method^Isetf arch
rivi 141: 
rivi 142: " ART*Enterprise (formerly ART-IM)
rivi 143: au BufNewFile,BufRead *.art^I^I^Isetf art
rivi 144: 
rivi 145: " AsciiDoc
rivi 146: au BufNewFile,BufRead *.asciidoc,*.adoc^I^Isetf asciidoc
rivi 147: 
rivi 148: " ASN.1
rivi 149: au BufNewFile,BufRead *.asn,*.asn1^I^Isetf asn
rivi 150: 
rivi 151: " Active Server Pages (with Visual Basic Script)
rivi 157: au BufNewFile,BufRead *.asa if exists("g:filetype_asa") |   exe "setf " . g:filetype_asa | else |   setf aspvbs | endif
rivi 158: 
rivi 159: " Active Server Pages (with Perl or Visual Basic Script)
rivi 167: au BufNewFile,BufRead *.asp if exists("g:filetype_asp") |   exe "setf " . g:filetype_asp | elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |   setf aspperl | else |   setf aspvbs | endif
rivi 168: 
rivi 169: " Grub (must be before catch *.lst)
rivi 170: au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub
rivi 171: 
rivi 172: " Assembly (all kinds)
rivi 173: " *.lst is not pure assembly, it has two extra columns (address, byte codes)
rivi 174: au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst^Icall s:FTasm()
rivi 175: 
rivi 176: " This function checks for the kind of assembly that is wanted by the user, or
rivi 177: " can be detected from the first five lines of the file.
rivi 178: func! s:FTasm()
rivi 199: 
rivi 200: func! s:FTasmsyntax()
rivi 212: 
rivi 213: " Macro (VAX)
rivi 214: au BufNewFile,BufRead *.mar^I^I^Isetf vmasm
rivi 215: 
rivi 216: " Atlas
rivi 217: au BufNewFile,BufRead *.atl,*.as^I^Isetf atlas
rivi 218: 
rivi 219: " Autoit v3
rivi 220: au BufNewFile,BufRead *.au3^I^I^Isetf autoit
rivi 221: 
rivi 222: " Autohotkey
rivi 223: au BufNewFile,BufRead *.ahk^I^I^Isetf autohotkey
rivi 224: 
rivi 225: " Automake
rivi 226: au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am^Isetf automake
rivi 227: 
rivi 228: " Autotest .at files are actually m4
rivi 229: au BufNewFile,BufRead *.at^I^I^Isetf m4
rivi 230: 
rivi 231: " Avenue
rivi 232: au BufNewFile,BufRead *.ave^I^I^Isetf ave
rivi 233: 
rivi 234: " Awk
rivi 235: au BufNewFile,BufRead *.awk^I^I^Isetf awk
rivi 236: 
rivi 237: " B
rivi 238: au BufNewFile,BufRead *.mch,*.ref,*.imp^I^Isetf b
rivi 239: 
rivi 240: " BASIC or Visual Basic
rivi 241: au BufNewFile,BufRead *.bas^I^I^Icall s:FTVB("basic")
rivi 242: 
rivi 243: " Check if one of the first five lines contains "VB_Name".  In that case it is
rivi 244: " probably a Visual Basic file.  Otherwise it's assumed to be "alt" filetype.
rivi 245: func! s:FTVB(alt)
rivi 252: 
rivi 253: " Visual Basic Script (close to Visual Basic) or Visual Basic .NET
rivi 254: au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl^Isetf vb
rivi 255: 
rivi 256: " IBasic file (similar to QBasic)
rivi 257: au BufNewFile,BufRead *.iba,*.ibi^I^Isetf ibasic
rivi 258: 
rivi 259: " FreeBasic file (similar to QBasic)
rivi 260: au BufNewFile,BufRead *.fb,*.bi^I^I^Isetf freebasic
rivi 261: 
rivi 262: " Batch file for MSDOS.
rivi 263: au BufNewFile,BufRead *.bat,*.sys^I^Isetf dosbatch
rivi 264: " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.
rivi 266: au BufNewFile,BufRead *.cmd if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif
rivi 267: 
rivi 268: " Batch file for 4DOS
rivi 269: au BufNewFile,BufRead *.btm^I^I^Icall s:FTbtm()
rivi 270: func! s:FTbtm()
rivi 277: 
rivi 278: " BC calculator
rivi 279: au BufNewFile,BufRead *.bc^I^I^Isetf bc
rivi 280: 
rivi 281: " BDF font
rivi 282: au BufNewFile,BufRead *.bdf^I^I^Isetf bdf
rivi 283: 
rivi 284: " BibTeX bibliography database file
rivi 285: au BufNewFile,BufRead *.bib^I^I^Isetf bib
rivi 286: 
rivi 287: " BibTeX Bibliography Style
rivi 288: au BufNewFile,BufRead *.bst^I^I^Isetf bst
rivi 289: 
rivi 290: " BIND configuration
rivi 291: au BufNewFile,BufRead named.conf,rndc.conf^Isetf named
rivi 292: 
rivi 293: " BIND zone
rivi 294: au BufNewFile,BufRead named.root^I^Isetf bindzone
rivi 295: au BufNewFile,BufRead *.db^I^I^Icall s:BindzoneCheck('')
rivi 296: 
rivi 297: func! s:BindzoneCheck(default)
rivi 304: 
rivi 305: " Blank
rivi 306: au BufNewFile,BufRead *.bl^I^I^Isetf blank
rivi 307: 
rivi 308: " Blkid cache file
rivi 309: au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml
rivi 310: 
rivi 311: " Bazel (http://bazel.io)
rivi 312: autocmd BufRead,BufNewFile *.bzl,BUILD,WORKSPACE setfiletype bzl
rivi 313: 
rivi 314: " C or lpc
rivi 315: au BufNewFile,BufRead *.c^I^I^Icall s:FTlpc()
rivi 316: 
rivi 317: func! s:FTlpc()
rivi 330: 
rivi 331: " Calendar
rivi 332: au BufNewFile,BufRead calendar^I^I^Isetf calendar
rivi 333: 
rivi 334: " C#
rivi 335: au BufNewFile,BufRead *.cs^I^I^Isetf cs
rivi 336: 
rivi 337: " CSDL
rivi 338: au BufNewFile,BufRead *.csdl^I^I^Isetf csdl
rivi 339: 
rivi 340: " Cabal
rivi 341: au BufNewFile,BufRead *.cabal^I^I^Isetf cabal
rivi 342: 
rivi 343: " Cdrdao TOC
rivi 344: au BufNewFile,BufRead *.toc^I^I^Isetf cdrtoc
rivi 345: 
rivi 346: " Cdrdao config
rivi 347: au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao^Isetf cdrdaoconf
rivi 348: 
rivi 349: " Cfengine
rivi 350: au BufNewFile,BufRead cfengine.conf^I^Isetf cfengine
rivi 351: 
rivi 352: " ChaiScript
rivi 353: au BufRead,BufNewFile *.chai^I^I^Isetf chaiscript
rivi 354: 
rivi 355: " Comshare Dimension Definition Language
rivi 356: au BufNewFile,BufRead *.cdl^I^I^Isetf cdl
rivi 357: 
rivi 358: " Conary Recipe
rivi 359: au BufNewFile,BufRead *.recipe^I^I^Isetf conaryrecipe
rivi 360: 
rivi 361: " Controllable Regex Mutilator
rivi 362: au BufNewFile,BufRead *.crm^I^I^Isetf crm
rivi 363: 
rivi 364: " Cyn++
rivi 365: au BufNewFile,BufRead *.cyn^I^I^Isetf cynpp
rivi 366: 
rivi 367: " Cynlib
rivi 368: " .cc and .cpp files can be C++ or Cynlib.
rivi 370: au BufNewFile,BufRead *.cc if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif
rivi 372: au BufNewFile,BufRead *.cpp if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif
rivi 373: 
rivi 374: " C++
rivi 375: au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
rivi 376: if has("fname_case")
rivi 377:   au BufNewFile,BufRead *.C,*.H setf cpp
rivi 378: endif
rivi 379: 
rivi 380: " .h files can be C, Ch C++, ObjC or ObjC++.
rivi 381: " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is
rivi 382: " detected automatically.
rivi 383: au BufNewFile,BufRead *.h^I^I^Icall s:FTheader()
rivi 384: 
rivi 385: func! s:FTheader()
rivi 400: 
rivi 401: " Ch (CHscript)
rivi 402: au BufNewFile,BufRead *.chf^I^I^Isetf ch
rivi 403: 
rivi 404: " TLH files are C++ headers generated by Visual C++'s #import from typelibs
rivi 405: au BufNewFile,BufRead *.tlh^I^I^Isetf cpp
rivi 406: 
rivi 407: " Cascading Style Sheets
rivi 408: au BufNewFile,BufRead *.css^I^I^Isetf css
rivi 409: 
rivi 410: " Century Term Command Scripts (*.cmd too)
rivi 411: au BufNewFile,BufRead *.con^I^I^Isetf cterm
rivi 412: 
rivi 413: " Changelog
rivi 415: au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch^Isetf debchangelog
rivi 416: 
rivi 422: au BufNewFile,BufRead [cC]hange[lL]og  if getline(1) =~ '; urgency='|   setf debchangelog| else|   setf changelog| endif
rivi 423: 
rivi 427: au BufNewFile,BufRead NEWS  if getline(1) =~ '; urgency='|   setf debchangelog| endif
rivi 428: 
rivi 429: " CHILL
rivi 430: au BufNewFile,BufRead *..ch^I^I^Isetf chill
rivi 431: 
rivi 432: " Changes for WEB and CWEB or CHILL
rivi 433: au BufNewFile,BufRead *.ch^I^I^Icall s:FTchange()
rivi 434: 
rivi 435: " This function checks if one of the first ten lines start with a '@'.  In
rivi 436: " that case it is probably a change file.
rivi 437: " If the first line starts with # or ! it's probably a ch file.
rivi 438: " If a line has "main", "include", "//" ir "/*" it's probably ch.
rivi 439: " Otherwise CHILL is assumed.
rivi 440: func! s:FTchange()
rivi 463: 
rivi 464: " ChordPro
rivi 465: au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro^Isetf chordpro
rivi 466: 
rivi 467: " Clean
rivi 468: au BufNewFile,BufRead *.dcl,*.icl^I^Isetf clean
rivi 469: 
rivi 470: " Clever
rivi 471: au BufNewFile,BufRead *.eni^I^I^Isetf cl
rivi 472: 
rivi 473: " Clever or dtd
rivi 474: au BufNewFile,BufRead *.ent^I^I^Icall s:FTent()
rivi 475: 
rivi 476: func! s:FTent()
rivi 495: 
rivi 496: " Clipper (or FoxPro; could also be eviews)
rivi 502: au BufNewFile,BufRead *.prg if exists("g:filetype_prg") |   exe "setf " . g:filetype_prg | else |   setf clipper | endif
rivi 503: 
rivi 504: " Clojure
rivi 505: au BufNewFile,BufRead *.clj,*.cljs,*.cljx,*.cljc^I^Isetf clojure
rivi 506: 
rivi 507: " Cmake
rivi 508: au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in^I^Isetf cmake
rivi 509: 
rivi 510: " Cmusrc
rivi 511: au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc
rivi 512: au BufNewFile,BufRead */cmus/{rc,*.theme}^I^I^Isetf cmusrc
rivi 513: 
rivi 514: " Cobol
rivi 515: au BufNewFile,BufRead *.cbl,*.cob,*.lib^Isetf cobol
rivi 516: "   cobol or zope form controller python script? (heuristic)
rivi 522: au BufNewFile,BufRead *.cpy if getline(1) =~ '^##' |   setf python | else |   setf cobol | endif
rivi 523: 
rivi 524: " Coco/R
rivi 525: au BufNewFile,BufRead *.atg^I^I^Isetf coco
rivi 526: 
rivi 527: " Cold Fusion
rivi 528: au BufNewFile,BufRead *.cfm,*.cfi,*.cfc^I^Isetf cf
rivi 529: 
rivi 530: " Configure scripts
rivi 531: au BufNewFile,BufRead configure.in,configure.ac setf config
rivi 532: 
rivi 533: " CUDA  Cumpute Unified Device Architecture
rivi 534: au BufNewFile,BufRead *.cu^I^I^Isetf cuda
rivi 535: 
rivi 536: " Dockerfile
rivi 537: au BufNewFile,BufRead Dockerfile^I^Isetf dockerfile
rivi 538: 
rivi 539: " WildPackets EtherPeek Decoder
rivi 540: au BufNewFile,BufRead *.dcd^I^I^Isetf dcd
rivi 541: 
rivi 542: " Enlightenment configuration files
rivi 543: au BufNewFile,BufRead *enlightenment/*.cfg^Isetf c
rivi 544: 
rivi 545: " Eterm
rivi 546: au BufNewFile,BufRead *Eterm/*.cfg^I^Isetf eterm
rivi 547: 
rivi 548: " Euphoria 3 or 4
rivi 549: au BufNewFile,BufRead *.eu,*.ew,*.ex,*.exu,*.exw  call s:EuphoriaCheck()
rivi 550: if has("fname_case")
rivi 551:    au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call s:EuphoriaCheck()
rivi 552: endif
rivi 553: 
rivi 554: func! s:EuphoriaCheck()
rivi 561: 
rivi 562: " Lynx config files
rivi 563: au BufNewFile,BufRead lynx.cfg^I^I^Isetf lynx
rivi 564: 
rivi 565: " Quake
rivi 566: au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg^Isetf quake
rivi 567: au BufNewFile,BufRead *quake[1-3]/*.cfg^I^I^Isetf quake
rivi 568: 
rivi 569: " Quake C
rivi 570: au BufNewFile,BufRead *.qc^I^I^Isetf c
rivi 571: 
rivi 572: " Configure files
rivi 573: au BufNewFile,BufRead *.cfg^I^I^Isetf cfg
rivi 574: 
rivi 575: " Cucumber
rivi 576: au BufNewFile,BufRead *.feature^I^I^Isetf cucumber
rivi 577: 
rivi 578: " Communicating Sequential Processes
rivi 579: au BufNewFile,BufRead *.csp,*.fdr^I^Isetf csp
rivi 580: 
rivi 581: " CUPL logic description and simulation
rivi 582: au BufNewFile,BufRead *.pld^I^I^Isetf cupl
rivi 583: au BufNewFile,BufRead *.si^I^I^Isetf cuplsim
rivi 584: 
rivi 585: " Debian Control
rivi 586: au BufNewFile,BufRead */debian/control^I^Isetf debcontrol
rivi 590: au BufNewFile,BufRead control  if getline(1) =~ '^Source:'|   setf debcontrol| endif
rivi 591: 
rivi 592: " Debian Sources.list
rivi 593: au BufNewFile,BufRead */etc/apt/sources.list^I^Isetf debsources
rivi 594: au BufNewFile,BufRead */etc/apt/sources.list.d/*.list^Isetf debsources
rivi 595: 
rivi 596: " Deny hosts
rivi 597: au BufNewFile,BufRead denyhosts.conf^I^Isetf denyhosts
rivi 598: 
rivi 599: " dnsmasq(8) configuration files
rivi 600: au BufNewFile,BufRead */etc/dnsmasq.conf^Isetf dnsmasq
rivi 601: 
rivi 602: " ROCKLinux package description
rivi 603: au BufNewFile,BufRead *.desc^I^I^Isetf desc
rivi 604: 
rivi 605: " the D language or dtrace
rivi 606: au BufNewFile,BufRead *.d^I^I^Icall s:DtraceCheck()
rivi 607: 
rivi 608: func! s:DtraceCheck()
rivi 619: 
rivi 620: " Desktop files
rivi 621: au BufNewFile,BufRead *.desktop,.directory^Isetf desktop
rivi 622: 
rivi 623: " Dict config
rivi 624: au BufNewFile,BufRead dict.conf,.dictrc^I^Isetf dictconf
rivi 625: 
rivi 626: " Dictd config
rivi 627: au BufNewFile,BufRead dictd.conf^I^Isetf dictdconf
rivi 628: 
rivi 629: " Diff files
rivi 630: au BufNewFile,BufRead *.diff,*.rej,*.patch^Isetf diff
rivi 631: 
rivi 632: " Dircolors
rivi 633: au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS^Isetf dircolors
rivi 634: 
rivi 635: " Diva (with Skill) or InstallShield
rivi 641: au BufNewFile,BufRead *.rul if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |   setf ishd | else |   setf diva | endif
rivi 642: 
rivi 643: " DCL (Digital Command Language - vms) or DNS zone file
rivi 644: au BufNewFile,BufRead *.com^I^I^Icall s:BindzoneCheck('dcl')
rivi 645: 
rivi 646: " DOT
rivi 647: au BufNewFile,BufRead *.dot^I^I^Isetf dot
rivi 648: 
rivi 649: " Dylan - lid files
rivi 650: au BufNewFile,BufRead *.lid^I^I^Isetf dylanlid
rivi 651: 
rivi 652: " Dylan - intr files (melange)
rivi 653: au BufNewFile,BufRead *.intr^I^I^Isetf dylanintr
rivi 654: 
rivi 655: " Dylan
rivi 656: au BufNewFile,BufRead *.dylan^I^I^Isetf dylan
rivi 657: 
rivi 658: " Microsoft Module Definition
rivi 659: au BufNewFile,BufRead *.def^I^I^Isetf def
rivi 660: 
rivi 661: " Dracula
rivi 662: au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe^Isetf dracula
rivi 663: 
rivi 664: " Datascript
rivi 665: au BufNewFile,BufRead *.ds^I^I^Isetf datascript
rivi 666: 
rivi 667: " dsl
rivi 668: au BufNewFile,BufRead *.dsl^I^I^Isetf dsl
rivi 669: 
rivi 670: " DTD (Document Type Definition for XML)
rivi 671: au BufNewFile,BufRead *.dtd^I^I^Isetf dtd
rivi 672: 
rivi 673: " DTS/DSTI (device tree files)
rivi 674: au BufNewFile,BufRead *.dts,*.dtsi^I^Isetf dts
rivi 675: 
rivi 676: " EDIF (*.edf,*.edif,*.edn,*.edo)
rivi 677: au BufNewFile,BufRead *.ed\(f\|if\|n\|o\)^Isetf edif
rivi 678: 
rivi 679: " Embedix Component Description
rivi 680: au BufNewFile,BufRead *.ecd^I^I^Isetf ecd
rivi 681: 
rivi 682: " Eiffel or Specman or Euphoria
rivi 683: au BufNewFile,BufRead *.e,*.E^I^I^Icall s:FTe()
rivi 684: 
rivi 685: " Elinks configuration
rivi 686: au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf^Isetf elinks
rivi 687: 
rivi 688: func! s:FTe()
rivi 703: 
rivi 704: " ERicsson LANGuage; Yaws is erlang too
rivi 705: au BufNewFile,BufRead *.erl,*.hrl,*.yaws^Isetf erlang
rivi 706: 
rivi 707: " Elm Filter Rules file
rivi 708: au BufNewFile,BufRead filter-rules^I^Isetf elmfilt
rivi 709: 
rivi 710: " ESMTP rc file
rivi 711: au BufNewFile,BufRead *esmtprc^I^I^Isetf esmtprc
rivi 712: 
rivi 713: " ESQL-C
rivi 714: au BufNewFile,BufRead *.ec,*.EC^I^I^Isetf esqlc
rivi 715: 
rivi 716: " Esterel
rivi 717: au BufNewFile,BufRead *.strl^I^I^Isetf esterel
rivi 718: 
rivi 719: " Essbase script
rivi 720: au BufNewFile,BufRead *.csc^I^I^Isetf csc
rivi 721: 
rivi 722: " Exim
rivi 723: au BufNewFile,BufRead exim.conf^I^I^Isetf exim
rivi 724: 
rivi 725: " Expect
rivi 726: au BufNewFile,BufRead *.exp^I^I^Isetf expect
rivi 727: 
rivi 728: " Exports
rivi 729: au BufNewFile,BufRead exports^I^I^Isetf exports
rivi 730: 
rivi 731: " Falcon
rivi 732: au BufNewFile,BufRead *.fal^I^I^Isetf falcon
rivi 733: 
rivi 734: " Fantom
rivi 735: au BufNewFile,BufRead *.fan,*.fwt^I^Isetf fan
rivi 736: 
rivi 737: " Factor
rivi 738: au BufNewFile,BufRead *.factor^I^I^Isetf factor
rivi 739: 
rivi 740: " Fetchmail RC file
rivi 741: au BufNewFile,BufRead .fetchmailrc^I^Isetf fetchmail
rivi 742: 
rivi 743: " FlexWiki - disabled, because it has side effects when a .wiki file
rivi 744: " is not actually FlexWiki
rivi 745: "au BufNewFile,BufRead *.wiki^I^I^Isetf flexwiki
rivi 746: 
rivi 747: " Focus Executable
rivi 748: au BufNewFile,BufRead *.fex,*.focexec^I^Isetf focexec
rivi 749: 
rivi 750: " Focus Master file (but not for auto.master)
rivi 751: au BufNewFile,BufRead auto.master^I^Isetf conf
rivi 752: au BufNewFile,BufRead *.mas,*.master^I^Isetf master
rivi 753: 
rivi 754: " Forth
rivi 755: au BufNewFile,BufRead *.fs,*.ft^I^I^Isetf forth
rivi 756: 
rivi 757: " Reva Forth
rivi 758: au BufNewFile,BufRead *.frt^I^I^Isetf reva
rivi 759: 
rivi 760: " Fortran
rivi 761: if has("fname_case")
rivi 762:   au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08^I setf fortran
rivi 763: endif
rivi 764: au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran
rivi 765: 
rivi 766: " Framescript
rivi 767: au BufNewFile,BufRead *.fsl^I^I^Isetf framescript
rivi 768: 
rivi 769: " FStab
rivi 770: au BufNewFile,BufRead fstab,mtab^I^Isetf fstab
rivi 771: 
rivi 772: " GDB command files
rivi 773: au BufNewFile,BufRead .gdbinit^I^I^Isetf gdb
rivi 774: 
rivi 775: " GDMO
rivi 776: au BufNewFile,BufRead *.mo,*.gdmo^I^Isetf gdmo
rivi 777: 
rivi 778: " Gedcom
rivi 779: au BufNewFile,BufRead *.ged,lltxxxxx.txt^Isetf gedcom
rivi 780: 
rivi 781: " Git
rivi 782: au BufNewFile,BufRead COMMIT_EDITMSG^I^Isetf gitcommit
rivi 783: au BufNewFile,BufRead MERGE_MSG^I^I^Isetf gitcommit
rivi 784: au BufNewFile,BufRead *.git/config,.gitconfig,.gitmodules setf gitconfig
rivi 785: au BufNewFile,BufRead *.git/modules/*/config^Isetf gitconfig
rivi 786: au BufNewFile,BufRead */.config/git/config^Isetf gitconfig
rivi 787: if !empty($XDG_CONFIG_HOME)
rivi 788:   au BufNewFile,BufRead $XDG_CONFIG_HOME/git/config^Isetf gitconfig
rivi 789: endif
rivi 790: au BufNewFile,BufRead git-rebase-todo^I^Isetf gitrebase
rivi 794: au BufNewFile,BufRead .msg.[0-9]* if getline(1) =~ '^From.*# This line is ignored.$' |   setf gitsendemail | endif
rivi 798: au BufNewFile,BufRead *.git/* if getline(1) =~ '^\x\{40\}\>\|^ref: ' |   setf git | endif
rivi 799: 
rivi 800: " Gkrellmrc
rivi 801: au BufNewFile,BufRead gkrellmrc,gkrellmrc_?^Isetf gkrellmrc
rivi 802: 
rivi 803: " GP scripts (2.0 and onward)
rivi 804: au BufNewFile,BufRead *.gp,.gprc^I^Isetf gp
rivi 805: 
rivi 806: " GPG
rivi 807: au BufNewFile,BufRead */.gnupg/options^I^Isetf gpg
rivi 808: au BufNewFile,BufRead */.gnupg/gpg.conf^I^Isetf gpg
rivi 809: au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg
rivi 810: 
rivi 811: " gnash(1) configuration files
rivi 812: au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash
rivi 813: 
rivi 814: " Gitolite
rivi 815: au BufNewFile,BufRead gitolite.conf^I^Isetf gitolite
rivi 816: au BufNewFile,BufRead */gitolite-admin/conf/*^Icall s:StarSetf('gitolite')
rivi 817: au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc^Isetf perl
rivi 818: 
rivi 819: " Gnuplot scripts
rivi 820: au BufNewFile,BufRead *.gpi^I^I^Isetf gnuplot
rivi 821: 
rivi 822: " Go (Google)
rivi 823: au BufNewFile,BufRead *.go^I^I^Isetf go
rivi 824: 
rivi 825: " GrADS scripts
rivi 826: au BufNewFile,BufRead *.gs^I^I^Isetf grads
rivi 827: 
rivi 828: " Gretl
rivi 829: au BufNewFile,BufRead *.gretl^I^I^Isetf gretl
rivi 830: 
rivi 831: " Groovy
rivi 832: au BufNewFile,BufRead *.gradle,*.groovy^I^Isetf groovy
rivi 833: 
rivi 834: " GNU Server Pages
rivi 835: au BufNewFile,BufRead *.gsp^I^I^Isetf gsp
rivi 836: 
rivi 837: " Group file
rivi 838: au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group
rivi 839: 
rivi 840: " GTK RC
rivi 841: au BufNewFile,BufRead .gtkrc,gtkrc^I^Isetf gtkrc
rivi 842: 
rivi 843: " Haml
rivi 844: au BufNewFile,BufRead *.haml^I^I^Isetf haml
rivi 845: 
rivi 846: " Hamster Classic | Playground files
rivi 847: au BufNewFile,BufRead *.hsc,*.hsm^I^Isetf hamster
rivi 848: 
rivi 849: " Haskell
rivi 850: au BufNewFile,BufRead *.hs,*.hs-boot^I^Isetf haskell
rivi 851: au BufNewFile,BufRead *.lhs^I^I^Isetf lhaskell
rivi 852: au BufNewFile,BufRead *.chs^I^I^Isetf chaskell
rivi 853: 
rivi 854: " Haste
rivi 855: au BufNewFile,BufRead *.ht^I^I^Isetf haste
rivi 856: au BufNewFile,BufRead *.htpp^I^I^Isetf hastepreproc
rivi 857: 
rivi 858: " Hercules
rivi 859: au BufNewFile,BufRead *.vc,*.ev,*.rs,*.sum,*.errsum^Isetf hercules
rivi 860: 
rivi 861: " HEX (Intel)
rivi 862: au BufNewFile,BufRead *.hex,*.h32^I^Isetf hex
rivi 863: 
rivi 864: " Tilde (must be before HTML)
rivi 865: au BufNewFile,BufRead *.t.html^I^I^Isetf tilde
rivi 866: 
rivi 867: " HTML (.shtml and .stm for server side)
rivi 868: au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call s:FThtml()
rivi 869: 
rivi 870: " Distinguish between HTML, XHTML and Django
rivi 871: func! s:FThtml()
rivi 886: 
rivi 887: " HTML with Ruby - eRuby
rivi 888: au BufNewFile,BufRead *.erb,*.rhtml^I^Isetf eruby
rivi 889: 
rivi 890: " HTML with M4
rivi 891: au BufNewFile,BufRead *.html.m4^I^I^Isetf htmlm4
rivi 892: 
rivi 893: " HTML Cheetah template
rivi 894: au BufNewFile,BufRead *.tmpl^I^I^Isetf htmlcheetah
rivi 895: 
rivi 896: " Host config
rivi 897: au BufNewFile,BufRead */etc/host.conf^I^Isetf hostconf
rivi 898: 
rivi 899: " Hosts access
rivi 900: au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess
rivi 901: 
rivi 902: " Hyper Builder
rivi 903: au BufNewFile,BufRead *.hb^I^I^Isetf hb
rivi 904: 
rivi 905: " Httest
rivi 906: au BufNewFile,BufRead *.htt,*.htb^I^Isetf httest
rivi 907: 
rivi 908: " Icon
rivi 909: au BufNewFile,BufRead *.icn^I^I^Isetf icon
rivi 910: 
rivi 911: " IDL (Interface Description Language)
rivi 912: au BufNewFile,BufRead *.idl^I^I^Icall s:FTidl()
rivi 913: 
rivi 914: " Distinguish between standard IDL and MS-IDL
rivi 915: func! s:FTidl()
rivi 926: 
rivi 927: " Microsoft IDL (Interface Description Language)  Also *.idl
rivi 928: " MOF = WMI (Windows Management Instrumentation) Managed Object Format
rivi 929: au BufNewFile,BufRead *.odl,*.mof^I^Isetf msidl
rivi 930: 
rivi 931: " Icewm menu
rivi 932: au BufNewFile,BufRead */.icewm/menu^I^Isetf icemenu
rivi 933: 
rivi 934: " Indent profile (must come before IDL *.pro!)
rivi 935: au BufNewFile,BufRead .indent.pro^I^Isetf indent
rivi 936: au BufNewFile,BufRead indent.pro^I^Icall s:ProtoCheck('indent')
rivi 937: 
rivi 938: " IDL (Interactive Data Language)
rivi 939: au BufNewFile,BufRead *.pro^I^I^Icall s:ProtoCheck('idlang')
rivi 940: 
rivi 941: " Distinguish between "default" and Cproto prototype file. */
rivi 942: func! s:ProtoCheck(default)
rivi 954: 
rivi 955: 
rivi 956: " Indent RC
rivi 957: au BufNewFile,BufRead indentrc^I^I^Isetf indent
rivi 958: 
rivi 959: " Inform
rivi 960: au BufNewFile,BufRead *.inf,*.INF^I^Isetf inform
rivi 961: 
rivi 962: " Initng
rivi 963: au BufNewFile,BufRead */etc/initng/*/*.i,*.ii^Isetf initng
rivi 964: 
rivi 965: " Innovation Data Processing
rivi 966: au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c ^Isetf upstreamdat
rivi 967: au BufRead,BufNewFile upstream.log\c,upstream.*.log\c,*.upstream.log\c ^Isetf upstreamlog
rivi 968: au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog
rivi 969: au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c ^Isetf usserverlog
rivi 970: au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c ^Isetf usw2kagtlog
rivi 971: 
rivi 972: " Ipfilter
rivi 973: au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules^Isetf ipfilter
rivi 974: 
rivi 975: " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
rivi 976: au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl^Isetf fgl
rivi 977: 
rivi 978: " .INI file for MSDOS
rivi 979: au BufNewFile,BufRead *.ini^I^I^Isetf dosini
rivi 980: 
rivi 981: " SysV Inittab
rivi 982: au BufNewFile,BufRead inittab^I^I^Isetf inittab
rivi 983: 
rivi 984: " Inno Setup
rivi 985: au BufNewFile,BufRead *.iss^I^I^Isetf iss
rivi 986: 
rivi 987: " J
rivi 988: au BufNewFile,BufRead *.ijs^I^I^Isetf j
rivi 989: 
rivi 990: " JAL
rivi 991: au BufNewFile,BufRead *.jal,*.JAL^I^Isetf jal
rivi 992: 
rivi 993: " Jam
rivi 994: au BufNewFile,BufRead *.jpl,*.jpr^I^Isetf jam
rivi 995: 
rivi 996: " Java
rivi 997: au BufNewFile,BufRead *.java,*.jav^I^Isetf java
rivi 998: 
rivi 999: " JavaCC
rivi 1000: au BufNewFile,BufRead *.jj,*.jjt^I^Isetf javacc
rivi 1001: 
rivi 1002: " JavaScript, ECMAScript
rivi 1003: au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx   setf javascript
rivi 1004: 
rivi 1005: " Java Server Pages
rivi 1006: au BufNewFile,BufRead *.jsp^I^I^Isetf jsp
rivi 1007: 
rivi 1008: " Java Properties resource file (note: doesn't catch font.properties.pl)
rivi 1009: au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??^Isetf jproperties
rivi 1010: au BufNewFile,BufRead *.properties_??_??_*^Icall s:StarSetf('jproperties')
rivi 1011: 
rivi 1012: " Jess
rivi 1013: au BufNewFile,BufRead *.clp^I^I^Isetf jess
rivi 1014: 
rivi 1015: " Jgraph
rivi 1016: au BufNewFile,BufRead *.jgr^I^I^Isetf jgraph
rivi 1017: 
rivi 1018: " Jovial
rivi 1019: au BufNewFile,BufRead *.jov,*.j73,*.jovial^Isetf jovial
rivi 1020: 
rivi 1021: " JSON
rivi 1022: au BufNewFile,BufRead *.json,*.jsonp^I^Isetf json
rivi 1023: 
rivi 1024: " Kixtart
rivi 1025: au BufNewFile,BufRead *.kix^I^I^Isetf kix
rivi 1026: 
rivi 1027: " Kimwitu[++]
rivi 1028: au BufNewFile,BufRead *.k^I^I^Isetf kwt
rivi 1029: 
rivi 1030: " Kivy
rivi 1031: au BufNewFile,BufRead *.kv^I^I^Isetf kivy
rivi 1032: 
rivi 1033: " KDE script
rivi 1034: au BufNewFile,BufRead *.ks^I^I^Isetf kscript
rivi 1035: 
rivi 1036: " Kconfig
rivi 1037: au BufNewFile,BufRead Kconfig,Kconfig.debug^Isetf kconfig
rivi 1038: 
rivi 1039: " Lace (ISE)
rivi 1040: au BufNewFile,BufRead *.ace,*.ACE^I^Isetf lace
rivi 1041: 
rivi 1042: " Latte
rivi 1043: au BufNewFile,BufRead *.latte,*.lte^I^Isetf latte
rivi 1044: 
rivi 1045: " Limits
rivi 1046: au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf^Isetf limits
rivi 1047: 
rivi 1048: " LambdaProlog (*.mod too, see Modsim)
rivi 1049: au BufNewFile,BufRead *.sig^I^I^Isetf lprolog
rivi 1050: 
rivi 1051: " LDAP LDIF
rivi 1052: au BufNewFile,BufRead *.ldif^I^I^Isetf ldif
rivi 1053: 
rivi 1054: " Ld loader
rivi 1055: au BufNewFile,BufRead *.ld^I^I^Isetf ld
rivi 1056: 
rivi 1057: " Less
rivi 1058: au BufNewFile,BufRead *.less^I^I^Isetf less
rivi 1059: 
rivi 1060: " Lex
rivi 1061: au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++^Isetf lex
rivi 1062: 
rivi 1063: " Libao
rivi 1064: au BufNewFile,BufRead */etc/libao.conf,*/.libao^Isetf libao
rivi 1065: 
rivi 1066: " Libsensors
rivi 1067: au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf^Isetf sensors
rivi 1068: 
rivi 1069: " LFTP
rivi 1070: au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc^Isetf lftp
rivi 1071: 
rivi 1072: " Lifelines (or Lex for C++!)
rivi 1073: au BufNewFile,BufRead *.ll^I^I^Isetf lifelines
rivi 1074: 
rivi 1075: " Lilo: Linux loader
rivi 1076: au BufNewFile,BufRead lilo.conf^I^I^Isetf lilo
rivi 1077: 
rivi 1078: " Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)
rivi 1079: if has("fname_case")
rivi 1080:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp
rivi 1081: else
rivi 1082:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp
rivi 1083: endif
rivi 1084: 
rivi 1085: " SBCL implementation of Common Lisp
rivi 1086: au BufNewFile,BufRead sbclrc,.sbclrc^I^Isetf lisp
rivi 1087: 
rivi 1088: " Liquid
rivi 1089: au BufNewFile,BufRead *.liquid^I^I^Isetf liquid
rivi 1090: 
rivi 1091: " Lite
rivi 1092: au BufNewFile,BufRead *.lite,*.lt^I^Isetf lite
rivi 1093: 
rivi 1094: " LiteStep RC files
rivi 1095: au BufNewFile,BufRead */LiteStep/*/*.rc^I^Isetf litestep
rivi 1096: 
rivi 1097: " Login access
rivi 1098: au BufNewFile,BufRead */etc/login.access^Isetf loginaccess
rivi 1099: 
rivi 1100: " Login defs
rivi 1101: au BufNewFile,BufRead */etc/login.defs^I^Isetf logindefs
rivi 1102: 
rivi 1103: " Logtalk
rivi 1104: au BufNewFile,BufRead *.lgt^I^I^Isetf logtalk
rivi 1105: 
rivi 1106: " LOTOS
rivi 1107: au BufNewFile,BufRead *.lot,*.lotos^I^Isetf lotos
rivi 1108: 
rivi 1109: " Lout (also: *.lt)
rivi 1110: au BufNewFile,BufRead *.lou,*.lout^I^Isetf lout
rivi 1111: 
rivi 1112: " Lua
rivi 1113: au BufNewFile,BufRead *.lua^I^I^Isetf lua
rivi 1114: 
rivi 1115: " Luarocks
rivi 1116: au BufNewFile,BufRead *.rockspec^I^Isetf lua
rivi 1117: 
rivi 1118: " Linden Scripting Language (Second Life)
rivi 1119: au BufNewFile,BufRead *.lsl^I^I^Isetf lsl
rivi 1120: 
rivi 1121: " Lynx style file (or LotusScript!)
rivi 1122: au BufNewFile,BufRead *.lss^I^I^Isetf lss
rivi 1123: 
rivi 1124: " M4
rivi 1126: au BufNewFile,BufRead *.m4 if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif
rivi 1127: 
rivi 1128: " MaGic Point
rivi 1129: au BufNewFile,BufRead *.mgp^I^I^Isetf mgp
rivi 1130: 
rivi 1131: " Mail (for Elm, trn, mutt, muttng, rn, slrn)
rivi 1132: au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail
rivi 1133: 
rivi 1134: " Mail aliases
rivi 1135: au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases^Isetf mailaliases
rivi 1136: 
rivi 1137: " Mailcap configuration file
rivi 1138: au BufNewFile,BufRead .mailcap,mailcap^I^Isetf mailcap
rivi 1139: 
rivi 1140: " Makefile
rivi 1141: au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make
rivi 1142: 
rivi 1143: " MakeIndex
rivi 1144: au BufNewFile,BufRead *.ist,*.mst^I^Isetf ist
rivi 1145: 
rivi 1146: " Mallard
rivi 1147: au BufNewFile,BufRead *.page^I^I^Isetf mallard
rivi 1148: 
rivi 1149: " Manpage
rivi 1150: au BufNewFile,BufRead *.man^I^I^Isetf man
rivi 1151: 
rivi 1152: " Man config
rivi 1153: au BufNewFile,BufRead */etc/man.conf,man.config^Isetf manconf
rivi 1154: 
rivi 1155: " Maple V
rivi 1156: au BufNewFile,BufRead *.mv,*.mpl,*.mws^I^Isetf maple
rivi 1157: 
rivi 1158: " Map (UMN mapserver config file)
rivi 1159: au BufNewFile,BufRead *.map^I^I^Isetf map
rivi 1160: 
rivi 1161: " Markdown
rivi 1162: au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,*.md  setf markdown
rivi 1163: 
rivi 1164: " Mason
rivi 1165: au BufNewFile,BufRead *.mason,*.mhtml,*.comp^Isetf mason
rivi 1166: 
rivi 1167: " Matlab or Objective C
rivi 1168: au BufNewFile,BufRead *.m^I^I^Icall s:FTm()
rivi 1169: 
rivi 1170: func! s:FTm()
rivi 1194: 
rivi 1195: " Mathematica notebook
rivi 1196: au BufNewFile,BufRead *.nb^I^I^Isetf mma
rivi 1197: 
rivi 1198: " Maya Extension Language
rivi 1199: au BufNewFile,BufRead *.mel^I^I^Isetf mel
rivi 1200: 
rivi 1201: " Mercurial (hg) commit file
rivi 1202: au BufNewFile,BufRead hg-editor-*.txt^I^Isetf hgcommit
rivi 1203: 
rivi 1204: " Mercurial config (looks like generic config file)
rivi 1205: au BufNewFile,BufRead *.hgrc,*hgrc^I^Isetf cfg
rivi 1206: 
rivi 1207: " Messages (logs mostly)
rivi 1208: au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages
rivi 1209: 
rivi 1210: " Metafont
rivi 1211: au BufNewFile,BufRead *.mf^I^I^Isetf mf
rivi 1212: 
rivi 1213: " MetaPost
rivi 1214: au BufNewFile,BufRead *.mp^I^I^Isetf mp
rivi 1215: 
rivi 1216: " MGL
rivi 1217: au BufNewFile,BufRead *.mgl^I^I^Isetf mgl
rivi 1218: 
rivi 1219: " MIX - Knuth assembly
rivi 1220: au BufNewFile,BufRead *.mix,*.mixal^I^Isetf mix
rivi 1221: 
rivi 1222: " MMIX or VMS makefile
rivi 1223: au BufNewFile,BufRead *.mms^I^I^Icall s:FTmms()
rivi 1224: 
rivi 1225: " Symbian meta-makefile definition (MMP)
rivi 1226: au BufNewFile,BufRead *.mmp^I^I^Isetf mmp
rivi 1227: 
rivi 1228: func! s:FTmms()
rivi 1244: 
rivi 1245: 
rivi 1246: " Modsim III (or LambdaProlog)
rivi 1252: au BufNewFile,BufRead *.mod if getline(1) =~ '\<module\>' |   setf lprolog | else |   setf modsim3 | endif
rivi 1253: 
rivi 1254: " Modula 2  (.md removed in favor of Markdown)
rivi 1255: au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.mi^Isetf modula2
rivi 1256: 
rivi 1257: " Modula 3 (.m3, .i3, .mg, .ig)
rivi 1258: au BufNewFile,BufRead *.[mi][3g]^I^Isetf modula3
rivi 1259: 
rivi 1260: " Monk
rivi 1261: au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc^Isetf monk
rivi 1262: 
rivi 1263: " MOO
rivi 1264: au BufNewFile,BufRead *.moo^I^I^Isetf moo
rivi 1265: 
rivi 1266: " Modconf
rivi 1267: au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf
rivi 1268: 
rivi 1269: " Mplayer config
rivi 1270: au BufNewFile,BufRead mplayer.conf,*/.mplayer/config^Isetf mplayerconf
rivi 1271: 
rivi 1272: " Motorola S record
rivi 1273: au BufNewFile,BufRead *.s19,*.s28,*.s37,*.mot,*.srec^Isetf srec
rivi 1274: 
rivi 1275: " Mrxvtrc
rivi 1276: au BufNewFile,BufRead mrxvtrc,.mrxvtrc^I^Isetf mrxvtrc
rivi 1277: 
rivi 1278: " Msql
rivi 1279: au BufNewFile,BufRead *.msql^I^I^Isetf msql
rivi 1280: 
rivi 1281: " Mysql
rivi 1282: au BufNewFile,BufRead *.mysql^I^I^Isetf mysql
rivi 1283: 
rivi 1284: " Mutt setup files (must be before catch *.rc)
rivi 1285: au BufNewFile,BufRead */etc/Muttrc.d/*^I^Icall s:StarSetf('muttrc')
rivi 1286: 
rivi 1287: " M$ Resource files
rivi 1288: au BufNewFile,BufRead *.rc,*.rch^I^Isetf rc
rivi 1289: 
rivi 1290: " MuPAD source
rivi 1291: au BufRead,BufNewFile *.mu^I^I^Isetf mupad
rivi 1292: 
rivi 1293: " Mush
rivi 1294: au BufNewFile,BufRead *.mush^I^I^Isetf mush
rivi 1295: 
rivi 1296: " Mutt setup file (also for Muttng)
rivi 1297: au BufNewFile,BufRead Mutt{ng,}rc^I^Isetf muttrc
rivi 1298: 
rivi 1299: " Nano
rivi 1300: au BufNewFile,BufRead */etc/nanorc,*.nanorc  ^Isetf nanorc
rivi 1301: 
rivi 1302: " Nastran input/DMAP
rivi 1303: "au BufNewFile,BufRead *.dat^I^I^Isetf nastran
rivi 1304: 
rivi 1305: " Natural
rivi 1306: au BufNewFile,BufRead *.NS[ACGLMNPS]^I^Isetf natural
rivi 1307: 
rivi 1308: " Netrc
rivi 1309: au BufNewFile,BufRead .netrc^I^I^Isetf netrc
rivi 1310: 
rivi 1311: " Ninja file
rivi 1312: au BufNewFile,BufRead *.ninja^I^I^Isetf ninja
rivi 1313: 
rivi 1314: " Novell netware batch files
rivi 1315: au BufNewFile,BufRead *.ncf^I^I^Isetf ncf
rivi 1316: 
rivi 1317: " Nroff/Troff (*.ms and *.t are checked below)
rivi 1321: au BufNewFile,BufRead *.me if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |   setf nroff | endif
rivi 1322: au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom^Isetf nroff
rivi 1323: au BufNewFile,BufRead *.[1-9]^I^I^Icall s:FTnroff()
rivi 1324: 
rivi 1325: " This function checks if one of the first five lines start with a dot.  In
rivi 1326: " that case it is probably an nroff file: 'filetype' is set and 1 is returned.
rivi 1327: func! s:FTnroff()
rivi 1334: 
rivi 1335: " Nroff or Objective C++
rivi 1336: au BufNewFile,BufRead *.mm^I^I^Icall s:FTmm()
rivi 1337: 
rivi 1338: func! s:FTmm()
rivi 1350: 
rivi 1351: " Not Quite C
rivi 1352: au BufNewFile,BufRead *.nqc^I^I^Isetf nqc
rivi 1353: 
rivi 1354: " NSIS
rivi 1355: au BufNewFile,BufRead *.nsi,*.nsh^I^Isetf nsis
rivi 1356: 
rivi 1357: " OCAML
rivi 1358: au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit^Isetf ocaml
rivi 1359: 
rivi 1360: " Occam
rivi 1361: au BufNewFile,BufRead *.occ^I^I^Isetf occam
rivi 1362: 
rivi 1363: " Omnimark
rivi 1364: au BufNewFile,BufRead *.xom,*.xin^I^Isetf omnimark
rivi 1365: 
rivi 1366: " OpenROAD
rivi 1367: au BufNewFile,BufRead *.or^I^I^Isetf openroad
rivi 1368: 
rivi 1369: " OPL
rivi 1370: au BufNewFile,BufRead *.[Oo][Pp][Ll]^I^Isetf opl
rivi 1371: 
rivi 1372: " Oracle config file
rivi 1373: au BufNewFile,BufRead *.ora^I^I^Isetf ora
rivi 1374: 
rivi 1375: " Packet filter conf
rivi 1376: au BufNewFile,BufRead pf.conf^I^I^Isetf pf
rivi 1377: 
rivi 1378: " Pam conf
rivi 1379: au BufNewFile,BufRead */etc/pam.conf^I^Isetf pamconf
rivi 1380: 
rivi 1381: " PApp
rivi 1382: au BufNewFile,BufRead *.papp,*.pxml,*.pxsl^Isetf papp
rivi 1383: 
rivi 1384: " Password file
rivi 1385: au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd
rivi 1386: 
rivi 1387: " Pascal (also *.p)
rivi 1388: au BufNewFile,BufRead *.pas^I^I^Isetf pascal
rivi 1389: 
rivi 1390: " Delphi project file
rivi 1391: au BufNewFile,BufRead *.dpr^I^I^Isetf pascal
rivi 1392: 
rivi 1393: " PDF
rivi 1394: au BufNewFile,BufRead *.pdf^I^I^Isetf pdf
rivi 1395: 
rivi 1396: " Perl
rivi 1397: if has("fname_case")
rivi 1398:   au BufNewFile,BufRead *.pl,*.PL^I^Icall s:FTpl()
rivi 1399: else
rivi 1400:   au BufNewFile,BufRead *.pl^I^I^Icall s:FTpl()
rivi 1401: endif
rivi 1402: au BufNewFile,BufRead *.plx,*.al^I^Isetf perl
rivi 1403: au BufNewFile,BufRead *.p6,*.pm6,*.pl6^I^Isetf perl6
rivi 1404: 
rivi 1405: func! s:FTpl()
rivi 1419: 
rivi 1420: " Perl, XPM or XPM2
rivi 1428: au BufNewFile,BufRead *.pm if getline(1) =~ "XPM2" |   setf xpm2 | elseif getline(1) =~ "XPM" |   setf xpm | else |   setf perl | endif
rivi 1429: 
rivi 1430: " Perl POD
rivi 1431: au BufNewFile,BufRead *.pod^I^I^Isetf pod
rivi 1432: au BufNewFile,BufRead *.pod6^I^I^Isetf pod6
rivi 1433: 
rivi 1434: " Php, php3, php4, etc.
rivi 1435: " Also Phtml (was used for PHP 2 in the past)
rivi 1436: " Also .ctp for Cake template file
rivi 1437: au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp^Isetf php
rivi 1438: 
rivi 1439: " Pike
rivi 1440: au BufNewFile,BufRead *.pike,*.lpc,*.ulpc,*.pmod setf pike
rivi 1441: 
rivi 1442: " Pinfo config
rivi 1443: au BufNewFile,BufRead */etc/pinforc,*/.pinforc^Isetf pinfo
rivi 1444: 
rivi 1445: " Palm Resource compiler
rivi 1446: au BufNewFile,BufRead *.rcp^I^I^Isetf pilrc
rivi 1447: 
rivi 1448: " Pine config
rivi 1449: au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex^I^Isetf pine
rivi 1450: 
rivi 1451: " PL/1, PL/I
rivi 1452: au BufNewFile,BufRead *.pli,*.pl1^I^Isetf pli
rivi 1453: 
rivi 1454: " PL/M (also: *.inp)
rivi 1455: au BufNewFile,BufRead *.plm,*.p36,*.pac^I^Isetf plm
rivi 1456: 
rivi 1457: " PL/SQL
rivi 1458: au BufNewFile,BufRead *.pls,*.plsql^I^Isetf plsql
rivi 1459: 
rivi 1460: " PLP
rivi 1461: au BufNewFile,BufRead *.plp^I^I^Isetf plp
rivi 1462: 
rivi 1463: " PO and PO template (GNU gettext)
rivi 1464: au BufNewFile,BufRead *.po,*.pot^I^Isetf po
rivi 1465: 
rivi 1466: " Postfix main config
rivi 1467: au BufNewFile,BufRead main.cf^I^I^Isetf pfmain
rivi 1468: 
rivi 1469: " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
rivi 1470: au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai^I  setf postscr
rivi 1471: 
rivi 1472: " PostScript Printer Description
rivi 1473: au BufNewFile,BufRead *.ppd^I^I^Isetf ppd
rivi 1474: 
rivi 1475: " Povray
rivi 1476: au BufNewFile,BufRead *.pov^I^I^Isetf pov
rivi 1477: 
rivi 1478: " Povray configuration
rivi 1479: au BufNewFile,BufRead .povrayrc^I^I^Isetf povini
rivi 1480: 
rivi 1481: " Povray, PHP or assembly
rivi 1482: au BufNewFile,BufRead *.inc^I^I^Icall s:FTinc()
rivi 1483: 
rivi 1484: func! s:FTinc()
rivi 1505: 
rivi 1506: " Printcap and Termcap
rivi 1508: au BufNewFile,BufRead *printcap let b:ptcap_type = "print" | setf ptcap
rivi 1510: au BufNewFile,BufRead *termcap let b:ptcap_type = "term" | setf ptcap
rivi 1511: 
rivi 1512: " PCCTS / ANTRL
rivi 1513: "au BufNewFile,BufRead *.g^I^I^Isetf antrl
rivi 1514: au BufNewFile,BufRead *.g^I^I^Isetf pccts
rivi 1515: 
rivi 1516: " PPWizard
rivi 1517: au BufNewFile,BufRead *.it,*.ih^I^I^Isetf ppwiz
rivi 1518: 
rivi 1519: " Obj 3D file format
rivi 1520: " TODO: is there a way to avoid MS-Windows Object files?
rivi 1521: au BufNewFile,BufRead *.obj^I^I^Isetf obj
rivi 1522: 
rivi 1523: " Oracle Pro*C/C++
rivi 1524: au BufNewFile,BufRead *.pc^I^I^Isetf proc
rivi 1525: 
rivi 1526: " Privoxy actions file
rivi 1527: au BufNewFile,BufRead *.action^I^I^Isetf privoxy
rivi 1528: 
rivi 1529: " Procmail
rivi 1530: au BufNewFile,BufRead .procmail,.procmailrc^Isetf procmail
rivi 1531: 
rivi 1532: " Progress or CWEB
rivi 1533: au BufNewFile,BufRead *.w^I^I^Icall s:FTprogress_cweb()
rivi 1534: 
rivi 1535: func! s:FTprogress_cweb()
rivi 1546: 
rivi 1547: " Progress or assembly
rivi 1548: au BufNewFile,BufRead *.i^I^I^Icall s:FTprogress_asm()
rivi 1549: 
rivi 1550: func! s:FTprogress_asm()
rivi 1572: 
rivi 1573: " Progress or Pascal
rivi 1574: au BufNewFile,BufRead *.p^I^I^Icall s:FTprogress_pascal()
rivi 1575: 
rivi 1576: func! s:FTprogress_pascal()
rivi 1600: 
rivi 1601: 
rivi 1602: " Software Distributor Product Specification File (POSIX 1387.2-1995)
rivi 1603: au BufNewFile,BufRead *.psf^I^I^Isetf psf
rivi 1607: au BufNewFile,BufRead INDEX,INFO if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |   setf psf | endif
rivi 1608: 
rivi 1609: " Prolog
rivi 1610: au BufNewFile,BufRead *.pdb^I^I^Isetf prolog
rivi 1611: 
rivi 1612: " Promela
rivi 1613: au BufNewFile,BufRead *.pml^I^I^Isetf promela
rivi 1614: 
rivi 1615: " Google protocol buffers
rivi 1616: au BufNewFile,BufRead *.proto^I^I^Isetf proto
rivi 1617: 
rivi 1618: " Protocols
rivi 1619: au BufNewFile,BufRead */etc/protocols^I^Isetf protocols
rivi 1620: 
rivi 1621: " Pyrex
rivi 1622: au BufNewFile,BufRead *.pyx,*.pxd^I^Isetf pyrex
rivi 1623: 
rivi 1624: " Python
rivi 1625: au BufNewFile,BufRead *.py,*.pyw^I^Isetf python
rivi 1626: 
rivi 1627: " Quixote (Python-based web framework)
rivi 1628: au BufNewFile,BufRead *.ptl^I^I^Isetf python
rivi 1629: 
rivi 1630: " Radiance
rivi 1631: au BufNewFile,BufRead *.rad,*.mat^I^Isetf radiance
rivi 1632: 
rivi 1633: " Ratpoison config/command files
rivi 1634: au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc^Isetf ratpoison
rivi 1635: 
rivi 1636: " RCS file
rivi 1637: au BufNewFile,BufRead *\,v^I^I^Isetf rcs
rivi 1638: 
rivi 1639: " Readline
rivi 1640: au BufNewFile,BufRead .inputrc,inputrc^I^Isetf readline
rivi 1641: 
rivi 1642: " Registry for MS-Windows
rivi 1644: au BufNewFile,BufRead *.reg if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif
rivi 1645: 
rivi 1646: " Renderman Interface Bytestream
rivi 1647: au BufNewFile,BufRead *.rib^I^I^Isetf rib
rivi 1648: 
rivi 1649: " Rexx
rivi 1650: au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit^Isetf rexx
rivi 1651: 
rivi 1652: " R (Splus)
rivi 1653: if has("fname_case")
rivi 1654:   au BufNewFile,BufRead *.s,*.S^I^I^Isetf r
rivi 1655: else
rivi 1656:   au BufNewFile,BufRead *.s^I^I^Isetf r
rivi 1657: endif
rivi 1658: 
rivi 1659: " R Help file
rivi 1660: if has("fname_case")
rivi 1661:   au BufNewFile,BufRead *.rd,*.Rd^I^Isetf rhelp
rivi 1662: else
rivi 1663:   au BufNewFile,BufRead *.rd^I^I^Isetf rhelp
rivi 1664: endif
rivi 1665: 
rivi 1666: " R noweb file
rivi 1667: if has("fname_case")
rivi 1668:   au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw^I^Isetf rnoweb
rivi 1669: else
rivi 1670:   au BufNewFile,BufRead *.rnw,*.snw^I^I^Isetf rnoweb
rivi 1671: endif
rivi 1672: 
rivi 1673: " R Markdown file
rivi 1674: if has("fname_case")
rivi 1675:   au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd^I^Isetf rmd
rivi 1676: else
rivi 1677:   au BufNewFile,BufRead *.rmd,*.smd^I^I^Isetf rmd
rivi 1678: endif
rivi 1679: 
rivi 1680: " R reStructuredText file
rivi 1681: if has("fname_case")
rivi 1682:   au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst^Isetf rrst
rivi 1683: else
rivi 1684:   au BufNewFile,BufRead *.rrst,*.srst^I^I^Isetf rrst
rivi 1685: endif
rivi 1686: 
rivi 1687: " Rexx, Rebol or R
rivi 1688: au BufNewFile,BufRead *.r,*.R^I^I^Icall s:FTr()
rivi 1689: 
rivi 1690: func! s:FTr()
rivi 1722: 
rivi 1723: " Remind
rivi 1724: au BufNewFile,BufRead .reminders,*.remind,*.rem^I^Isetf remind
rivi 1725: 
rivi 1726: " Resolv.conf
rivi 1727: au BufNewFile,BufRead resolv.conf^I^Isetf resolv
rivi 1728: 
rivi 1729: " Relax NG Compact
rivi 1730: au BufNewFile,BufRead *.rnc^I^I^Isetf rnc
rivi 1731: 
rivi 1732: " Relax NG XML
rivi 1733: au BufNewFile,BufRead *.rng^I^I^Isetf rng
rivi 1734: 
rivi 1735: " RPL/2
rivi 1736: au BufNewFile,BufRead *.rpl^I^I^Isetf rpl
rivi 1737: 
rivi 1738: " Robots.txt
rivi 1739: au BufNewFile,BufRead robots.txt^I^Isetf robots
rivi 1740: 
rivi 1741: " Rpcgen
rivi 1742: au BufNewFile,BufRead *.x^I^I^Isetf rpcgen
rivi 1743: 
rivi 1744: " reStructuredText Documentation Format
rivi 1745: au BufNewFile,BufRead *.rst^I^I^Isetf rst
rivi 1746: 
rivi 1747: " RTF
rivi 1748: au BufNewFile,BufRead *.rtf^I^I^Isetf rtf
rivi 1749: 
rivi 1750: " Interactive Ruby shell
rivi 1751: au BufNewFile,BufRead .irbrc,irbrc^I^Isetf ruby
rivi 1752: 
rivi 1753: " Ruby
rivi 1754: au BufNewFile,BufRead *.rb,*.rbw^I^Isetf ruby
rivi 1755: 
rivi 1756: " RubyGems
rivi 1757: au BufNewFile,BufRead *.gemspec^I^I^Isetf ruby
rivi 1758: 
rivi 1759: " Rackup
rivi 1760: au BufNewFile,BufRead *.ru^I^I^Isetf ruby
rivi 1761: 
rivi 1762: " Bundler
rivi 1763: au BufNewFile,BufRead Gemfile^I^I^Isetf ruby
rivi 1764: 
rivi 1765: " Ruby on Rails
rivi 1766: au BufNewFile,BufRead *.builder,*.rxml,*.rjs^Isetf ruby
rivi 1767: 
rivi 1768: " Rantfile and Rakefile is like Ruby
rivi 1769: au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake^Isetf ruby
rivi 1770: 
rivi 1771: " S-lang (or shader language, or SmallLisp)
rivi 1772: au BufNewFile,BufRead *.sl^I^I^Isetf slang
rivi 1773: 
rivi 1774: " Samba config
rivi 1775: au BufNewFile,BufRead smb.conf^I^I^Isetf samba
rivi 1776: 
rivi 1777: " SAS script
rivi 1778: au BufNewFile,BufRead *.sas^I^I^Isetf sas
rivi 1779: 
rivi 1780: " Sass
rivi 1781: au BufNewFile,BufRead *.sass^I^I^Isetf sass
rivi 1782: 
rivi 1783: " Sather
rivi 1784: au BufNewFile,BufRead *.sa^I^I^Isetf sather
rivi 1785: 
rivi 1786: " Scilab
rivi 1787: au BufNewFile,BufRead *.sci,*.sce^I^Isetf scilab
rivi 1788: 
rivi 1789: " SCSS
rivi 1790: au BufNewFile,BufRead *.scss^I^I^Isetf scss
rivi 1791: 
rivi 1792: " SD: Streaming Descriptors
rivi 1793: au BufNewFile,BufRead *.sd^I^I^Isetf sd
rivi 1794: 
rivi 1795: " SDL
rivi 1796: au BufNewFile,BufRead *.sdl,*.pr^I^Isetf sdl
rivi 1797: 
rivi 1798: " sed
rivi 1799: au BufNewFile,BufRead *.sed^I^I^Isetf sed
rivi 1800: 
rivi 1801: " Sieve (RFC 3028)
rivi 1802: au BufNewFile,BufRead *.siv^I^I^Isetf sieve
rivi 1803: 
rivi 1804: " Sendmail
rivi 1805: au BufNewFile,BufRead sendmail.cf^I^Isetf sm
rivi 1806: 
rivi 1807: " Sendmail .mc files are actually m4.  Could also be MS Message text file.
rivi 1808: au BufNewFile,BufRead *.mc^I^I^Icall s:McSetf()
rivi 1809: 
rivi 1810: func! s:McSetf()
rivi 1825: 
rivi 1826: " Services
rivi 1827: au BufNewFile,BufRead */etc/services^I^Isetf services
rivi 1828: 
rivi 1829: " Service Location config
rivi 1830: au BufNewFile,BufRead */etc/slp.conf^I^Isetf slpconf
rivi 1831: 
rivi 1832: " Service Location registration
rivi 1833: au BufNewFile,BufRead */etc/slp.reg^I^Isetf slpreg
rivi 1834: 
rivi 1835: " Service Location SPI
rivi 1836: au BufNewFile,BufRead */etc/slp.spi^I^Isetf slpspi
rivi 1837: 
rivi 1838: " Setserial config
rivi 1839: au BufNewFile,BufRead */etc/serial.conf^I^Isetf setserial
rivi 1840: 
rivi 1841: " SGML
rivi 1851: au BufNewFile,BufRead *.sgm,*.sgml if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |   setf sgmllnx | elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |   let b:docbk_type = "sgml" |   let b:docbk_ver = 4 |   setf docbk | else |   setf sgml | endif
rivi 1852: 
rivi 1853: " SGMLDECL
rivi 1857: au BufNewFile,BufRead *.decl,*.dcl,*.dec if getline(1).getline(2).getline(3) =~? '^<!SGML' |    setf sgmldecl | endif
rivi 1858: 
rivi 1859: " SGML catalog file
rivi 1860: au BufNewFile,BufRead catalog^I^I^Isetf catalog
rivi 1861: au BufNewFile,BufRead sgml.catalog*^I^Icall s:StarSetf('catalog')
rivi 1862: 
rivi 1863: " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
rivi 1864: " Gentoo ebuilds are actually bash scripts
rivi 1865: au BufNewFile,BufRead .bashrc*,bashrc,bash.bashrc,.bash[_-]profile*,.bash[_-]logout*,.bash[_-]aliases*,*.bash,*/{,.}bash[_-]completion{,.d,.sh}{,/*},*.ebuild,*.eclass call SetFileTypeSH("bash")
rivi 1866: au BufNewFile,BufRead .kshrc*,*.ksh call SetFileTypeSH("ksh")
rivi 1867: au BufNewFile,BufRead */etc/profile,.profile*,*.sh,*.env call SetFileTypeSH(getline(1))
rivi 1868: 
rivi 1869: " Also called from scripts.vim.
rivi 1870: func! SetFileTypeSH(name)
rivi 1913: 
rivi 1914: " For shell-like file types, check for an "exec" command hidden in a comment,
rivi 1915: " as used for Tcl.
rivi 1916: " Also called from scripts.vim, thus can't be local to this script.
rivi 1917: func! SetFileTypeShell(name)
rivi 1936: 
rivi 1937: " tcsh scripts
rivi 1938: au BufNewFile,BufRead .tcshrc*,*.tcsh,tcsh.tcshrc,tcsh.login^Icall SetFileTypeShell("tcsh")
rivi 1939: 
rivi 1940: " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
rivi 1941: au BufNewFile,BufRead .login*,.cshrc*,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call s:CSH()
rivi 1942: 
rivi 1943: func! s:CSH()
rivi 1952: 
rivi 1953: " Z-Shell script
rivi 1954: au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
rivi 1955: au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
rivi 1956: au BufNewFile,BufRead *.zsh^I^I^Isetf zsh
rivi 1957: 
rivi 1958: " Scheme
rivi 1959: au BufNewFile,BufRead *.scm,*.ss,*.rkt^I^Isetf scheme
rivi 1960: 
rivi 1961: " Screen RC
rivi 1962: au BufNewFile,BufRead .screenrc,screenrc^Isetf screen
rivi 1963: 
rivi 1964: " Simula
rivi 1965: au BufNewFile,BufRead *.sim^I^I^Isetf simula
rivi 1966: 
rivi 1967: " SINDA
rivi 1968: au BufNewFile,BufRead *.sin,*.s85^I^Isetf sinda
rivi 1969: 
rivi 1970: " SiSU
rivi 1971: au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
rivi 1972: au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu
rivi 1973: 
rivi 1974: " SKILL
rivi 1975: au BufNewFile,BufRead *.il,*.ils,*.cdf^I^Isetf skill
rivi 1976: 
rivi 1977: " SLRN
rivi 1978: au BufNewFile,BufRead .slrnrc^I^I^Isetf slrnrc
rivi 1979: au BufNewFile,BufRead *.score^I^I^Isetf slrnsc
rivi 1980: 
rivi 1981: " Smalltalk (and TeX)
rivi 1982: au BufNewFile,BufRead *.st^I^I^Isetf st
rivi 1990: au BufNewFile,BufRead *.cls if getline(1) =~ '^%' |  setf tex | elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |  setf rexx | else |  setf st | endif
rivi 1991: 
rivi 1992: " Smarty templates
rivi 1993: au BufNewFile,BufRead *.tpl^I^I^Isetf smarty
rivi 1994: 
rivi 1995: " SMIL or XML
rivi 2001: au BufNewFile,BufRead *.smil if getline(1) =~ '<?\s*xml.*?>' |   setf xml | else |   setf smil | endif
rivi 2002: 
rivi 2003: " SMIL or SNMP MIB file
rivi 2009: au BufNewFile,BufRead *.smi if getline(1) =~ '\<smil\>' |   setf smil | else |   setf mib | endif
rivi 2010: 
rivi 2011: " SMITH
rivi 2012: au BufNewFile,BufRead *.smt,*.smith^I^Isetf smith
rivi 2013: 
rivi 2014: " Snobol4 and spitbol
rivi 2015: au BufNewFile,BufRead *.sno,*.spt^I^Isetf snobol4
rivi 2016: 
rivi 2017: " SNMP MIB files
rivi 2018: au BufNewFile,BufRead *.mib,*.my^I^Isetf mib
rivi 2019: 
rivi 2020: " Snort Configuration
rivi 2021: au BufNewFile,BufRead *.hog,snort.conf,vision.conf^Isetf hog
rivi 2022: au BufNewFile,BufRead *.rules^I^I^Icall s:FTRules()
rivi 2023: 
rivi 2024: let s:ft_rules_udev_rules_pattern = '^\s*\cudev_rules\s*=\s*"\([^"]\{-1,}\)/*".*'
rivi 2025: func! s:FTRules()
rivi 2057: 
rivi 2058: 
rivi 2059: " Spec (Linux RPM)
rivi 2060: au BufNewFile,BufRead *.spec^I^I^Isetf spec
rivi 2061: 
rivi 2062: " Speedup (AspenTech plant simulator)
rivi 2063: au BufNewFile,BufRead *.speedup,*.spdata,*.spd^Isetf spup
rivi 2064: 
rivi 2065: " Slice
rivi 2066: au BufNewFile,BufRead *.ice^I^I^Isetf slice
rivi 2067: 
rivi 2068: " Spice
rivi 2069: au BufNewFile,BufRead *.sp,*.spice^I^Isetf spice
rivi 2070: 
rivi 2071: " Spyce
rivi 2072: au BufNewFile,BufRead *.spy,*.spi^I^Isetf spyce
rivi 2073: 
rivi 2074: " Squid
rivi 2075: au BufNewFile,BufRead squid.conf^I^Isetf squid
rivi 2076: 
rivi 2077: " SQL for Oracle Designer
rivi 2078: au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks^Isetf sql
rivi 2079: 
rivi 2080: " SQL
rivi 2081: au BufNewFile,BufRead *.sql^I^I^Icall s:SQL()
rivi 2082: 
rivi 2083: func! s:SQL()
rivi 2090: 
rivi 2091: " SQLJ
rivi 2092: au BufNewFile,BufRead *.sqlj^I^I^Isetf sqlj
rivi 2093: 
rivi 2094: " SQR
rivi 2095: au BufNewFile,BufRead *.sqr,*.sqi^I^Isetf sqr
rivi 2096: 
rivi 2097: " OpenSSH configuration
rivi 2098: au BufNewFile,BufRead ssh_config,*/.ssh/config^Isetf sshconfig
rivi 2099: 
rivi 2100: " OpenSSH server configuration
rivi 2101: au BufNewFile,BufRead sshd_config^I^Isetf sshdconfig
rivi 2102: 
rivi 2103: " Stata
rivi 2104: au BufNewFile,BufRead *.ado,*.class,*.do,*.imata,*.mata   setf stata
rivi 2105: 
rivi 2106: " SMCL
rivi 2107: au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl^Isetf smcl
rivi 2108: 
rivi 2109: " Stored Procedures
rivi 2110: au BufNewFile,BufRead *.stp^I^I^Isetf stp
rivi 2111: 
rivi 2112: " Standard ML
rivi 2113: au BufNewFile,BufRead *.sml^I^I^Isetf sml
rivi 2114: 
rivi 2115: " Sratus VOS command macro
rivi 2116: au BufNewFile,BufRead *.cm^I^I^Isetf voscm
rivi 2117: 
rivi 2118: " Sysctl
rivi 2119: au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf^Isetf sysctl
rivi 2120: 
rivi 2121: " Systemd unit files
rivi 2122: au BufNewFile,BufRead */systemd/*.{automount,mount,path,service,socket,swap,target,timer}^Isetf systemd
rivi 2123: 
rivi 2124: " Synopsys Design Constraints
rivi 2125: au BufNewFile,BufRead *.sdc^I^I^Isetf sdc
rivi 2126: 
rivi 2127: " Sudoers
rivi 2128: au BufNewFile,BufRead */etc/sudoers,sudoers.tmp^Isetf sudoers
rivi 2129: 
rivi 2130: " SVG (Scalable Vector Graphics)
rivi 2131: au BufNewFile,BufRead *.svg^I^I^Isetf svg
rivi 2132: 
rivi 2133: " If the file has an extension of 't' and is in a directory 't' or 'xt' then
rivi 2134: " it is almost certainly a Perl test file.
rivi 2135: " If the first line starts with '#' and contains 'perl' it's probably a Perl
rivi 2136: " file.
rivi 2137: " (Slow test) If a file contains a 'use' statement then it is almost certainly
rivi 2138: " a Perl file.
rivi 2139: func! s:FTperl()
rivi 2155: 
rivi 2156: " Tads (or Nroff or Perl test file)
rivi 2158: au BufNewFile,BufRead *.t if !s:FTnroff() && !s:FTperl() | setf tads | endif
rivi 2159: 
rivi 2160: " Tags
rivi 2161: au BufNewFile,BufRead tags^I^I^Isetf tags
rivi 2162: 
rivi 2163: " TAK
rivi 2164: au BufNewFile,BufRead *.tak^I^I^Isetf tak
rivi 2165: 
rivi 2166: " Task
rivi 2167: au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
rivi 2168: au BufRead,BufNewFile *.task^I^I^Isetf taskedit
rivi 2169: 
rivi 2170: " Tcl (JACL too)
rivi 2171: au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl^Isetf tcl
rivi 2172: 
rivi 2173: " TealInfo
rivi 2174: au BufNewFile,BufRead *.tli^I^I^Isetf tli
rivi 2175: 
rivi 2176: " Telix Salt
rivi 2177: au BufNewFile,BufRead *.slt^I^I^Isetf tsalt
rivi 2178: 
rivi 2179: " Tera Term Language
rivi 2180: au BufRead,BufNewFile *.ttl^I^I^Isetf teraterm
rivi 2181: 
rivi 2182: " Terminfo
rivi 2183: au BufNewFile,BufRead *.ti^I^I^Isetf terminfo
rivi 2184: 
rivi 2185: " TeX
rivi 2186: au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl^Isetf tex
rivi 2187: au BufNewFile,BufRead *.tex^I^I^Icall s:FTtex()
rivi 2188: 
rivi 2189: " Choose context, plaintex, or tex (LaTeX) based on these rules:
rivi 2190: " 1. Check the first line of the file for "%&<format>".
rivi 2191: " 2. Check the first 1000 non-comment lines for LaTeX or ConTeXt keywords.
rivi 2192: " 3. Default to "latex" or to g:tex_flavor, can be set in user's vimrc.
rivi 2193: func! s:FTtex()
rivi 2240: 
rivi 2241: " ConTeXt
rivi 2242: au BufNewFile,BufRead tex/context/*/*.tex,*.mkii,*.mkiv   setf context
rivi 2243: 
rivi 2244: " Texinfo
rivi 2245: au BufNewFile,BufRead *.texinfo,*.texi,*.txi^Isetf texinfo
rivi 2246: 
rivi 2247: " TeX configuration
rivi 2248: au BufNewFile,BufRead texmf.cnf^I^I^Isetf texmf
rivi 2249: 
rivi 2250: " Tidy config
rivi 2251: au BufNewFile,BufRead .tidyrc,tidyrc^I^Isetf tidy
rivi 2252: 
rivi 2253: " TF mud client
rivi 2254: au BufNewFile,BufRead *.tf,.tfrc,tfrc^I^Isetf tf
rivi 2255: 
rivi 2256: " TPP - Text Presentation Program
rivi 2257: au BufNewFile,BufReadPost *.tpp^I^I^Isetf tpp
rivi 2258: 
rivi 2259: " Treetop
rivi 2260: au BufRead,BufNewFile *.treetop^I^I^Isetf treetop
rivi 2261: 
rivi 2262: " Trustees
rivi 2263: au BufNewFile,BufRead trustees.conf^I^Isetf trustees
rivi 2264: 
rivi 2265: " TSS - Geometry
rivi 2266: au BufNewFile,BufReadPost *.tssgm^I^Isetf tssgm
rivi 2267: 
rivi 2268: " TSS - Optics
rivi 2269: au BufNewFile,BufReadPost *.tssop^I^Isetf tssop
rivi 2270: 
rivi 2271: " TSS - Command Line (temporary)
rivi 2272: au BufNewFile,BufReadPost *.tsscl^I^Isetf tsscl
rivi 2273: 
rivi 2274: " TWIG files
rivi 2275: au BufNewFile,BufReadPost *.twig^I^Isetf twig
rivi 2276: 
rivi 2277: " Motif UIT/UIL files
rivi 2278: au BufNewFile,BufRead *.uit,*.uil^I^Isetf uil
rivi 2279: 
rivi 2280: " Udev conf
rivi 2281: au BufNewFile,BufRead */etc/udev/udev.conf^Isetf udevconf
rivi 2282: 
rivi 2283: " Udev permissions
rivi 2284: au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
rivi 2285: "
rivi 2286: " Udev symlinks config
rivi 2287: au BufNewFile,BufRead */etc/udev/cdsymlinks.conf^Isetf sh
rivi 2288: 
rivi 2289: " UnrealScript
rivi 2290: au BufNewFile,BufRead *.uc^I^I^Isetf uc
rivi 2291: 
rivi 2292: " Updatedb
rivi 2293: au BufNewFile,BufRead */etc/updatedb.conf^Isetf updatedb
rivi 2294: 
rivi 2295: " Upstart (init(8)) config files
rivi 2296: au BufNewFile,BufRead */usr/share/upstart/*.conf^I       setf upstart
rivi 2297: au BufNewFile,BufRead */usr/share/upstart/*.override^I       setf upstart
rivi 2298: au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
rivi 2299: au BufNewFile,BufRead */.init/*.conf,*/.init/*.override        setf upstart
rivi 2300: au BufNewFile,BufRead */.config/upstart/*.conf^I^I       setf upstart
rivi 2301: au BufNewFile,BufRead */.config/upstart/*.override^I       setf upstart
rivi 2302: 
rivi 2303: " Vera
rivi 2304: au BufNewFile,BufRead *.vr,*.vri,*.vrh^I^Isetf vera
rivi 2305: 
rivi 2306: " Verilog HDL
rivi 2307: au BufNewFile,BufRead *.v^I^I^Isetf verilog
rivi 2308: 
rivi 2309: " Verilog-AMS HDL
rivi 2310: au BufNewFile,BufRead *.va,*.vams^I^Isetf verilogams
rivi 2311: 
rivi 2312: " SystemVerilog
rivi 2313: au BufNewFile,BufRead *.sv,*.svh^I^Isetf systemverilog
rivi 2314: 
rivi 2315: " VHDL
rivi 2316: au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl
rivi 2317: au BufNewFile,BufRead *.vhdl_[0-9]*^I^Icall s:StarSetf('vhdl')
rivi 2318: 
rivi 2319: " Vim script
rivi 2320: au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc^Isetf vim
rivi 2321: 
rivi 2322: " Viminfo file
rivi 2323: au BufNewFile,BufRead .viminfo,_viminfo^I^Isetf viminfo
rivi 2324: 
rivi 2325: " Virata Config Script File or Drupal module
rivi 2331: au BufRead,BufNewFile *.hw,*.module,*.pkg if getline(1) =~ '<?php' |   setf php | else |   setf virata | endif
rivi 2332: 
rivi 2333: " Visual Basic (also uses *.bas) or FORM
rivi 2334: au BufNewFile,BufRead *.frm^I^I^Icall s:FTVB("form")
rivi 2335: 
rivi 2336: " SaxBasic is close to Visual Basic
rivi 2337: au BufNewFile,BufRead *.sba^I^I^Isetf vb
rivi 2338: 
rivi 2339: " Vgrindefs file
rivi 2340: au BufNewFile,BufRead vgrindefs^I^I^Isetf vgrindefs
rivi 2341: 
rivi 2342: " VRML V1.0c
rivi 2343: au BufNewFile,BufRead *.wrl^I^I^Isetf vrml
rivi 2344: 
rivi 2345: " Vroom (vim testing and executable documentation)
rivi 2346: au BufNewFile,BufRead *.vroom^I^I^Isetf vroom
rivi 2347: 
rivi 2348: " Webmacro
rivi 2349: au BufNewFile,BufRead *.wm^I^I^Isetf webmacro
rivi 2350: 
rivi 2351: " Wget config
rivi 2352: au BufNewFile,BufRead .wgetrc,wgetrc^I^Isetf wget
rivi 2353: 
rivi 2354: " Website MetaLanguage
rivi 2355: au BufNewFile,BufRead *.wml^I^I^Isetf wml
rivi 2356: 
rivi 2357: " Winbatch
rivi 2358: au BufNewFile,BufRead *.wbt^I^I^Isetf winbatch
rivi 2359: 
rivi 2360: " WSML
rivi 2361: au BufNewFile,BufRead *.wsml^I^I^Isetf wsml
rivi 2362: 
rivi 2363: " WvDial
rivi 2364: au BufNewFile,BufRead wvdial.conf,.wvdialrc^Isetf wvdial
rivi 2365: 
rivi 2366: " CVS RC file
rivi 2367: au BufNewFile,BufRead .cvsrc^I^I^Isetf cvsrc
rivi 2368: 
rivi 2369: " CVS commit file
rivi 2370: au BufNewFile,BufRead cvs\d\+^I^I^Isetf cvs
rivi 2371: 
rivi 2372: " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
rivi 2373: " lines in a WEB file).
rivi 2379: au BufNewFile,BufRead *.web if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |   setf web | else |   setf winbatch | endif
rivi 2380: 
rivi 2381: " Windows Scripting Host and Windows Script Component
rivi 2382: au BufNewFile,BufRead *.ws[fc]^I^I^Isetf wsh
rivi 2383: 
rivi 2384: " XHTML
rivi 2385: au BufNewFile,BufRead *.xhtml,*.xht^I^Isetf xhtml
rivi 2386: 
rivi 2387: " X Pixmap (dynamically sets colors, use BufEnter to make it work better)
rivi 2393: au BufEnter *.xpm if getline(1) =~ "XPM2" |   setf xpm2 | else |   setf xpm | endif
rivi 2394: au BufEnter *.xpm2^I^I^I^Isetf xpm2
rivi 2395: 
rivi 2396: " XFree86 config
rivi 2401: au BufNewFile,BufRead XF86Config if getline(1) =~ '\<XConfigurator\>' |   let b:xf86conf_xfree86_version = 3 | endif | setf xf86conf
rivi 2404: au BufNewFile,BufRead */xorg.conf.d/*.conf let b:xf86conf_xfree86_version = 4 | setf xf86conf
rivi 2405: 
rivi 2406: " Xorg config
rivi 2407: au BufNewFile,BufRead xorg.conf,xorg.conf-4^Ilet b:xf86conf_xfree86_version = 4 | setf xf86conf
rivi 2408: 
rivi 2409: " Xinetd conf
rivi 2410: au BufNewFile,BufRead */etc/xinetd.conf^I^Isetf xinetd
rivi 2411: 
rivi 2412: " XS Perl extension interface language
rivi 2413: au BufNewFile,BufRead *.xs^I^I^Isetf xs
rivi 2414: 
rivi 2415: " X resources file
rivi 2416: au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults
rivi 2417: 
rivi 2418: " Xmath
rivi 2419: au BufNewFile,BufRead *.msc,*.msf^I^Isetf xmath
rivi 2421: au BufNewFile,BufRead *.ms if !s:FTnroff() | setf xmath | endif
rivi 2422: 
rivi 2423: " XML  specific variants: docbk and xbl
rivi 2424: au BufNewFile,BufRead *.xml^I^I^Icall s:FTxml()
rivi 2425: 
rivi 2426: func! s:FTxml()
rivi 2451: 
rivi 2452: " XMI (holding UML models) is also XML
rivi 2453: au BufNewFile,BufRead *.xmi^I^I^Isetf xml
rivi 2454: 
rivi 2455: " CSPROJ files are Visual Studio.NET's XML-based project config files
rivi 2456: au BufNewFile,BufRead *.csproj,*.csproj.user^Isetf xml
rivi 2457: 
rivi 2458: " Qt Linguist translation source and Qt User Interface Files are XML
rivi 2459: au BufNewFile,BufRead *.ts,*.ui^I^I^Isetf xml
rivi 2460: 
rivi 2461: " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
rivi 2462: au BufNewFile,BufRead *.tpm^I^I^Isetf xml
rivi 2463: 
rivi 2464: " Xdg menus
rivi 2465: au BufNewFile,BufRead */etc/xdg/menus/*.menu^Isetf xml
rivi 2466: 
rivi 2467: " ATI graphics driver configuration
rivi 2468: au BufNewFile,BufRead fglrxrc^I^I^Isetf xml
rivi 2469: 
rivi 2470: " XLIFF (XML Localisation Interchange File Format) is also XML
rivi 2471: au BufNewFile,BufRead *.xlf^I^I^Isetf xml
rivi 2472: au BufNewFile,BufRead *.xliff^I^I^Isetf xml
rivi 2473: 
rivi 2474: " XML User Interface Language
rivi 2475: au BufNewFile,BufRead *.xul^I^I^Isetf xml
rivi 2476: 
rivi 2477: " X11 xmodmap (also see below)
rivi 2478: au BufNewFile,BufRead *Xmodmap^I^I^Isetf xmodmap
rivi 2479: 
rivi 2480: " Xquery
rivi 2481: au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy^Isetf xquery
rivi 2482: 
rivi 2483: " XSD
rivi 2484: au BufNewFile,BufRead *.xsd^I^I^Isetf xsd
rivi 2485: 
rivi 2486: " Xslt
rivi 2487: au BufNewFile,BufRead *.xsl,*.xslt^I^Isetf xslt
rivi 2488: 
rivi 2489: " Yacc
rivi 2490: au BufNewFile,BufRead *.yy,*.yxx,*.y++^I^Isetf yacc
rivi 2491: 
rivi 2492: " Yacc or racc
rivi 2493: au BufNewFile,BufRead *.y^I^I^Icall s:FTy()
rivi 2494: 
rivi 2495: func! s:FTy()
rivi 2511: 
rivi 2512: 
rivi 2513: " Yaml
rivi 2514: au BufNewFile,BufRead *.yaml,*.yml^I^Isetf yaml
rivi 2515: 
rivi 2516: " yum conf (close enough to dosini)
rivi 2517: au BufNewFile,BufRead */etc/yum.conf^I^Isetf dosini
rivi 2518: 
rivi 2519: " Zimbu
rivi 2520: au BufNewFile,BufRead *.zu^I^I^Isetf zimbu
rivi 2521: " Zimbu Templates
rivi 2522: au BufNewFile,BufRead *.zut^I^I^Isetf zimbutempl
rivi 2523: 
rivi 2524: " Zope
rivi 2525: "   dtml (zope dynamic template markup language), pt (zope page template),
rivi 2526: "   cpt (zope form controller page template)
rivi 2527: au BufNewFile,BufRead *.dtml,*.pt,*.cpt^I^Icall s:FThtml()
rivi 2528: "   zsql (zope sql method)
rivi 2529: au BufNewFile,BufRead *.zsql^I^I^Icall s:SQL()
rivi 2530: 
rivi 2531: " Z80 assembler asz80
rivi 2532: au BufNewFile,BufRead *.z8a^I^I^Isetf z8a
rivi 2533: 
rivi 2534: augroup END
rivi 2535: 
rivi 2536: 
rivi 2537: " Source the user-specified filetype file, for backwards compatibility with
rivi 2538: " Vim 5.x.
rivi 2539: if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
rivi 2540:   execute "source " . myfiletypefile
rivi 2541: endif
rivi 2542: 
rivi 2543: 
rivi 2544: " Check for "*" after loading myfiletypefile, so that scripts.vim is only used
rivi 2545: " when there are no matching file name extensions.
rivi 2546: " Don't do this for compressed files.
rivi 2547: augroup filetypedetect
rivi 2550: au BufNewFile,BufRead * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif
rivi 2551: au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif
rivi 2552: 
rivi 2553: 
rivi 2554: " Extra checks for when no filetype has been detected now.  Mostly used for
rivi 2555: " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
rivi 2556: " script file.
rivi 2557: " Most of these should call s:StarSetf() to avoid names ending in .gz and the
rivi 2558: " like are used.
rivi 2559: 
rivi 2560: " More Apache config files
rivi 2561: au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*^Icall s:StarSetf('apache')
rivi 2562: au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.d/*.conf*^I^Icall s:StarSetf('apache')
rivi 2563: 
rivi 2564: " Asterisk config file
rivi 2565: au BufNewFile,BufRead *asterisk/*.conf*^I^Icall s:StarSetf('asterisk')
rivi 2566: au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')
rivi 2567: 
rivi 2568: " Bazaar version control
rivi 2569: au BufNewFile,BufRead bzr_log.*^I^I^Isetf bzr
rivi 2570: 
rivi 2571: " BIND zone
rivi 2572: au BufNewFile,BufRead */named/db.*,*/bind/db.*^Icall s:StarSetf('bindzone')
rivi 2573: 
rivi 2574: " Calendar
rivi 2577: au BufNewFile,BufRead */.calendar/*,*/share/calendar/*/calendar.*,*/share/calendar/calendar.*^I^I^I^I^Icall s:StarSetf('calendar')
rivi 2578: 
rivi 2579: " Changelog
rivi 2585: au BufNewFile,BufRead [cC]hange[lL]og* if getline(1) =~ '; urgency='|  call s:StarSetf('debchangelog')|else|  call s:StarSetf('changelog')|endif
rivi 2586: 
rivi 2587: " Crontab
rivi 2588: au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*^I^Icall s:StarSetf('crontab')
rivi 2589: 
rivi 2590: " dnsmasq(8) configuration
rivi 2591: au BufNewFile,BufRead */etc/dnsmasq.d/*^I^Icall s:StarSetf('dnsmasq')
rivi 2592: 
rivi 2593: " Dracula
rivi 2594: au BufNewFile,BufRead drac.*^I^I^Icall s:StarSetf('dracula')
rivi 2595: 
rivi 2596: " Fvwm
rivi 2597: au BufNewFile,BufRead */.fvwm/*^I^I^Icall s:StarSetf('fvwm')
rivi 2599: au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook let b:fvwm_version = 1 | call s:StarSetf('fvwm')
rivi 2605: au BufNewFile,BufRead *fvwm2rc* if expand("<afile>:e") == "m4"|  call s:StarSetf('fvwm2m4')|else|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')|endif
rivi 2606: 
rivi 2607: " Gedcom
rivi 2608: au BufNewFile,BufRead */tmp/lltmp*^I^Icall s:StarSetf('gedcom')
rivi 2609: 
rivi 2610: " GTK RC
rivi 2611: au BufNewFile,BufRead .gtkrc*,gtkrc*^I^Icall s:StarSetf('gtkrc')
rivi 2612: 
rivi 2613: " Jam
rivi 2614: au BufNewFile,BufRead Prl*.*,JAM*.*^I^Icall s:StarSetf('jam')
rivi 2615: 
rivi 2616: " Jargon
rivi 2620: au! BufNewFile,BufRead *jarg* if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'|  call s:StarSetf('jargon')|endif
rivi 2621: 
rivi 2622: " Kconfig
rivi 2623: au BufNewFile,BufRead Kconfig.*^I^I^Icall s:StarSetf('kconfig')
rivi 2624: 
rivi 2625: " Lilo: Linux loader
rivi 2626: au BufNewFile,BufRead lilo.conf*^I^Icall s:StarSetf('lilo')
rivi 2627: 
rivi 2628: " Logcheck
rivi 2629: au BufNewFile,BufRead */etc/logcheck/*.d*/*^Icall s:StarSetf('logcheck')
rivi 2630: 
rivi 2631: " Makefile
rivi 2632: au BufNewFile,BufRead [mM]akefile*^I^Icall s:StarSetf('make')
rivi 2633: 
rivi 2634: " Ruby Makefile
rivi 2635: au BufNewFile,BufRead [rR]akefile*^I^Icall s:StarSetf('ruby')
rivi 2636: 
rivi 2637: " Mail (also matches muttrc.vim, so this is below the other checks)
rivi 2638: au BufNewFile,BufRead mutt[[:alnum:]._-]\\\{6\}^Isetf mail
rivi 2639: 
rivi 2640: " Modconf
rivi 2644: au BufNewFile,BufRead */etc/modutils/* if executable(expand("<afile>")) != 1|  call s:StarSetf('modconf')|endif
rivi 2645: au BufNewFile,BufRead */etc/modprobe.*^I^Icall s:StarSetf('modconf')
rivi 2646: 
rivi 2647: " Mutt setup file
rivi 2648: au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*^Icall s:StarSetf('muttrc')
rivi 2649: au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*^I^Icall s:StarSetf('muttrc')
rivi 2650: 
rivi 2651: " Nroff macros
rivi 2652: au BufNewFile,BufRead tmac.*^I^I^Icall s:StarSetf('nroff')
rivi 2653: 
rivi 2654: " Pam conf
rivi 2655: au BufNewFile,BufRead */etc/pam.d/*^I^Icall s:StarSetf('pamconf')
rivi 2656: 
rivi 2657: " Printcap and Termcap
rivi 2661: au BufNewFile,BufRead *printcap* if !did_filetype()|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')|endif
rivi 2665: au BufNewFile,BufRead *termcap* if !did_filetype()|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')|endif
rivi 2666: 
rivi 2667: " ReDIF
rivi 2668: " Only used when the .rdf file was not detected to be XML.
rivi 2669: au BufRead,BufNewFile *.rdf^I^I^Icall s:Redif()
rivi 2670: func! s:Redif()
rivi 2680: 
rivi 2681: " Remind
rivi 2682: au BufNewFile,BufRead .reminders*^I^Icall s:StarSetf('remind')
rivi 2683: 
rivi 2684: " Vim script
rivi 2685: au BufNewFile,BufRead *vimrc*^I^I^Icall s:StarSetf('vim')
rivi 2686: 
rivi 2687: " Subversion commit file
rivi 2688: au BufNewFile,BufRead svn-commit*.tmp^I^Isetf svn
rivi 2689: 
rivi 2690: " X resources file
rivi 2691: au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')
rivi 2692: 
rivi 2693: " XFree86 config
rivi 2695: au BufNewFile,BufRead XF86Config-4* let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
rivi 2700: au BufNewFile,BufRead XF86Config* if getline(1) =~ '\<XConfigurator\>'|  let b:xf86conf_xfree86_version = 3|endif|call s:StarSetf('xf86conf')
rivi 2701: 
rivi 2702: " X11 xmodmap
rivi 2703: au BufNewFile,BufRead *xmodmap*^I^I^Icall s:StarSetf('xmodmap')
rivi 2704: 
rivi 2705: " Xinetd conf
rivi 2706: au BufNewFile,BufRead */etc/xinetd.d/*^I^Icall s:StarSetf('xinetd')
rivi 2707: 
rivi 2708: " yum conf (close enough to dosini)
rivi 2709: au BufNewFile,BufRead */etc/yum.repos.d/*^Icall s:StarSetf('dosini')
rivi 2710: 
rivi 2711: " Z-Shell script
rivi 2712: au BufNewFile,BufRead zsh*,zlog*^I^Icall s:StarSetf('zsh')
rivi 2713: 
rivi 2714: 
rivi 2715: " Plain text files, needs to be far down to not override others.  This avoids
rivi 2716: " the "conf" type being used if there is a line starting with '#'.
rivi 2717: au BufNewFile,BufRead *.txt,*.text,README^Isetf text
rivi 2718: 
rivi 2719: 
rivi 2720: " Use the filetype detect plugins.  They may overrule any of the previously
rivi 2721: " detected filetypes.
rivi 2722: runtime! ftdetect/*.vim
Etsitään ilmausta ftdetect/*.vim kohteesta /home/ollpu/.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/ollpu/.vim/after
Etsitään ilmausta /home/ollpu/.vim/ftdetect/*.vim
Etsitään ilmausta /var/lib/vim/addons/ftdetect/*.vim
Etsitään ilmausta /usr/share/vim/vimfiles/ftdetect/*.vim
Etsitään ilmausta /usr/share/vim/vim74/ftdetect/*.vim
Etsitään ilmausta /usr/share/vim/vimfiles/after/ftdetect/*.vim
Etsitään ilmausta /var/lib/vim/addons/after/ftdetect/*.vim
Etsitään ilmausta /home/ollpu/.vim/after/ftdetect/*.vim
not found in 'runtimepath': "ftdetect/*.vim"
rivi 2723: 
rivi 2724: " NOTE: The above command could have ended the filetypedetect autocmd group
rivi 2725: " and started another one. Let's make sure it has ended to get to a consistent
rivi 2726: " state.
rivi 2727: augroup END
rivi 2728: 
rivi 2729: " Generic configuration file (check this last, it's just guessing!)
rivi 2735: au filetypedetect BufNewFile,BufRead,StdinReadPost * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'^I|| getline(4) =~ '^#' || getline(5) =~ '^#') |   setf conf | endif
rivi 2736: 
rivi 2737: 
rivi 2738: " If the GUI is already running, may still need to install the Syntax menu.
rivi 2739: " Don't do it when the 'M' flag is included in 'guioptions'.
rivi 2741: if has("menu") && has("gui_running") && !exists("did_install_syntax_menu") && &guioptions !~# "M"
rivi 2742:   source <sfile>:p:h/menu.vim
rivi 2743: endif
rivi 2744: 
rivi 2745: " Function called for testing all functions defined here.  These are
rivi 2746: " script-local, thus need to be executed here.
rivi 2747: " Returns a string with error messages (hopefully empty).
rivi 2748: func! TestFiletypeFuncs(testlist)
rivi 2759: 
rivi 2760: " Restore 'cpoptions'
rivi 2761: let &cpo = s:cpo_save
rivi 2762: unlet s:cpo_save
ladattu /usr/share/vim/vim74/filetype.vim
jatkaa kohdassa /usr/share/vim/vim74/syntax/syntax.vim
Etsitään ilmausta /usr/share/vim/vimfiles/after/filetype.vim
Etsitään ilmausta /var/lib/vim/addons/after/filetype.vim
Etsitään ilmausta /home/ollpu/.vim/after/filetype.vim
rivi 26:   let s:did_ft = 0
rivi 27: endif
rivi 28: 
rivi 29: " Set up the connection between FileType and Syntax autocommands.
rivi 30: " This makes the syntax automatically set when the file type is detected.
rivi 31: augroup syntaxset
rivi 32:   au! FileType *^Iexe "set syntax=" . expand("<amatch>")
rivi 33: augroup END
rivi 34: 
rivi 35: 
rivi 36: " Execute the syntax autocommands for the each buffer.
rivi 37: " If the filetype wasn't detected yet, do that now.
rivi 38: " Always do the syntaxset autocommands, for buffers where the 'filetype'
rivi 39: " already was set manually (e.g., help buffers).
rivi 40: doautoall syntaxset FileType
rivi 41: if !s:did_ft
rivi 42:   doautoall filetypedetect BufRead
rivi 43: endif
ladattu /usr/share/vim/vim74/syntax/syntax.vim
jatkaa kohdassa /usr/share/vim/vimrc
rivi 21: endif
rivi 22: 
rivi 23: " If using a dark background within the editing area and syntax highlighting
rivi 24: " turn on this option as well
rivi 25: "set background=dark
rivi 26: 
rivi 27: " Uncomment the following to have Vim jump to the last position when
rivi 28: " reopening a file
rivi 29: "if has("autocmd")
rivi 30: "  au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif
rivi 31: "endif
rivi 32: 
rivi 33: " Uncomment the following to have Vim load indentation rules and plugins
rivi 34: " according to the detected filetype.
rivi 35: "if has("autocmd")
rivi 36: "  filetype plugin indent on
rivi 37: "endif
rivi 38: 
rivi 39: " The following are commented out as they cause vim to behave a lot
rivi 40: " differently from regular Vi. They are highly recommended though.
rivi 41: "set showcmd^I^I" Show (partial) command in status line.
rivi 42: "set showmatch^I^I" Show matching brackets.
rivi 43: "set ignorecase^I^I" Do case insensitive matching
rivi 44: "set smartcase^I^I" Do smart case matching
rivi 45: "set incsearch^I^I" Incremental search
rivi 46: "set autowrite^I^I" Automatically save before commands like :next and :make
rivi 47: "set hidden^I^I" Hide buffers when they are abandoned
rivi 48: "set mouse=a^I^I" Enable mouse usage (all modes)
rivi 49: 
rivi 50: " Source a global configuration file if available
rivi 51: if filereadable("/etc/vim/vimrc.local")
rivi 52:   source /etc/vim/vimrc.local
rivi 53: endif
rivi 54: 
ladattu $VIM/vimrc
chdir(/home/ollpu)
fchdir() to previous dir
ladataan $HOME/.vimrc
rivi 1: language en_GB.utf8
line 2: 
line 3: execute pathogen#infect()
Searching for "autoload/pathogen.vim" in "/home/ollpu/.vim,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/ollpu/.vim/after"
Searching for "/home/ollpu/.vim/autoload/pathogen.vim"
chdir(/home/ollpu/.vim/autoload)
fchdir() to previous dir
line 3: sourcing "/home/ollpu/.vim/autoload/pathogen.vim"
line 1: " pathogen.vim - path option manipulation
line 2: " Maintainer:   Tim Pope <http://tpo.pe/>
line 3: " Version:      2.4
line 4: 
line 5: " Install in ~/.vim/autoload (or ~\vimfiles\autoload).
line 6: "
line 7: " For management of individually installed plugins in ~/.vim/bundle (or
line 8: " ~\vimfiles\bundle), adding `execute pathogen#infect()` to the top of your
line 9: " .vimrc is the only other setup necessary.
line 10: "
line 11: " The API is documented inline below.
line 12: 
line 13: if exists("g:loaded_pathogen") || &cp
line 14:   finish
line 15: endif
line 16: let g:loaded_pathogen = 1
line 17: 
line 18: " Point of entry for basic default usage.  Give a relative path to invoke
line 19: " pathogen#interpose() (defaults to "bundle/{}"), or an absolute path to invoke
line 20: " pathogen#surround().  Curly braces are expanded with pathogen#expand():
line 21: " "bundle/{}" finds all subdirectories inside "bundle" inside all directories
line 22: " in the runtime path.
line 23: function! pathogen#infect(...) abort
line 43: 
line 44: " Split a path into a list.
line 45: function! pathogen#split(path) abort
line 51: 
line 52: " Convert a list to a path.
line 53: function! pathogen#join(...) abort
line 78: 
line 79: " Convert a list to a path with escaped spaces for 'path', 'tag', etc.
line 80: function! pathogen#legacyjoin(...) abort
line 83: 
line 84: " Turn filetype detection off and back on again if it was already enabled.
line 85: function! pathogen#cycle_filetype() abort
line 91: 
line 92: " Check if a bundle is disabled.  A bundle is considered disabled if its
line 93: " basename or full name is included in the list g:pathogen_blacklist or the
line 94: " comma delimited environment variable $VIMBLACKLIST.
line 95: function! pathogen#is_disabled(path) abort
line 108: 
line 109: " Prepend the given directory to the runtime path and append its corresponding
line 110: " after directory.  Curly braces are expanded with pathogen#expand().
line 111: function! pathogen#surround(path) abort
line 121: 
line 122: " For each directory in the runtime path, add a second entry with the given
line 123: " argument appended.  Curly braces are expanded with pathogen#expand().
line 124: function! pathogen#interpose(name) abort
line 142: 
line 143: let s:done_bundles = {}
line 144: 
line 145: " Invoke :helptags on all non-$VIM doc directories in runtimepath.
line 146: function! pathogen#helptags() abort
line 156: 
line 157: command! -bar Helptags :call pathogen#helptags()
line 158: 
line 159: " Execute the given command.  This is basically a backdoor for --remote-expr.
line 160: function! pathogen#execute(...) abort
line 166: 
line 167: " Section: Unofficial
line 168: 
line 169: function! pathogen#is_absolute(path) abort
line 172: 
line 173: " Given a string, returns all possible permutations of comma delimited braced
line 174: " alternatives of that string.  pathogen#expand('/{a,b}/{c,d}') yields
line 175: " ['/a/c', '/a/d', '/b/c', '/b/d'].  Empty braces are treated as a wildcard
line 176: " and globbed.  Actual globs are preserved.
line 177: function! pathogen#expand(pattern, ...) abort
line 197: 
line 198: " \ on Windows unless shellslash is set, / everywhere else.
line 199: function! pathogen#slash() abort
line 202: 
line 203: function! pathogen#separator() abort
line 206: 
line 207: " Convenience wrapper around glob() which returns a list.
line 208: function! pathogen#glob(pattern) abort
line 212: 
line 213: " Like pathogen#glob(), only limit the results to directories.
line 214: function! pathogen#glob_directories(pattern) abort
line 217: 
line 218: " Remove duplicates from a list.
line 219: function! pathogen#uniq(list) abort
line 235: 
line 236: " Backport of fnameescape().
line 237: function! pathogen#fnameescape(string) abort
line 246: 
line 247: " Like findfile(), but hardcoded to use the runtimepath.
line 248: function! pathogen#runtime_findfile(file,count) abort
line 257: 
line 258: " Section: Deprecated
line 259: 
line 260: function! s:warn(msg) abort
line 265: 
line 266: " Prepend all subdirectories of path to the rtp, and append all 'after'
line 267: " directories in those subdirectories.  Deprecated.
line 268: function! pathogen#runtime_prepend_subdirectories(path) abort
line 272: 
line 273: function! pathogen#incubate(...) abort
line 278: 
line 279: " Deprecated alias for pathogen#interpose().
line 280: function! pathogen#runtime_append_all_bundles(...) abort
line 288: 
line 289: if exists(':Vedit')
line 290:   finish
line 291: endif
line 292: 
line 293: let s:vopen_warning = 0
line 294: 
line 295: function! s:find(count,cmd,file,lcd)
line 315: 
line 316: function! s:Findcomplete(A,L,P)
line 343: 
line 344: command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Ve       :execute s:find(<count>,'edit<bang>',<q-args>,0)
line 345: command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vedit    :execute s:find(<count>,'edit<bang>',<q-args>,0)
line 346: command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vopen    :execute s:find(<count>,'edit<bang>',<q-args>,1)
line 347: command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vsplit   :execute s:find(<count>,'split',<q-args>,<bang>1)
line 348: command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vvsplit  :execute s:find(<count>,'vsplit',<q-args>,<bang>1)
line 349: command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vtabedit :execute s:find(<count>,'tabedit',<q-args>,<bang>1)
line 350: command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vpedit   :execute s:find(<count>,'pedit',<q-args>,<bang>1)
line 351: command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vread    :execute s:find(<count>,'read',<q-args>,<bang>1)
line 352: 
line 353: " vim:set et sw=2 foldmethod=expr foldexpr=getline(v\:lnum)=~'^\"\ Section\:'?'>1'\:getline(v\:lnum)=~#'^fu'?'a1'\:getline(v\:lnum)=~#'^endf'?'s1'\:'=':
finished sourcing /home/ollpu/.vim/autoload/pathogen.vim
continuing in /home/ollpu/.vimrc
calling function pathogen#infect()

line 1:   for path in a:0 ? filter(reverse(copy(a:000)), 'type(v:val) == type("")') : ['bundle/{}']
line 2:     if path =~# '^\%({\=[$~\\/]\|{\=\w:[\\/]\).*[{}*]'
line 3:       call pathogen#surround(path)
line 4:     elseif path =~# '^\%([$~\\/]\|\w:[\\/]\)'
line 5:       call s:warn('Change pathogen#infect('.string(path).') to pathogen#infect('.string(path.'/{}').')')
line 6:       call pathogen#surround(path . '/{}')
line 7:     elseif path =~# '[{}*]'
line 8:       call pathogen#interpose(path)
calling function pathogen#infect[8]..pathogen#interpose('bundle/{}')

line 1:   let sep = pathogen#slash()
calling function pathogen#infect[8]..pathogen#interpose[1]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[8]..pathogen#interpose[1]..pathogen#slash returning '/'

continuing in function pathogen#infect[8]..pathogen#interpose

line 2:   let name = a:name
line 3:   if has_key(s:done_bundles, name)
line 4:     return ""
line 5:   endif
line 6:   let s:done_bundles[name] = 1
line 7:   let list = []
line 8:   for dir in pathogen#split(&rtp)
calling function pathogen#infect[8]..pathogen#interpose[8]..pathogen#split('/home/ollpu/.vim,/var/lib/vim/addons...vim/addons/after,/home/ollpu/.vim/after')

line 1:   if type(a:path) == type([]) | return a:path | endif
line 1:  return a:path | endif
line 1:  endif
line 2:   if empty(a:path) | return [] | endif
line 2:  return [] | endif
line 2:  endif
line 3:   let split = split(a:path,'\\\@<!\%(\\\\\)*\zs,')
line 4:   return map(split,'substitute(v:val,''\\\([\\,]\)'',''\1'',"g")')
function pathogen#infect[8]..pathogen#interpose[8]..pathogen#split returning ['/home/ollpu/.vim', '/var/lib/vim/ad...addons/after', '/home/ollpu/.vim/after']

continuing in function pathogen#infect[8]..pathogen#interpose

line 9:     if dir =~# '\<after$'
line 10:       let list += reverse(filter(pathogen#expand(dir[0:-6].name, sep.'after'), '!pathogen#is_disabled(v:val[0:-7])')) + [dir]
line 11:     else
line 12:       let list += [dir] + filter(pathogen#expand(dir.sep.name), '!pathogen#is_disabled(v:val)')
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand('/home/ollpu/.vim/bundle/{}')

line 1:   let after = a:0 ? a:1 : ''
line 2:   if a:pattern =~# '{[^{}]\+}'
line 3:     let [pre, pat, post] = split(substitute(a:pattern, '\(.\{-\}\){\([^{}]\+\)}\(.*\)', "\\1\001\\2\001\\3", ''), "\001", 1)
line 4:     let found = map(split(pat, ',', 1), 'pre.v:val.post')
line 5:     let results = []
line 6:     for pattern in found
line 7:       call extend(results, pathogen#expand(pattern))
line 8:     endfor
line 9:   elseif a:pattern =~# '{}'
line 10:     let pat = matchstr(a:pattern, '^.*{}[^*]*\%($\|[\\/]\)')
line 11:     let post = a:pattern[strlen(pat) : -1]
line 12:     let results = map(split(glob(substitute(pat, '{}', '*', 'g')), "\n"), 'v:val.post')
line 13:   else
line 14:     let results = [a:pattern]
line 15:   endif
line 16:   let vf = pathogen#slash() . 'vimfiles'
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand[16]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand[16]..pathogen#slash returning '/'

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand

line 17:   call map(results, 'v:val =~# "\\*" ? v:val.after : isdirectory(v:val.vf.after) ? v:val.vf.after : isdirectory(v:val.after) ? v:val.after : ""')
line 18:   return filter(results, '!empty(v:val)')
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand returning ['/home/ollpu/.vim/bundle/fu', '/home... '/home/ollpu/.vim/bundle/vim-surround']

continuing in function pathogen#infect[8]..pathogen#interpose

calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled('/home/ollpu/.vim/bundle/fu')

line 1:   if a:path =~# '\~$'
line 2:     return 1
line 3:   endif
line 4:   let sep = pathogen#slash()
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash returning '/'

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled

line 5:   let blacklist = get(g:, 'pathogen_blacklist', get(g:, 'pathogen_disabled', [])) + pathogen#split($VIMBLACKLIST)
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split('')

line 1:   if type(a:path) == type([]) | return a:path | endif
line 1:  return a:path | endif
line 1:  endif
line 2:   if empty(a:path) | return [] | endif
line 2:  return [] | endif
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split returning []

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled

line 8:   if !empty(blacklist)
line 9:     call map(blacklist, 'substitute(v:val, "[\\/]$", "", "")')
line 10:   endif
line 11:   return index(blacklist, fnamemodify(a:path, ':t')) != -1 || index(blacklist, a:path) != -1
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled returning #0

continuing in function pathogen#infect[8]..pathogen#interpose

calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled('/home/ollpu/.vim/bundle/lightline.vim')

line 1:   if a:path =~# '\~$'
line 2:     return 1
line 3:   endif
line 4:   let sep = pathogen#slash()
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash returning '/'

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled

line 5:   let blacklist = get(g:, 'pathogen_blacklist', get(g:, 'pathogen_disabled', [])) + pathogen#split($VIMBLACKLIST)
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split('')

line 1:   if type(a:path) == type([]) | return a:path | endif
line 1:  return a:path | endif
line 1:  endif
line 2:   if empty(a:path) | return [] | endif
line 2:  return [] | endif
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split returning []

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled

line 8:   if !empty(blacklist)
line 9:     call map(blacklist, 'substitute(v:val, "[\\/]$", "", "")')
line 10:   endif
line 11:   return index(blacklist, fnamemodify(a:path, ':t')) != -1 || index(blacklist, a:path) != -1
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled returning #0

continuing in function pathogen#infect[8]..pathogen#interpose

calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled('/home/ollpu/.vim/bundle/molokai')

line 1:   if a:path =~# '\~$'
line 2:     return 1
line 3:   endif
line 4:   let sep = pathogen#slash()
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash returning '/'

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled

line 5:   let blacklist = get(g:, 'pathogen_blacklist', get(g:, 'pathogen_disabled', [])) + pathogen#split($VIMBLACKLIST)
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split('')

line 1:   if type(a:path) == type([]) | return a:path | endif
line 1:  return a:path | endif
line 1:  endif
line 2:   if empty(a:path) | return [] | endif
line 2:  return [] | endif
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split returning []

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled

line 8:   if !empty(blacklist)
line 9:     call map(blacklist, 'substitute(v:val, "[\\/]$", "", "")')
line 10:   endif
line 11:   return index(blacklist, fnamemodify(a:path, ':t')) != -1 || index(blacklist, a:path) != -1
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled returning #0

continuing in function pathogen#infect[8]..pathogen#interpose

calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled('/home/ollpu/.vim/bundle/vim-autoclose')

line 1:   if a:path =~# '\~$'
line 2:     return 1
line 3:   endif
line 4:   let sep = pathogen#slash()
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash returning '/'

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled

line 5:   let blacklist = get(g:, 'pathogen_blacklist', get(g:, 'pathogen_disabled', [])) + pathogen#split($VIMBLACKLIST)
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split('')

line 1:   if type(a:path) == type([]) | return a:path | endif
line 1:  return a:path | endif
line 1:  endif
line 2:   if empty(a:path) | return [] | endif
line 2:  return [] | endif
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split returning []

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled

line 8:   if !empty(blacklist)
line 9:     call map(blacklist, 'substitute(v:val, "[\\/]$", "", "")')
line 10:   endif
line 11:   return index(blacklist, fnamemodify(a:path, ':t')) != -1 || index(blacklist, a:path) != -1
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled returning #0

continuing in function pathogen#infect[8]..pathogen#interpose

calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled('/home/ollpu/.vim/bundle/vim-surround')

line 1:   if a:path =~# '\~$'
line 2:     return 1
line 3:   endif
line 4:   let sep = pathogen#slash()
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash returning '/'

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled

line 5:   let blacklist = get(g:, 'pathogen_blacklist', get(g:, 'pathogen_disabled', [])) + pathogen#split($VIMBLACKLIST)
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split('')

line 1:   if type(a:path) == type([]) | return a:path | endif
line 1:  return a:path | endif
line 1:  endif
line 2:   if empty(a:path) | return [] | endif
line 2:  return [] | endif
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split returning []

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled

line 8:   if !empty(blacklist)
line 9:     call map(blacklist, 'substitute(v:val, "[\\/]$", "", "")')
line 10:   endif
line 11:   return index(blacklist, fnamemodify(a:path, ':t')) != -1 || index(blacklist, a:path) != -1
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled returning #0

continuing in function pathogen#infect[8]..pathogen#interpose

line 13:     endif
line 14:   endfor
line 8:   for dir in pathogen#split(&rtp)
line 9:     if dir =~# '\<after$'
line 10:       let list += reverse(filter(pathogen#expand(dir[0:-6].name, sep.'after'), '!pathogen#is_disabled(v:val[0:-7])')) + [dir]
line 11:     else
line 12:       let list += [dir] + filter(pathogen#expand(dir.sep.name), '!pathogen#is_disabled(v:val)')
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand('/var/lib/vim/addons/bundle/{}')

line 1:   let after = a:0 ? a:1 : ''
line 2:   if a:pattern =~# '{[^{}]\+}'
line 3:     let [pre, pat, post] = split(substitute(a:pattern, '\(.\{-\}\){\([^{}]\+\)}\(.*\)', "\\1\001\\2\001\\3", ''), "\001", 1)
line 4:     let found = map(split(pat, ',', 1), 'pre.v:val.post')
line 5:     let results = []
line 6:     for pattern in found
line 7:       call extend(results, pathogen#expand(pattern))
line 8:     endfor
line 9:   elseif a:pattern =~# '{}'
line 10:     let pat = matchstr(a:pattern, '^.*{}[^*]*\%($\|[\\/]\)')
line 11:     let post = a:pattern[strlen(pat) : -1]
line 12:     let results = map(split(glob(substitute(pat, '{}', '*', 'g')), "\n"), 'v:val.post')
line 13:   else
line 14:     let results = [a:pattern]
line 15:   endif
line 16:   let vf = pathogen#slash() . 'vimfiles'
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand[16]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand[16]..pathogen#slash returning '/'

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand

line 17:   call map(results, 'v:val =~# "\\*" ? v:val.after : isdirectory(v:val.vf.after) ? v:val.vf.after : isdirectory(v:val.after) ? v:val.after : ""')
line 18:   return filter(results, '!empty(v:val)')
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand returning []

continuing in function pathogen#infect[8]..pathogen#interpose

line 13:     endif
line 14:   endfor
line 8:   for dir in pathogen#split(&rtp)
line 9:     if dir =~# '\<after$'
line 10:       let list += reverse(filter(pathogen#expand(dir[0:-6].name, sep.'after'), '!pathogen#is_disabled(v:val[0:-7])')) + [dir]
line 11:     else
line 12:       let list += [dir] + filter(pathogen#expand(dir.sep.name), '!pathogen#is_disabled(v:val)')
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand('/usr/share/vim/vimfiles/bundle/{}')

line 1:   let after = a:0 ? a:1 : ''
line 2:   if a:pattern =~# '{[^{}]\+}'
line 3:     let [pre, pat, post] = split(substitute(a:pattern, '\(.\{-\}\){\([^{}]\+\)}\(.*\)', "\\1\001\\2\001\\3", ''), "\001", 1)
line 4:     let found = map(split(pat, ',', 1), 'pre.v:val.post')
line 5:     let results = []
line 6:     for pattern in found
line 7:       call extend(results, pathogen#expand(pattern))
line 8:     endfor
line 9:   elseif a:pattern =~# '{}'
line 10:     let pat = matchstr(a:pattern, '^.*{}[^*]*\%($\|[\\/]\)')
line 11:     let post = a:pattern[strlen(pat) : -1]
line 12:     let results = map(split(glob(substitute(pat, '{}', '*', 'g')), "\n"), 'v:val.post')
line 13:   else
line 14:     let results = [a:pattern]
line 15:   endif
line 16:   let vf = pathogen#slash() . 'vimfiles'
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand[16]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand[16]..pathogen#slash returning '/'

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand

line 17:   call map(results, 'v:val =~# "\\*" ? v:val.after : isdirectory(v:val.vf.after) ? v:val.vf.after : isdirectory(v:val.after) ? v:val.after : ""')
line 18:   return filter(results, '!empty(v:val)')
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand returning []

continuing in function pathogen#infect[8]..pathogen#interpose

line 13:     endif
line 14:   endfor
line 8:   for dir in pathogen#split(&rtp)
line 9:     if dir =~# '\<after$'
line 10:       let list += reverse(filter(pathogen#expand(dir[0:-6].name, sep.'after'), '!pathogen#is_disabled(v:val[0:-7])')) + [dir]
line 11:     else
line 12:       let list += [dir] + filter(pathogen#expand(dir.sep.name), '!pathogen#is_disabled(v:val)')
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand('/usr/share/vim/vim74/bundle/{}')

line 1:   let after = a:0 ? a:1 : ''
line 2:   if a:pattern =~# '{[^{}]\+}'
line 3:     let [pre, pat, post] = split(substitute(a:pattern, '\(.\{-\}\){\([^{}]\+\)}\(.*\)', "\\1\001\\2\001\\3", ''), "\001", 1)
line 4:     let found = map(split(pat, ',', 1), 'pre.v:val.post')
line 5:     let results = []
line 6:     for pattern in found
line 7:       call extend(results, pathogen#expand(pattern))
line 8:     endfor
line 9:   elseif a:pattern =~# '{}'
line 10:     let pat = matchstr(a:pattern, '^.*{}[^*]*\%($\|[\\/]\)')
line 11:     let post = a:pattern[strlen(pat) : -1]
line 12:     let results = map(split(glob(substitute(pat, '{}', '*', 'g')), "\n"), 'v:val.post')
line 13:   else
line 14:     let results = [a:pattern]
line 15:   endif
line 16:   let vf = pathogen#slash() . 'vimfiles'
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand[16]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand[16]..pathogen#slash returning '/'

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand

line 17:   call map(results, 'v:val =~# "\\*" ? v:val.after : isdirectory(v:val.vf.after) ? v:val.vf.after : isdirectory(v:val.after) ? v:val.after : ""')
line 18:   return filter(results, '!empty(v:val)')
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand returning []

continuing in function pathogen#infect[8]..pathogen#interpose

line 13:     endif
line 14:   endfor
line 8:   for dir in pathogen#split(&rtp)
line 9:     if dir =~# '\<after$'
line 10:       let list += reverse(filter(pathogen#expand(dir[0:-6].name, sep.'after'), '!pathogen#is_disabled(v:val[0:-7])')) + [dir]
calling function pathogen#infect[8]..pathogen#interpose[10]..pathogen#expand('/usr/share/vim/vimfiles/bundle/{}', '/after')

line 1:   let after = a:0 ? a:1 : ''
line 2:   if a:pattern =~# '{[^{}]\+}'
line 3:     let [pre, pat, post] = split(substitute(a:pattern, '\(.\{-\}\){\([^{}]\+\)}\(.*\)', "\\1\001\\2\001\\3", ''), "\001", 1)
line 4:     let found = map(split(pat, ',', 1), 'pre.v:val.post')
line 5:     let results = []
line 6:     for pattern in found
line 7:       call extend(results, pathogen#expand(pattern))
line 8:     endfor
line 9:   elseif a:pattern =~# '{}'
line 10:     let pat = matchstr(a:pattern, '^.*{}[^*]*\%($\|[\\/]\)')
line 11:     let post = a:pattern[strlen(pat) : -1]
line 12:     let results = map(split(glob(substitute(pat, '{}', '*', 'g')), "\n"), 'v:val.post')
line 13:   else
line 14:     let results = [a:pattern]
line 15:   endif
line 16:   let vf = pathogen#slash() . 'vimfiles'
calling function pathogen#infect[8]..pathogen#interpose[10]..pathogen#expand[16]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[8]..pathogen#interpose[10]..pathogen#expand[16]..pathogen#slash returning '/'

continuing in function pathogen#infect[8]..pathogen#interpose[10]..pathogen#expand

line 17:   call map(results, 'v:val =~# "\\*" ? v:val.after : isdirectory(v:val.vf.after) ? v:val.vf.after : isdirectory(v:val.after) ? v:val.after : ""')
line 18:   return filter(results, '!empty(v:val)')
function pathogen#infect[8]..pathogen#interpose[10]..pathogen#expand returning []

continuing in function pathogen#infect[8]..pathogen#interpose

line 11:     else
line 12:       let list += [dir] + filter(pathogen#expand(dir.sep.name), '!pathogen#is_disabled(v:val)')
line 13:     endif
line 14:   endfor
line 8:   for dir in pathogen#split(&rtp)
line 9:     if dir =~# '\<after$'
line 10:       let list += reverse(filter(pathogen#expand(dir[0:-6].name, sep.'after'), '!pathogen#is_disabled(v:val[0:-7])')) + [dir]
calling function pathogen#infect[8]..pathogen#interpose[10]..pathogen#expand('/var/lib/vim/addons/bundle/{}', '/after')

line 1:   let after = a:0 ? a:1 : ''
line 2:   if a:pattern =~# '{[^{}]\+}'
line 3:     let [pre, pat, post] = split(substitute(a:pattern, '\(.\{-\}\){\([^{}]\+\)}\(.*\)', "\\1\001\\2\001\\3", ''), "\001", 1)
line 4:     let found = map(split(pat, ',', 1), 'pre.v:val.post')
line 5:     let results = []
line 6:     for pattern in found
line 7:       call extend(results, pathogen#expand(pattern))
line 8:     endfor
line 9:   elseif a:pattern =~# '{}'
line 10:     let pat = matchstr(a:pattern, '^.*{}[^*]*\%($\|[\\/]\)')
line 11:     let post = a:pattern[strlen(pat) : -1]
line 12:     let results = map(split(glob(substitute(pat, '{}', '*', 'g')), "\n"), 'v:val.post')
line 13:   else
line 14:     let results = [a:pattern]
line 15:   endif
line 16:   let vf = pathogen#slash() . 'vimfiles'
calling function pathogen#infect[8]..pathogen#interpose[10]..pathogen#expand[16]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[8]..pathogen#interpose[10]..pathogen#expand[16]..pathogen#slash returning '/'

continuing in function pathogen#infect[8]..pathogen#interpose[10]..pathogen#expand

line 17:   call map(results, 'v:val =~# "\\*" ? v:val.after : isdirectory(v:val.vf.after) ? v:val.vf.after : isdirectory(v:val.after) ? v:val.after : ""')
line 18:   return filter(results, '!empty(v:val)')
function pathogen#infect[8]..pathogen#interpose[10]..pathogen#expand returning []

continuing in function pathogen#infect[8]..pathogen#interpose

line 11:     else
line 12:       let list += [dir] + filter(pathogen#expand(dir.sep.name), '!pathogen#is_disabled(v:val)')
line 13:     endif
line 14:   endfor
line 8:   for dir in pathogen#split(&rtp)
line 9:     if dir =~# '\<after$'
line 10:       let list += reverse(filter(pathogen#expand(dir[0:-6].name, sep.'after'), '!pathogen#is_disabled(v:val[0:-7])')) + [dir]
calling function pathogen#infect[8]..pathogen#interpose[10]..pathogen#expand('/home/ollpu/.vim/bundle/{}', '/after')

line 1:   let after = a:0 ? a:1 : ''
line 2:   if a:pattern =~# '{[^{}]\+}'
line 3:     let [pre, pat, post] = split(substitute(a:pattern, '\(.\{-\}\){\([^{}]\+\)}\(.*\)', "\\1\001\\2\001\\3", ''), "\001", 1)
line 4:     let found = map(split(pat, ',', 1), 'pre.v:val.post')
line 5:     let results = []
line 6:     for pattern in found
line 7:       call extend(results, pathogen#expand(pattern))
line 8:     endfor
line 9:   elseif a:pattern =~# '{}'
line 10:     let pat = matchstr(a:pattern, '^.*{}[^*]*\%($\|[\\/]\)')
line 11:     let post = a:pattern[strlen(pat) : -1]
line 12:     let results = map(split(glob(substitute(pat, '{}', '*', 'g')), "\n"), 'v:val.post')
line 13:   else
line 14:     let results = [a:pattern]
line 15:   endif
line 16:   let vf = pathogen#slash() . 'vimfiles'
calling function pathogen#infect[8]..pathogen#interpose[10]..pathogen#expand[16]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[8]..pathogen#interpose[10]..pathogen#expand[16]..pathogen#slash returning '/'

continuing in function pathogen#infect[8]..pathogen#interpose[10]..pathogen#expand

line 17:   call map(results, 'v:val =~# "\\*" ? v:val.after : isdirectory(v:val.vf.after) ? v:val.vf.after : isdirectory(v:val.after) ? v:val.after : ""')
line 18:   return filter(results, '!empty(v:val)')
function pathogen#infect[8]..pathogen#interpose[10]..pathogen#expand returning []

continuing in function pathogen#infect[8]..pathogen#interpose

line 11:     else
line 12:       let list += [dir] + filter(pathogen#expand(dir.sep.name), '!pathogen#is_disabled(v:val)')
line 13:     endif
line 14:   endfor
line 8:   for dir in pathogen#split(&rtp)
line 9:     if dir =~# '\<after$'
line 10:       let list += reverse(filter(pathogen#expand(dir[0:-6].name, sep.'after'), '!pathogen#is_disabled(v:val[0:-7])')) + [dir]
line 11:     else
line 12:       let list += [dir] + filter(pathogen#expand(dir.sep.name), '!pathogen#is_disabled(v:val)')
line 13:     endif
line 14:   endfor
line 15:   let &rtp = pathogen#join(pathogen#uniq(list))
calling function pathogen#infect[8]..pathogen#interpose[15]..pathogen#uniq(['/home/ollpu/.vim', '/home/ollpu/.vi...addons/after', '/home/ollpu/.vim/after'])

line 1:   let i = 0
line 2:   let seen = {}
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 14:   return a:list
function pathogen#infect[8]..pathogen#interpose[15]..pathogen#uniq returning ['/home/ollpu/.vim', '/home/ollpu/.vi...addons/after', '/home/ollpu/.vim/after']

continuing in function pathogen#infect[8]..pathogen#interpose

calling function pathogen#infect[8]..pathogen#interpose[15]..pathogen#join(['/home/ollpu/.vim', '/home/ollpu/.vi...addons/after', '/home/ollpu/.vim/after'])

line 1:   if type(a:1) == type(1) && a:1
line 2:     let i = 1
line 3:     let space = ' '
line 4:   else
line 5:     let i = 0
line 6:     let space = ''
line 7:   endif
line 8:   let path = ""
line 9:   while i < a:0
line 10:     if type(a:000[i]) == type([])
line 11:       let list = a:000[i]
line 12:       let j = 0
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 18:     else
line 19:       let path .= "," . a:000[i]
line 20:     endif
line 21:     let i += 1
line 22:   endwhile
line 9:   while i < a:0
line 10:     if type(a:000[i]) == type([])
line 11:       let list = a:000[i]
line 12:       let j = 0
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 18:     else
line 19:       let path .= "," . a:000[i]
line 20:     endif
line 21:     let i += 1
line 22:   endwhile
line 23:   return substitute(path,'^,','','')
function pathogen#infect[8]..pathogen#interpose[15]..pathogen#join returning '/home/ollpu/.vim,/home/ollpu/.vim/bu...vim/addons/after,/home/ollpu/.vim/after'

continuing in function pathogen#infect[8]..pathogen#interpose

line 16:   return 1
function pathogen#infect[8]..pathogen#interpose returning #1

continuing in function pathogen#infect

line 9:     else
line 10:       call s:warn('Change pathogen#infect('.string(path).') to pathogen#infect('.string(path.'/{}').')')
line 11:       call pathogen#interpose(path . '/{}')
line 12:     endif
line 13:   endfor
line 1:   for path in a:0 ? filter(reverse(copy(a:000)), 'type(v:val) == type("")') : ['bundle/{}']
line 2:     if path =~# '^\%({\=[$~\\/]\|{\=\w:[\\/]\).*[{}*]'
line 3:       call pathogen#surround(path)
line 4:     elseif path =~# '^\%([$~\\/]\|\w:[\\/]\)'
line 5:       call s:warn('Change pathogen#infect('.string(path).') to pathogen#infect('.string(path.'/{}').')')
line 6:       call pathogen#surround(path . '/{}')
line 7:     elseif path =~# '[{}*]'
line 8:       call pathogen#interpose(path)
line 9:     else
line 10:       call s:warn('Change pathogen#infect('.string(path).') to pathogen#infect('.string(path.'/{}').')')
line 11:       call pathogen#interpose(path . '/{}')
line 12:     endif
line 13:   endfor
line 14:   call pathogen#cycle_filetype()
calling function pathogen#infect[14]..pathogen#cycle_filetype()

line 1:   if exists('g:did_load_filetypes')
line 2:     filetype off
Searching for "ftoff.vim" in "/home/ollpu/.vim,/home/ollpu/.vim/bundle/fu,/home/ollpu/.vim/bundle/lightline.vim,/home/ollpu/.vim/bundle/molokai,/home/ollpu/.vim/bundle/vim-autoclose,/home/ollpu/.vim/bundle/vim-surround,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/ollpu/.vim/after"
Searching for "/home/ollpu/.vim/ftoff.vim"
Searching for "/home/ollpu/.vim/bundle/fu/ftoff.vim"
Searching for "/home/ollpu/.vim/bundle/lightline.vim/ftoff.vim"
Searching for "/home/ollpu/.vim/bundle/molokai/ftoff.vim"
Searching for "/home/ollpu/.vim/bundle/vim-autoclose/ftoff.vim"
Searching for "/home/ollpu/.vim/bundle/vim-surround/ftoff.vim"
Searching for "/var/lib/vim/addons/ftoff.vim"
Searching for "/usr/share/vim/vimfiles/ftoff.vim"
Searching for "/usr/share/vim/vim74/ftoff.vim"
chdir(/usr/share/vim/vim74)
fchdir() to previous dir
line 2: sourcing "/usr/share/vim/vim74/ftoff.vim"
line 1: " Vim support file to switch off detection of file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last change:^I2001 Jun 11
line 5: 
line 6: if exists("did_load_filetypes")
line 7:   unlet did_load_filetypes
line 8: endif
line 9: 
line 10: " Remove all autocommands in the filetypedetect group
line 11: silent! au! filetypedetect *
finished sourcing /usr/share/vim/vim74/ftoff.vim
continuing in function pathogen#infect[14]..pathogen#cycle_filetype
Searching for "/usr/share/vim/vimfiles/after/ftoff.vim"
Searching for "/var/lib/vim/addons/after/ftoff.vim"
Searching for "/home/ollpu/.vim/after/ftoff.vim"
line 3:     filetype on
Searching for "filetype.vim" in "/home/ollpu/.vim,/home/ollpu/.vim/bundle/fu,/home/ollpu/.vim/bundle/lightline.vim,/home/ollpu/.vim/bundle/molokai,/home/ollpu/.vim/bundle/vim-autoclose,/home/ollpu/.vim/bundle/vim-surround,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/ollpu/.vim/after"
Searching for "/home/ollpu/.vim/filetype.vim"
Searching for "/home/ollpu/.vim/bundle/fu/filetype.vim"
Searching for "/home/ollpu/.vim/bundle/lightline.vim/filetype.vim"
Searching for "/home/ollpu/.vim/bundle/molokai/filetype.vim"
Searching for "/home/ollpu/.vim/bundle/vim-autoclose/filetype.vim"
Searching for "/home/ollpu/.vim/bundle/vim-surround/filetype.vim"
Searching for "/var/lib/vim/addons/filetype.vim"
Searching for "/usr/share/vim/vimfiles/filetype.vim"
Searching for "/usr/share/vim/vim74/filetype.vim"
chdir(/usr/share/vim/vim74)
fchdir() to previous dir
line 3: sourcing "/usr/share/vim/vim74/filetype.vim"
line 1: " Vim support file to detect file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2015 Dec 03
line 5: 
line 6: " Listen very carefully, I will say this only once
line 7: if exists("did_load_filetypes")
line 8:   finish
line 9: endif
line 10: let did_load_filetypes = 1
line 11: 
line 12: " Line continuation is used here, remove 'C' from 'cpoptions'
line 13: let s:cpo_save = &cpo
line 14: set cpo&vim
line 15: 
line 16: augroup filetypedetect
line 17: 
line 18: " Ignored extensions
line 19: if exists("*fnameescape")
line 21: au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
line 28: au BufNewFile,BufRead *~ let s:name = expand("<afile>") | let s:short = substitute(s:name, '\~$', '', '') | if s:name != s:short && s:short != "" |   exe "doau filetypedetect BufRead " . fnameescape(s:short) | endif | unlet! s:name s:short
line 32: au BufNewFile,BufRead ?\+.in if expand("<afile>:t") != "configure.in" |   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) | endif
line 33: elseif &verbose > 0
line 34:   echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
line 35: endif
line 36: 
line 37: " Pattern used to match file names which should not be inspected.
line 38: " Currently finds compressed files.
line 39: if !exists("g:ft_ignore_pat")
line 40:   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
line 41: endif
line 42: 
line 43: " Function used for patterns that end in a star: don't set the filetype if the
line 44: " file name matches ft_ignore_pat.
line 45: func! s:StarSetf(ft)
line 50: 
line 51: " Abaqus or Trasys
line 52: au BufNewFile,BufRead *.inp^I^I^Icall s:Check_inp()
line 53: 
line 54: func! s:Check_inp()
line 73: 
line 74: " A-A-P recipe
line 75: au BufNewFile,BufRead *.aap^I^I^Isetf aap
line 76: 
line 77: " A2ps printing utility
line 78: au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps
line 79: 
line 80: " ABAB/4
line 81: au BufNewFile,BufRead *.abap^I^I^Isetf abap
line 82: 
line 83: " ABC music notation
line 84: au BufNewFile,BufRead *.abc^I^I^Isetf abc
line 85: 
line 86: " ABEL
line 87: au BufNewFile,BufRead *.abl^I^I^Isetf abel
line 88: 
line 89: " AceDB
line 90: au BufNewFile,BufRead *.wrm^I^I^Isetf acedb
line 91: 
line 92: " Ada (83, 9X, 95)
line 93: au BufNewFile,BufRead *.adb,*.ads,*.ada^I^Isetf ada
line 94: if has("vms")
line 95:   au BufNewFile,BufRead *.gpr,*.ada_m,*.adc^Isetf ada
line 96: else
line 97:   au BufNewFile,BufRead *.gpr^I^I^Isetf ada
line 98: endif
line 99: 
line 100: " AHDL
line 101: au BufNewFile,BufRead *.tdf^I^I^Isetf ahdl
line 102: 
line 103: " AMPL
line 104: au BufNewFile,BufRead *.run^I^I^Isetf ampl
line 105: 
line 106: " Ant
line 107: au BufNewFile,BufRead build.xml^I^I^Isetf ant
line 108: 
line 109: " Arduino
line 110: au BufNewFile,BufRead *.ino,*.pde^I^Isetf arduino
line 111: 
line 112: " Apache style config file
line 113: au BufNewFile,BufRead proftpd.conf*^I^Icall s:StarSetf('apachestyle')
line 114: 
line 115: " Apache config file
line 116: au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf^I^Isetf apache
line 117: 
line 118: " XA65 MOS6510 cross assembler
line 119: au BufNewFile,BufRead *.a65^I^I^Isetf a65
line 120: 
line 121: " Applescript
line 122: au BufNewFile,BufRead *.scpt^I^I^Isetf applescript
line 123: 
line 124: " Applix ELF
line 126: au BufNewFile,BufRead *.am if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif
line 127: 
line 128: " ALSA configuration
line 129: au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf
line 130: 
line 131: " Arc Macro Language
line 132: au BufNewFile,BufRead *.aml^I^I^Isetf aml
line 133: 
line 134: " APT config file
line 135: au BufNewFile,BufRead apt.conf^I^I       setf aptconf
line 136: au BufNewFile,BufRead */.aptitude/config       setf aptconf
line 137: au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf
line 138: 
line 139: " Arch Inventory file
line 140: au BufNewFile,BufRead .arch-inventory,=tagging-method^Isetf arch
line 141: 
line 142: " ART*Enterprise (formerly ART-IM)
line 143: au BufNewFile,BufRead *.art^I^I^Isetf art
line 144: 
line 145: " AsciiDoc
line 146: au BufNewFile,BufRead *.asciidoc,*.adoc^I^Isetf asciidoc
line 147: 
line 148: " ASN.1
line 149: au BufNewFile,BufRead *.asn,*.asn1^I^Isetf asn
line 150: 
line 151: " Active Server Pages (with Visual Basic Script)
line 157: au BufNewFile,BufRead *.asa if exists("g:filetype_asa") |   exe "setf " . g:filetype_asa | else |   setf aspvbs | endif
line 158: 
line 159: " Active Server Pages (with Perl or Visual Basic Script)
line 167: au BufNewFile,BufRead *.asp if exists("g:filetype_asp") |   exe "setf " . g:filetype_asp | elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |   setf aspperl | else |   setf aspvbs | endif
line 168: 
line 169: " Grub (must be before catch *.lst)
line 170: au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub
line 171: 
line 172: " Assembly (all kinds)
line 173: " *.lst is not pure assembly, it has two extra columns (address, byte codes)
line 174: au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst^Icall s:FTasm()
line 175: 
line 176: " This function checks for the kind of assembly that is wanted by the user, or
line 177: " can be detected from the first five lines of the file.
line 178: func! s:FTasm()
line 199: 
line 200: func! s:FTasmsyntax()
line 212: 
line 213: " Macro (VAX)
line 214: au BufNewFile,BufRead *.mar^I^I^Isetf vmasm
line 215: 
line 216: " Atlas
line 217: au BufNewFile,BufRead *.atl,*.as^I^Isetf atlas
line 218: 
line 219: " Autoit v3
line 220: au BufNewFile,BufRead *.au3^I^I^Isetf autoit
line 221: 
line 222: " Autohotkey
line 223: au BufNewFile,BufRead *.ahk^I^I^Isetf autohotkey
line 224: 
line 225: " Automake
line 226: au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am^Isetf automake
line 227: 
line 228: " Autotest .at files are actually m4
line 229: au BufNewFile,BufRead *.at^I^I^Isetf m4
line 230: 
line 231: " Avenue
line 232: au BufNewFile,BufRead *.ave^I^I^Isetf ave
line 233: 
line 234: " Awk
line 235: au BufNewFile,BufRead *.awk^I^I^Isetf awk
line 236: 
line 237: " B
line 238: au BufNewFile,BufRead *.mch,*.ref,*.imp^I^Isetf b
line 239: 
line 240: " BASIC or Visual Basic
line 241: au BufNewFile,BufRead *.bas^I^I^Icall s:FTVB("basic")
line 242: 
line 243: " Check if one of the first five lines contains "VB_Name".  In that case it is
line 244: " probably a Visual Basic file.  Otherwise it's assumed to be "alt" filetype.
line 245: func! s:FTVB(alt)
line 252: 
line 253: " Visual Basic Script (close to Visual Basic) or Visual Basic .NET
line 254: au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl^Isetf vb
line 255: 
line 256: " IBasic file (similar to QBasic)
line 257: au BufNewFile,BufRead *.iba,*.ibi^I^Isetf ibasic
line 258: 
line 259: " FreeBasic file (similar to QBasic)
line 260: au BufNewFile,BufRead *.fb,*.bi^I^I^Isetf freebasic
line 261: 
line 262: " Batch file for MSDOS.
line 263: au BufNewFile,BufRead *.bat,*.sys^I^Isetf dosbatch
line 264: " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.
line 266: au BufNewFile,BufRead *.cmd if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif
line 267: 
line 268: " Batch file for 4DOS
line 269: au BufNewFile,BufRead *.btm^I^I^Icall s:FTbtm()
line 270: func! s:FTbtm()
line 277: 
line 278: " BC calculator
line 279: au BufNewFile,BufRead *.bc^I^I^Isetf bc
line 280: 
line 281: " BDF font
line 282: au BufNewFile,BufRead *.bdf^I^I^Isetf bdf
line 283: 
line 284: " BibTeX bibliography database file
line 285: au BufNewFile,BufRead *.bib^I^I^Isetf bib
line 286: 
line 287: " BibTeX Bibliography Style
line 288: au BufNewFile,BufRead *.bst^I^I^Isetf bst
line 289: 
line 290: " BIND configuration
line 291: au BufNewFile,BufRead named.conf,rndc.conf^Isetf named
line 292: 
line 293: " BIND zone
line 294: au BufNewFile,BufRead named.root^I^Isetf bindzone
line 295: au BufNewFile,BufRead *.db^I^I^Icall s:BindzoneCheck('')
line 296: 
line 297: func! s:BindzoneCheck(default)
line 304: 
line 305: " Blank
line 306: au BufNewFile,BufRead *.bl^I^I^Isetf blank
line 307: 
line 308: " Blkid cache file
line 309: au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml
line 310: 
line 311: " Bazel (http://bazel.io)
line 312: autocmd BufRead,BufNewFile *.bzl,BUILD,WORKSPACE setfiletype bzl
line 313: 
line 314: " C or lpc
line 315: au BufNewFile,BufRead *.c^I^I^Icall s:FTlpc()
line 316: 
line 317: func! s:FTlpc()
line 330: 
line 331: " Calendar
line 332: au BufNewFile,BufRead calendar^I^I^Isetf calendar
line 333: 
line 334: " C#
line 335: au BufNewFile,BufRead *.cs^I^I^Isetf cs
line 336: 
line 337: " CSDL
line 338: au BufNewFile,BufRead *.csdl^I^I^Isetf csdl
line 339: 
line 340: " Cabal
line 341: au BufNewFile,BufRead *.cabal^I^I^Isetf cabal
line 342: 
line 343: " Cdrdao TOC
line 344: au BufNewFile,BufRead *.toc^I^I^Isetf cdrtoc
line 345: 
line 346: " Cdrdao config
line 347: au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao^Isetf cdrdaoconf
line 348: 
line 349: " Cfengine
line 350: au BufNewFile,BufRead cfengine.conf^I^Isetf cfengine
line 351: 
line 352: " ChaiScript
line 353: au BufRead,BufNewFile *.chai^I^I^Isetf chaiscript
line 354: 
line 355: " Comshare Dimension Definition Language
line 356: au BufNewFile,BufRead *.cdl^I^I^Isetf cdl
line 357: 
line 358: " Conary Recipe
line 359: au BufNewFile,BufRead *.recipe^I^I^Isetf conaryrecipe
line 360: 
line 361: " Controllable Regex Mutilator
line 362: au BufNewFile,BufRead *.crm^I^I^Isetf crm
line 363: 
line 364: " Cyn++
line 365: au BufNewFile,BufRead *.cyn^I^I^Isetf cynpp
line 366: 
line 367: " Cynlib
line 368: " .cc and .cpp files can be C++ or Cynlib.
line 370: au BufNewFile,BufRead *.cc if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif
line 372: au BufNewFile,BufRead *.cpp if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif
line 373: 
line 374: " C++
line 375: au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
line 376: if has("fname_case")
line 377:   au BufNewFile,BufRead *.C,*.H setf cpp
line 378: endif
line 379: 
line 380: " .h files can be C, Ch C++, ObjC or ObjC++.
line 381: " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is
line 382: " detected automatically.
line 383: au BufNewFile,BufRead *.h^I^I^Icall s:FTheader()
line 384: 
line 385: func! s:FTheader()
line 400: 
line 401: " Ch (CHscript)
line 402: au BufNewFile,BufRead *.chf^I^I^Isetf ch
line 403: 
line 404: " TLH files are C++ headers generated by Visual C++'s #import from typelibs
line 405: au BufNewFile,BufRead *.tlh^I^I^Isetf cpp
line 406: 
line 407: " Cascading Style Sheets
line 408: au BufNewFile,BufRead *.css^I^I^Isetf css
line 409: 
line 410: " Century Term Command Scripts (*.cmd too)
line 411: au BufNewFile,BufRead *.con^I^I^Isetf cterm
line 412: 
line 413: " Changelog
line 415: au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch^Isetf debchangelog
line 416: 
line 422: au BufNewFile,BufRead [cC]hange[lL]og  if getline(1) =~ '; urgency='|   setf debchangelog| else|   setf changelog| endif
line 423: 
line 427: au BufNewFile,BufRead NEWS  if getline(1) =~ '; urgency='|   setf debchangelog| endif
line 428: 
line 429: " CHILL
line 430: au BufNewFile,BufRead *..ch^I^I^Isetf chill
line 431: 
line 432: " Changes for WEB and CWEB or CHILL
line 433: au BufNewFile,BufRead *.ch^I^I^Icall s:FTchange()
line 434: 
line 435: " This function checks if one of the first ten lines start with a '@'.  In
line 436: " that case it is probably a change file.
line 437: " If the first line starts with # or ! it's probably a ch file.
line 438: " If a line has "main", "include", "//" ir "/*" it's probably ch.
line 439: " Otherwise CHILL is assumed.
line 440: func! s:FTchange()
line 463: 
line 464: " ChordPro
line 465: au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro^Isetf chordpro
line 466: 
line 467: " Clean
line 468: au BufNewFile,BufRead *.dcl,*.icl^I^Isetf clean
line 469: 
line 470: " Clever
line 471: au BufNewFile,BufRead *.eni^I^I^Isetf cl
line 472: 
line 473: " Clever or dtd
line 474: au BufNewFile,BufRead *.ent^I^I^Icall s:FTent()
line 475: 
line 476: func! s:FTent()
line 495: 
line 496: " Clipper (or FoxPro; could also be eviews)
line 502: au BufNewFile,BufRead *.prg if exists("g:filetype_prg") |   exe "setf " . g:filetype_prg | else |   setf clipper | endif
line 503: 
line 504: " Clojure
line 505: au BufNewFile,BufRead *.clj,*.cljs,*.cljx,*.cljc^I^Isetf clojure
line 506: 
line 507: " Cmake
line 508: au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in^I^Isetf cmake
line 509: 
line 510: " Cmusrc
line 511: au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc
line 512: au BufNewFile,BufRead */cmus/{rc,*.theme}^I^I^Isetf cmusrc
line 513: 
line 514: " Cobol
line 515: au BufNewFile,BufRead *.cbl,*.cob,*.lib^Isetf cobol
line 516: "   cobol or zope form controller python script? (heuristic)
line 522: au BufNewFile,BufRead *.cpy if getline(1) =~ '^##' |   setf python | else |   setf cobol | endif
line 523: 
line 524: " Coco/R
line 525: au BufNewFile,BufRead *.atg^I^I^Isetf coco
line 526: 
line 527: " Cold Fusion
line 528: au BufNewFile,BufRead *.cfm,*.cfi,*.cfc^I^Isetf cf
line 529: 
line 530: " Configure scripts
line 531: au BufNewFile,BufRead configure.in,configure.ac setf config
line 532: 
line 533: " CUDA  Cumpute Unified Device Architecture
line 534: au BufNewFile,BufRead *.cu^I^I^Isetf cuda
line 535: 
line 536: " Dockerfile
line 537: au BufNewFile,BufRead Dockerfile^I^Isetf dockerfile
line 538: 
line 539: " WildPackets EtherPeek Decoder
line 540: au BufNewFile,BufRead *.dcd^I^I^Isetf dcd
line 541: 
line 542: " Enlightenment configuration files
line 543: au BufNewFile,BufRead *enlightenment/*.cfg^Isetf c
line 544: 
line 545: " Eterm
line 546: au BufNewFile,BufRead *Eterm/*.cfg^I^Isetf eterm
line 547: 
line 548: " Euphoria 3 or 4
line 549: au BufNewFile,BufRead *.eu,*.ew,*.ex,*.exu,*.exw  call s:EuphoriaCheck()
line 550: if has("fname_case")
line 551:    au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call s:EuphoriaCheck()
line 552: endif
line 553: 
line 554: func! s:EuphoriaCheck()
line 561: 
line 562: " Lynx config files
line 563: au BufNewFile,BufRead lynx.cfg^I^I^Isetf lynx
line 564: 
line 565: " Quake
line 566: au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg^Isetf quake
line 567: au BufNewFile,BufRead *quake[1-3]/*.cfg^I^I^Isetf quake
line 568: 
line 569: " Quake C
line 570: au BufNewFile,BufRead *.qc^I^I^Isetf c
line 571: 
line 572: " Configure files
line 573: au BufNewFile,BufRead *.cfg^I^I^Isetf cfg
line 574: 
line 575: " Cucumber
line 576: au BufNewFile,BufRead *.feature^I^I^Isetf cucumber
line 577: 
line 578: " Communicating Sequential Processes
line 579: au BufNewFile,BufRead *.csp,*.fdr^I^Isetf csp
line 580: 
line 581: " CUPL logic description and simulation
line 582: au BufNewFile,BufRead *.pld^I^I^Isetf cupl
line 583: au BufNewFile,BufRead *.si^I^I^Isetf cuplsim
line 584: 
line 585: " Debian Control
line 586: au BufNewFile,BufRead */debian/control^I^Isetf debcontrol
line 590: au BufNewFile,BufRead control  if getline(1) =~ '^Source:'|   setf debcontrol| endif
line 591: 
line 592: " Debian Sources.list
line 593: au BufNewFile,BufRead */etc/apt/sources.list^I^Isetf debsources
line 594: au BufNewFile,BufRead */etc/apt/sources.list.d/*.list^Isetf debsources
line 595: 
line 596: " Deny hosts
line 597: au BufNewFile,BufRead denyhosts.conf^I^Isetf denyhosts
line 598: 
line 599: " dnsmasq(8) configuration files
line 600: au BufNewFile,BufRead */etc/dnsmasq.conf^Isetf dnsmasq
line 601: 
line 602: " ROCKLinux package description
line 603: au BufNewFile,BufRead *.desc^I^I^Isetf desc
line 604: 
line 605: " the D language or dtrace
line 606: au BufNewFile,BufRead *.d^I^I^Icall s:DtraceCheck()
line 607: 
line 608: func! s:DtraceCheck()
line 619: 
line 620: " Desktop files
line 621: au BufNewFile,BufRead *.desktop,.directory^Isetf desktop
line 622: 
line 623: " Dict config
line 624: au BufNewFile,BufRead dict.conf,.dictrc^I^Isetf dictconf
line 625: 
line 626: " Dictd config
line 627: au BufNewFile,BufRead dictd.conf^I^Isetf dictdconf
line 628: 
line 629: " Diff files
line 630: au BufNewFile,BufRead *.diff,*.rej,*.patch^Isetf diff
line 631: 
line 632: " Dircolors
line 633: au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS^Isetf dircolors
line 634: 
line 635: " Diva (with Skill) or InstallShield
line 641: au BufNewFile,BufRead *.rul if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |   setf ishd | else |   setf diva | endif
line 642: 
line 643: " DCL (Digital Command Language - vms) or DNS zone file
line 644: au BufNewFile,BufRead *.com^I^I^Icall s:BindzoneCheck('dcl')
line 645: 
line 646: " DOT
line 647: au BufNewFile,BufRead *.dot^I^I^Isetf dot
line 648: 
line 649: " Dylan - lid files
line 650: au BufNewFile,BufRead *.lid^I^I^Isetf dylanlid
line 651: 
line 652: " Dylan - intr files (melange)
line 653: au BufNewFile,BufRead *.intr^I^I^Isetf dylanintr
line 654: 
line 655: " Dylan
line 656: au BufNewFile,BufRead *.dylan^I^I^Isetf dylan
line 657: 
line 658: " Microsoft Module Definition
line 659: au BufNewFile,BufRead *.def^I^I^Isetf def
line 660: 
line 661: " Dracula
line 662: au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe^Isetf dracula
line 663: 
line 664: " Datascript
line 665: au BufNewFile,BufRead *.ds^I^I^Isetf datascript
line 666: 
line 667: " dsl
line 668: au BufNewFile,BufRead *.dsl^I^I^Isetf dsl
line 669: 
line 670: " DTD (Document Type Definition for XML)
line 671: au BufNewFile,BufRead *.dtd^I^I^Isetf dtd
line 672: 
line 673: " DTS/DSTI (device tree files)
line 674: au BufNewFile,BufRead *.dts,*.dtsi^I^Isetf dts
line 675: 
line 676: " EDIF (*.edf,*.edif,*.edn,*.edo)
line 677: au BufNewFile,BufRead *.ed\(f\|if\|n\|o\)^Isetf edif
line 678: 
line 679: " Embedix Component Description
line 680: au BufNewFile,BufRead *.ecd^I^I^Isetf ecd
line 681: 
line 682: " Eiffel or Specman or Euphoria
line 683: au BufNewFile,BufRead *.e,*.E^I^I^Icall s:FTe()
line 684: 
line 685: " Elinks configuration
line 686: au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf^Isetf elinks
line 687: 
line 688: func! s:FTe()
line 703: 
line 704: " ERicsson LANGuage; Yaws is erlang too
line 705: au BufNewFile,BufRead *.erl,*.hrl,*.yaws^Isetf erlang
line 706: 
line 707: " Elm Filter Rules file
line 708: au BufNewFile,BufRead filter-rules^I^Isetf elmfilt
line 709: 
line 710: " ESMTP rc file
line 711: au BufNewFile,BufRead *esmtprc^I^I^Isetf esmtprc
line 712: 
line 713: " ESQL-C
line 714: au BufNewFile,BufRead *.ec,*.EC^I^I^Isetf esqlc
line 715: 
line 716: " Esterel
line 717: au BufNewFile,BufRead *.strl^I^I^Isetf esterel
line 718: 
line 719: " Essbase script
line 720: au BufNewFile,BufRead *.csc^I^I^Isetf csc
line 721: 
line 722: " Exim
line 723: au BufNewFile,BufRead exim.conf^I^I^Isetf exim
line 724: 
line 725: " Expect
line 726: au BufNewFile,BufRead *.exp^I^I^Isetf expect
line 727: 
line 728: " Exports
line 729: au BufNewFile,BufRead exports^I^I^Isetf exports
line 730: 
line 731: " Falcon
line 732: au BufNewFile,BufRead *.fal^I^I^Isetf falcon
line 733: 
line 734: " Fantom
line 735: au BufNewFile,BufRead *.fan,*.fwt^I^Isetf fan
line 736: 
line 737: " Factor
line 738: au BufNewFile,BufRead *.factor^I^I^Isetf factor
line 739: 
line 740: " Fetchmail RC file
line 741: au BufNewFile,BufRead .fetchmailrc^I^Isetf fetchmail
line 742: 
line 743: " FlexWiki - disabled, because it has side effects when a .wiki file
line 744: " is not actually FlexWiki
line 745: "au BufNewFile,BufRead *.wiki^I^I^Isetf flexwiki
line 746: 
line 747: " Focus Executable
line 748: au BufNewFile,BufRead *.fex,*.focexec^I^Isetf focexec
line 749: 
line 750: " Focus Master file (but not for auto.master)
line 751: au BufNewFile,BufRead auto.master^I^Isetf conf
line 752: au BufNewFile,BufRead *.mas,*.master^I^Isetf master
line 753: 
line 754: " Forth
line 755: au BufNewFile,BufRead *.fs,*.ft^I^I^Isetf forth
line 756: 
line 757: " Reva Forth
line 758: au BufNewFile,BufRead *.frt^I^I^Isetf reva
line 759: 
line 760: " Fortran
line 761: if has("fname_case")
line 762:   au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08^I setf fortran
line 763: endif
line 764: au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran
line 765: 
line 766: " Framescript
line 767: au BufNewFile,BufRead *.fsl^I^I^Isetf framescript
line 768: 
line 769: " FStab
line 770: au BufNewFile,BufRead fstab,mtab^I^Isetf fstab
line 771: 
line 772: " GDB command files
line 773: au BufNewFile,BufRead .gdbinit^I^I^Isetf gdb
line 774: 
line 775: " GDMO
line 776: au BufNewFile,BufRead *.mo,*.gdmo^I^Isetf gdmo
line 777: 
line 778: " Gedcom
line 779: au BufNewFile,BufRead *.ged,lltxxxxx.txt^Isetf gedcom
line 780: 
line 781: " Git
line 782: au BufNewFile,BufRead COMMIT_EDITMSG^I^Isetf gitcommit
line 783: au BufNewFile,BufRead MERGE_MSG^I^I^Isetf gitcommit
line 784: au BufNewFile,BufRead *.git/config,.gitconfig,.gitmodules setf gitconfig
line 785: au BufNewFile,BufRead *.git/modules/*/config^Isetf gitconfig
line 786: au BufNewFile,BufRead */.config/git/config^Isetf gitconfig
line 787: if !empty($XDG_CONFIG_HOME)
line 788:   au BufNewFile,BufRead $XDG_CONFIG_HOME/git/config^Isetf gitconfig
line 789: endif
line 790: au BufNewFile,BufRead git-rebase-todo^I^Isetf gitrebase
line 794: au BufNewFile,BufRead .msg.[0-9]* if getline(1) =~ '^From.*# This line is ignored.$' |   setf gitsendemail | endif
line 798: au BufNewFile,BufRead *.git/* if getline(1) =~ '^\x\{40\}\>\|^ref: ' |   setf git | endif
line 799: 
line 800: " Gkrellmrc
line 801: au BufNewFile,BufRead gkrellmrc,gkrellmrc_?^Isetf gkrellmrc
line 802: 
line 803: " GP scripts (2.0 and onward)
line 804: au BufNewFile,BufRead *.gp,.gprc^I^Isetf gp
line 805: 
line 806: " GPG
line 807: au BufNewFile,BufRead */.gnupg/options^I^Isetf gpg
line 808: au BufNewFile,BufRead */.gnupg/gpg.conf^I^Isetf gpg
line 809: au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg
line 810: 
line 811: " gnash(1) configuration files
line 812: au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash
line 813: 
line 814: " Gitolite
line 815: au BufNewFile,BufRead gitolite.conf^I^Isetf gitolite
line 816: au BufNewFile,BufRead */gitolite-admin/conf/*^Icall s:StarSetf('gitolite')
line 817: au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc^Isetf perl
line 818: 
line 819: " Gnuplot scripts
line 820: au BufNewFile,BufRead *.gpi^I^I^Isetf gnuplot
line 821: 
line 822: " Go (Google)
line 823: au BufNewFile,BufRead *.go^I^I^Isetf go
line 824: 
line 825: " GrADS scripts
line 826: au BufNewFile,BufRead *.gs^I^I^Isetf grads
line 827: 
line 828: " Gretl
line 829: au BufNewFile,BufRead *.gretl^I^I^Isetf gretl
line 830: 
line 831: " Groovy
line 832: au BufNewFile,BufRead *.gradle,*.groovy^I^Isetf groovy
line 833: 
line 834: " GNU Server Pages
line 835: au BufNewFile,BufRead *.gsp^I^I^Isetf gsp
line 836: 
line 837: " Group file
line 838: au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group
line 839: 
line 840: " GTK RC
line 841: au BufNewFile,BufRead .gtkrc,gtkrc^I^Isetf gtkrc
line 842: 
line 843: " Haml
line 844: au BufNewFile,BufRead *.haml^I^I^Isetf haml
line 845: 
line 846: " Hamster Classic | Playground files
line 847: au BufNewFile,BufRead *.hsc,*.hsm^I^Isetf hamster
line 848: 
line 849: " Haskell
line 850: au BufNewFile,BufRead *.hs,*.hs-boot^I^Isetf haskell
line 851: au BufNewFile,BufRead *.lhs^I^I^Isetf lhaskell
line 852: au BufNewFile,BufRead *.chs^I^I^Isetf chaskell
line 853: 
line 854: " Haste
line 855: au BufNewFile,BufRead *.ht^I^I^Isetf haste
line 856: au BufNewFile,BufRead *.htpp^I^I^Isetf hastepreproc
line 857: 
line 858: " Hercules
line 859: au BufNewFile,BufRead *.vc,*.ev,*.rs,*.sum,*.errsum^Isetf hercules
line 860: 
line 861: " HEX (Intel)
line 862: au BufNewFile,BufRead *.hex,*.h32^I^Isetf hex
line 863: 
line 864: " Tilde (must be before HTML)
line 865: au BufNewFile,BufRead *.t.html^I^I^Isetf tilde
line 866: 
line 867: " HTML (.shtml and .stm for server side)
line 868: au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call s:FThtml()
line 869: 
line 870: " Distinguish between HTML, XHTML and Django
line 871: func! s:FThtml()
line 886: 
line 887: " HTML with Ruby - eRuby
line 888: au BufNewFile,BufRead *.erb,*.rhtml^I^Isetf eruby
line 889: 
line 890: " HTML with M4
line 891: au BufNewFile,BufRead *.html.m4^I^I^Isetf htmlm4
line 892: 
line 893: " HTML Cheetah template
line 894: au BufNewFile,BufRead *.tmpl^I^I^Isetf htmlcheetah
line 895: 
line 896: " Host config
line 897: au BufNewFile,BufRead */etc/host.conf^I^Isetf hostconf
line 898: 
line 899: " Hosts access
line 900: au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess
line 901: 
line 902: " Hyper Builder
line 903: au BufNewFile,BufRead *.hb^I^I^Isetf hb
line 904: 
line 905: " Httest
line 906: au BufNewFile,BufRead *.htt,*.htb^I^Isetf httest
line 907: 
line 908: " Icon
line 909: au BufNewFile,BufRead *.icn^I^I^Isetf icon
line 910: 
line 911: " IDL (Interface Description Language)
line 912: au BufNewFile,BufRead *.idl^I^I^Icall s:FTidl()
line 913: 
line 914: " Distinguish between standard IDL and MS-IDL
line 915: func! s:FTidl()
line 926: 
line 927: " Microsoft IDL (Interface Description Language)  Also *.idl
line 928: " MOF = WMI (Windows Management Instrumentation) Managed Object Format
line 929: au BufNewFile,BufRead *.odl,*.mof^I^Isetf msidl
line 930: 
line 931: " Icewm menu
line 932: au BufNewFile,BufRead */.icewm/menu^I^Isetf icemenu
line 933: 
line 934: " Indent profile (must come before IDL *.pro!)
line 935: au BufNewFile,BufRead .indent.pro^I^Isetf indent
line 936: au BufNewFile,BufRead indent.pro^I^Icall s:ProtoCheck('indent')
line 937: 
line 938: " IDL (Interactive Data Language)
line 939: au BufNewFile,BufRead *.pro^I^I^Icall s:ProtoCheck('idlang')
line 940: 
line 941: " Distinguish between "default" and Cproto prototype file. */
line 942: func! s:ProtoCheck(default)
line 954: 
line 955: 
line 956: " Indent RC
line 957: au BufNewFile,BufRead indentrc^I^I^Isetf indent
line 958: 
line 959: " Inform
line 960: au BufNewFile,BufRead *.inf,*.INF^I^Isetf inform
line 961: 
line 962: " Initng
line 963: au BufNewFile,BufRead */etc/initng/*/*.i,*.ii^Isetf initng
line 964: 
line 965: " Innovation Data Processing
line 966: au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c ^Isetf upstreamdat
line 967: au BufRead,BufNewFile upstream.log\c,upstream.*.log\c,*.upstream.log\c ^Isetf upstreamlog
line 968: au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog
line 969: au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c ^Isetf usserverlog
line 970: au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c ^Isetf usw2kagtlog
line 971: 
line 972: " Ipfilter
line 973: au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules^Isetf ipfilter
line 974: 
line 975: " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
line 976: au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl^Isetf fgl
line 977: 
line 978: " .INI file for MSDOS
line 979: au BufNewFile,BufRead *.ini^I^I^Isetf dosini
line 980: 
line 981: " SysV Inittab
line 982: au BufNewFile,BufRead inittab^I^I^Isetf inittab
line 983: 
line 984: " Inno Setup
line 985: au BufNewFile,BufRead *.iss^I^I^Isetf iss
line 986: 
line 987: " J
line 988: au BufNewFile,BufRead *.ijs^I^I^Isetf j
line 989: 
line 990: " JAL
line 991: au BufNewFile,BufRead *.jal,*.JAL^I^Isetf jal
line 992: 
line 993: " Jam
line 994: au BufNewFile,BufRead *.jpl,*.jpr^I^Isetf jam
line 995: 
line 996: " Java
line 997: au BufNewFile,BufRead *.java,*.jav^I^Isetf java
line 998: 
line 999: " JavaCC
line 1000: au BufNewFile,BufRead *.jj,*.jjt^I^Isetf javacc
line 1001: 
line 1002: " JavaScript, ECMAScript
line 1003: au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx   setf javascript
line 1004: 
line 1005: " Java Server Pages
line 1006: au BufNewFile,BufRead *.jsp^I^I^Isetf jsp
line 1007: 
line 1008: " Java Properties resource file (note: doesn't catch font.properties.pl)
line 1009: au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??^Isetf jproperties
line 1010: au BufNewFile,BufRead *.properties_??_??_*^Icall s:StarSetf('jproperties')
line 1011: 
line 1012: " Jess
line 1013: au BufNewFile,BufRead *.clp^I^I^Isetf jess
line 1014: 
line 1015: " Jgraph
line 1016: au BufNewFile,BufRead *.jgr^I^I^Isetf jgraph
line 1017: 
line 1018: " Jovial
line 1019: au BufNewFile,BufRead *.jov,*.j73,*.jovial^Isetf jovial
line 1020: 
line 1021: " JSON
line 1022: au BufNewFile,BufRead *.json,*.jsonp^I^Isetf json
line 1023: 
line 1024: " Kixtart
line 1025: au BufNewFile,BufRead *.kix^I^I^Isetf kix
line 1026: 
line 1027: " Kimwitu[++]
line 1028: au BufNewFile,BufRead *.k^I^I^Isetf kwt
line 1029: 
line 1030: " Kivy
line 1031: au BufNewFile,BufRead *.kv^I^I^Isetf kivy
line 1032: 
line 1033: " KDE script
line 1034: au BufNewFile,BufRead *.ks^I^I^Isetf kscript
line 1035: 
line 1036: " Kconfig
line 1037: au BufNewFile,BufRead Kconfig,Kconfig.debug^Isetf kconfig
line 1038: 
line 1039: " Lace (ISE)
line 1040: au BufNewFile,BufRead *.ace,*.ACE^I^Isetf lace
line 1041: 
line 1042: " Latte
line 1043: au BufNewFile,BufRead *.latte,*.lte^I^Isetf latte
line 1044: 
line 1045: " Limits
line 1046: au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf^Isetf limits
line 1047: 
line 1048: " LambdaProlog (*.mod too, see Modsim)
line 1049: au BufNewFile,BufRead *.sig^I^I^Isetf lprolog
line 1050: 
line 1051: " LDAP LDIF
line 1052: au BufNewFile,BufRead *.ldif^I^I^Isetf ldif
line 1053: 
line 1054: " Ld loader
line 1055: au BufNewFile,BufRead *.ld^I^I^Isetf ld
line 1056: 
line 1057: " Less
line 1058: au BufNewFile,BufRead *.less^I^I^Isetf less
line 1059: 
line 1060: " Lex
line 1061: au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++^Isetf lex
line 1062: 
line 1063: " Libao
line 1064: au BufNewFile,BufRead */etc/libao.conf,*/.libao^Isetf libao
line 1065: 
line 1066: " Libsensors
line 1067: au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf^Isetf sensors
line 1068: 
line 1069: " LFTP
line 1070: au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc^Isetf lftp
line 1071: 
line 1072: " Lifelines (or Lex for C++!)
line 1073: au BufNewFile,BufRead *.ll^I^I^Isetf lifelines
line 1074: 
line 1075: " Lilo: Linux loader
line 1076: au BufNewFile,BufRead lilo.conf^I^I^Isetf lilo
line 1077: 
line 1078: " Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)
line 1079: if has("fname_case")
line 1080:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp
line 1081: else
line 1082:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp
line 1083: endif
line 1084: 
line 1085: " SBCL implementation of Common Lisp
line 1086: au BufNewFile,BufRead sbclrc,.sbclrc^I^Isetf lisp
line 1087: 
line 1088: " Liquid
line 1089: au BufNewFile,BufRead *.liquid^I^I^Isetf liquid
line 1090: 
line 1091: " Lite
line 1092: au BufNewFile,BufRead *.lite,*.lt^I^Isetf lite
line 1093: 
line 1094: " LiteStep RC files
line 1095: au BufNewFile,BufRead */LiteStep/*/*.rc^I^Isetf litestep
line 1096: 
line 1097: " Login access
line 1098: au BufNewFile,BufRead */etc/login.access^Isetf loginaccess
line 1099: 
line 1100: " Login defs
line 1101: au BufNewFile,BufRead */etc/login.defs^I^Isetf logindefs
line 1102: 
line 1103: " Logtalk
line 1104: au BufNewFile,BufRead *.lgt^I^I^Isetf logtalk
line 1105: 
line 1106: " LOTOS
line 1107: au BufNewFile,BufRead *.lot,*.lotos^I^Isetf lotos
line 1108: 
line 1109: " Lout (also: *.lt)
line 1110: au BufNewFile,BufRead *.lou,*.lout^I^Isetf lout
line 1111: 
line 1112: " Lua
line 1113: au BufNewFile,BufRead *.lua^I^I^Isetf lua
line 1114: 
line 1115: " Luarocks
line 1116: au BufNewFile,BufRead *.rockspec^I^Isetf lua
line 1117: 
line 1118: " Linden Scripting Language (Second Life)
line 1119: au BufNewFile,BufRead *.lsl^I^I^Isetf lsl
line 1120: 
line 1121: " Lynx style file (or LotusScript!)
line 1122: au BufNewFile,BufRead *.lss^I^I^Isetf lss
line 1123: 
line 1124: " M4
line 1126: au BufNewFile,BufRead *.m4 if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif
line 1127: 
line 1128: " MaGic Point
line 1129: au BufNewFile,BufRead *.mgp^I^I^Isetf mgp
line 1130: 
line 1131: " Mail (for Elm, trn, mutt, muttng, rn, slrn)
line 1132: au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail
line 1133: 
line 1134: " Mail aliases
line 1135: au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases^Isetf mailaliases
line 1136: 
line 1137: " Mailcap configuration file
line 1138: au BufNewFile,BufRead .mailcap,mailcap^I^Isetf mailcap
line 1139: 
line 1140: " Makefile
line 1141: au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make
line 1142: 
line 1143: " MakeIndex
line 1144: au BufNewFile,BufRead *.ist,*.mst^I^Isetf ist
line 1145: 
line 1146: " Mallard
line 1147: au BufNewFile,BufRead *.page^I^I^Isetf mallard
line 1148: 
line 1149: " Manpage
line 1150: au BufNewFile,BufRead *.man^I^I^Isetf man
line 1151: 
line 1152: " Man config
line 1153: au BufNewFile,BufRead */etc/man.conf,man.config^Isetf manconf
line 1154: 
line 1155: " Maple V
line 1156: au BufNewFile,BufRead *.mv,*.mpl,*.mws^I^Isetf maple
line 1157: 
line 1158: " Map (UMN mapserver config file)
line 1159: au BufNewFile,BufRead *.map^I^I^Isetf map
line 1160: 
line 1161: " Markdown
line 1162: au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,*.md  setf markdown
line 1163: 
line 1164: " Mason
line 1165: au BufNewFile,BufRead *.mason,*.mhtml,*.comp^Isetf mason
line 1166: 
line 1167: " Matlab or Objective C
line 1168: au BufNewFile,BufRead *.m^I^I^Icall s:FTm()
line 1169: 
line 1170: func! s:FTm()
line 1194: 
line 1195: " Mathematica notebook
line 1196: au BufNewFile,BufRead *.nb^I^I^Isetf mma
line 1197: 
line 1198: " Maya Extension Language
line 1199: au BufNewFile,BufRead *.mel^I^I^Isetf mel
line 1200: 
line 1201: " Mercurial (hg) commit file
line 1202: au BufNewFile,BufRead hg-editor-*.txt^I^Isetf hgcommit
line 1203: 
line 1204: " Mercurial config (looks like generic config file)
line 1205: au BufNewFile,BufRead *.hgrc,*hgrc^I^Isetf cfg
line 1206: 
line 1207: " Messages (logs mostly)
line 1208: au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages
line 1209: 
line 1210: " Metafont
line 1211: au BufNewFile,BufRead *.mf^I^I^Isetf mf
line 1212: 
line 1213: " MetaPost
line 1214: au BufNewFile,BufRead *.mp^I^I^Isetf mp
line 1215: 
line 1216: " MGL
line 1217: au BufNewFile,BufRead *.mgl^I^I^Isetf mgl
line 1218: 
line 1219: " MIX - Knuth assembly
line 1220: au BufNewFile,BufRead *.mix,*.mixal^I^Isetf mix
line 1221: 
line 1222: " MMIX or VMS makefile
line 1223: au BufNewFile,BufRead *.mms^I^I^Icall s:FTmms()
line 1224: 
line 1225: " Symbian meta-makefile definition (MMP)
line 1226: au BufNewFile,BufRead *.mmp^I^I^Isetf mmp
line 1227: 
line 1228: func! s:FTmms()
line 1244: 
line 1245: 
line 1246: " Modsim III (or LambdaProlog)
line 1252: au BufNewFile,BufRead *.mod if getline(1) =~ '\<module\>' |   setf lprolog | else |   setf modsim3 | endif
line 1253: 
line 1254: " Modula 2  (.md removed in favor of Markdown)
line 1255: au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.mi^Isetf modula2
line 1256: 
line 1257: " Modula 3 (.m3, .i3, .mg, .ig)
line 1258: au BufNewFile,BufRead *.[mi][3g]^I^Isetf modula3
line 1259: 
line 1260: " Monk
line 1261: au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc^Isetf monk
line 1262: 
line 1263: " MOO
line 1264: au BufNewFile,BufRead *.moo^I^I^Isetf moo
line 1265: 
line 1266: " Modconf
line 1267: au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf
line 1268: 
line 1269: " Mplayer config
line 1270: au BufNewFile,BufRead mplayer.conf,*/.mplayer/config^Isetf mplayerconf
line 1271: 
line 1272: " Motorola S record
line 1273: au BufNewFile,BufRead *.s19,*.s28,*.s37,*.mot,*.srec^Isetf srec
line 1274: 
line 1275: " Mrxvtrc
line 1276: au BufNewFile,BufRead mrxvtrc,.mrxvtrc^I^Isetf mrxvtrc
line 1277: 
line 1278: " Msql
line 1279: au BufNewFile,BufRead *.msql^I^I^Isetf msql
line 1280: 
line 1281: " Mysql
line 1282: au BufNewFile,BufRead *.mysql^I^I^Isetf mysql
line 1283: 
line 1284: " Mutt setup files (must be before catch *.rc)
line 1285: au BufNewFile,BufRead */etc/Muttrc.d/*^I^Icall s:StarSetf('muttrc')
line 1286: 
line 1287: " M$ Resource files
line 1288: au BufNewFile,BufRead *.rc,*.rch^I^Isetf rc
line 1289: 
line 1290: " MuPAD source
line 1291: au BufRead,BufNewFile *.mu^I^I^Isetf mupad
line 1292: 
line 1293: " Mush
line 1294: au BufNewFile,BufRead *.mush^I^I^Isetf mush
line 1295: 
line 1296: " Mutt setup file (also for Muttng)
line 1297: au BufNewFile,BufRead Mutt{ng,}rc^I^Isetf muttrc
line 1298: 
line 1299: " Nano
line 1300: au BufNewFile,BufRead */etc/nanorc,*.nanorc  ^Isetf nanorc
line 1301: 
line 1302: " Nastran input/DMAP
line 1303: "au BufNewFile,BufRead *.dat^I^I^Isetf nastran
line 1304: 
line 1305: " Natural
line 1306: au BufNewFile,BufRead *.NS[ACGLMNPS]^I^Isetf natural
line 1307: 
line 1308: " Netrc
line 1309: au BufNewFile,BufRead .netrc^I^I^Isetf netrc
line 1310: 
line 1311: " Ninja file
line 1312: au BufNewFile,BufRead *.ninja^I^I^Isetf ninja
line 1313: 
line 1314: " Novell netware batch files
line 1315: au BufNewFile,BufRead *.ncf^I^I^Isetf ncf
line 1316: 
line 1317: " Nroff/Troff (*.ms and *.t are checked below)
line 1321: au BufNewFile,BufRead *.me if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |   setf nroff | endif
line 1322: au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom^Isetf nroff
line 1323: au BufNewFile,BufRead *.[1-9]^I^I^Icall s:FTnroff()
line 1324: 
line 1325: " This function checks if one of the first five lines start with a dot.  In
line 1326: " that case it is probably an nroff file: 'filetype' is set and 1 is returned.
line 1327: func! s:FTnroff()
line 1334: 
line 1335: " Nroff or Objective C++
line 1336: au BufNewFile,BufRead *.mm^I^I^Icall s:FTmm()
line 1337: 
line 1338: func! s:FTmm()
line 1350: 
line 1351: " Not Quite C
line 1352: au BufNewFile,BufRead *.nqc^I^I^Isetf nqc
line 1353: 
line 1354: " NSIS
line 1355: au BufNewFile,BufRead *.nsi,*.nsh^I^Isetf nsis
line 1356: 
line 1357: " OCAML
line 1358: au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit^Isetf ocaml
line 1359: 
line 1360: " Occam
line 1361: au BufNewFile,BufRead *.occ^I^I^Isetf occam
line 1362: 
line 1363: " Omnimark
line 1364: au BufNewFile,BufRead *.xom,*.xin^I^Isetf omnimark
line 1365: 
line 1366: " OpenROAD
line 1367: au BufNewFile,BufRead *.or^I^I^Isetf openroad
line 1368: 
line 1369: " OPL
line 1370: au BufNewFile,BufRead *.[Oo][Pp][Ll]^I^Isetf opl
line 1371: 
line 1372: " Oracle config file
line 1373: au BufNewFile,BufRead *.ora^I^I^Isetf ora
line 1374: 
line 1375: " Packet filter conf
line 1376: au BufNewFile,BufRead pf.conf^I^I^Isetf pf
line 1377: 
line 1378: " Pam conf
line 1379: au BufNewFile,BufRead */etc/pam.conf^I^Isetf pamconf
line 1380: 
line 1381: " PApp
line 1382: au BufNewFile,BufRead *.papp,*.pxml,*.pxsl^Isetf papp
line 1383: 
line 1384: " Password file
line 1385: au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd
line 1386: 
line 1387: " Pascal (also *.p)
line 1388: au BufNewFile,BufRead *.pas^I^I^Isetf pascal
line 1389: 
line 1390: " Delphi project file
line 1391: au BufNewFile,BufRead *.dpr^I^I^Isetf pascal
line 1392: 
line 1393: " PDF
line 1394: au BufNewFile,BufRead *.pdf^I^I^Isetf pdf
line 1395: 
line 1396: " Perl
line 1397: if has("fname_case")
line 1398:   au BufNewFile,BufRead *.pl,*.PL^I^Icall s:FTpl()
line 1399: else
line 1400:   au BufNewFile,BufRead *.pl^I^I^Icall s:FTpl()
line 1401: endif
line 1402: au BufNewFile,BufRead *.plx,*.al^I^Isetf perl
line 1403: au BufNewFile,BufRead *.p6,*.pm6,*.pl6^I^Isetf perl6
line 1404: 
line 1405: func! s:FTpl()
line 1419: 
line 1420: " Perl, XPM or XPM2
line 1428: au BufNewFile,BufRead *.pm if getline(1) =~ "XPM2" |   setf xpm2 | elseif getline(1) =~ "XPM" |   setf xpm | else |   setf perl | endif
line 1429: 
line 1430: " Perl POD
line 1431: au BufNewFile,BufRead *.pod^I^I^Isetf pod
line 1432: au BufNewFile,BufRead *.pod6^I^I^Isetf pod6
line 1433: 
line 1434: " Php, php3, php4, etc.
line 1435: " Also Phtml (was used for PHP 2 in the past)
line 1436: " Also .ctp for Cake template file
line 1437: au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp^Isetf php
line 1438: 
line 1439: " Pike
line 1440: au BufNewFile,BufRead *.pike,*.lpc,*.ulpc,*.pmod setf pike
line 1441: 
line 1442: " Pinfo config
line 1443: au BufNewFile,BufRead */etc/pinforc,*/.pinforc^Isetf pinfo
line 1444: 
line 1445: " Palm Resource compiler
line 1446: au BufNewFile,BufRead *.rcp^I^I^Isetf pilrc
line 1447: 
line 1448: " Pine config
line 1449: au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex^I^Isetf pine
line 1450: 
line 1451: " PL/1, PL/I
line 1452: au BufNewFile,BufRead *.pli,*.pl1^I^Isetf pli
line 1453: 
line 1454: " PL/M (also: *.inp)
line 1455: au BufNewFile,BufRead *.plm,*.p36,*.pac^I^Isetf plm
line 1456: 
line 1457: " PL/SQL
line 1458: au BufNewFile,BufRead *.pls,*.plsql^I^Isetf plsql
line 1459: 
line 1460: " PLP
line 1461: au BufNewFile,BufRead *.plp^I^I^Isetf plp
line 1462: 
line 1463: " PO and PO template (GNU gettext)
line 1464: au BufNewFile,BufRead *.po,*.pot^I^Isetf po
line 1465: 
line 1466: " Postfix main config
line 1467: au BufNewFile,BufRead main.cf^I^I^Isetf pfmain
line 1468: 
line 1469: " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
line 1470: au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai^I  setf postscr
line 1471: 
line 1472: " PostScript Printer Description
line 1473: au BufNewFile,BufRead *.ppd^I^I^Isetf ppd
line 1474: 
line 1475: " Povray
line 1476: au BufNewFile,BufRead *.pov^I^I^Isetf pov
line 1477: 
line 1478: " Povray configuration
line 1479: au BufNewFile,BufRead .povrayrc^I^I^Isetf povini
line 1480: 
line 1481: " Povray, PHP or assembly
line 1482: au BufNewFile,BufRead *.inc^I^I^Icall s:FTinc()
line 1483: 
line 1484: func! s:FTinc()
line 1505: 
line 1506: " Printcap and Termcap
line 1508: au BufNewFile,BufRead *printcap let b:ptcap_type = "print" | setf ptcap
line 1510: au BufNewFile,BufRead *termcap let b:ptcap_type = "term" | setf ptcap
line 1511: 
line 1512: " PCCTS / ANTRL
line 1513: "au BufNewFile,BufRead *.g^I^I^Isetf antrl
line 1514: au BufNewFile,BufRead *.g^I^I^Isetf pccts
line 1515: 
line 1516: " PPWizard
line 1517: au BufNewFile,BufRead *.it,*.ih^I^I^Isetf ppwiz
line 1518: 
line 1519: " Obj 3D file format
line 1520: " TODO: is there a way to avoid MS-Windows Object files?
line 1521: au BufNewFile,BufRead *.obj^I^I^Isetf obj
line 1522: 
line 1523: " Oracle Pro*C/C++
line 1524: au BufNewFile,BufRead *.pc^I^I^Isetf proc
line 1525: 
line 1526: " Privoxy actions file
line 1527: au BufNewFile,BufRead *.action^I^I^Isetf privoxy
line 1528: 
line 1529: " Procmail
line 1530: au BufNewFile,BufRead .procmail,.procmailrc^Isetf procmail
line 1531: 
line 1532: " Progress or CWEB
line 1533: au BufNewFile,BufRead *.w^I^I^Icall s:FTprogress_cweb()
line 1534: 
line 1535: func! s:FTprogress_cweb()
line 1546: 
line 1547: " Progress or assembly
line 1548: au BufNewFile,BufRead *.i^I^I^Icall s:FTprogress_asm()
line 1549: 
line 1550: func! s:FTprogress_asm()
line 1572: 
line 1573: " Progress or Pascal
line 1574: au BufNewFile,BufRead *.p^I^I^Icall s:FTprogress_pascal()
line 1575: 
line 1576: func! s:FTprogress_pascal()
line 1600: 
line 1601: 
line 1602: " Software Distributor Product Specification File (POSIX 1387.2-1995)
line 1603: au BufNewFile,BufRead *.psf^I^I^Isetf psf
line 1607: au BufNewFile,BufRead INDEX,INFO if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |   setf psf | endif
line 1608: 
line 1609: " Prolog
line 1610: au BufNewFile,BufRead *.pdb^I^I^Isetf prolog
line 1611: 
line 1612: " Promela
line 1613: au BufNewFile,BufRead *.pml^I^I^Isetf promela
line 1614: 
line 1615: " Google protocol buffers
line 1616: au BufNewFile,BufRead *.proto^I^I^Isetf proto
line 1617: 
line 1618: " Protocols
line 1619: au BufNewFile,BufRead */etc/protocols^I^Isetf protocols
line 1620: 
line 1621: " Pyrex
line 1622: au BufNewFile,BufRead *.pyx,*.pxd^I^Isetf pyrex
line 1623: 
line 1624: " Python
line 1625: au BufNewFile,BufRead *.py,*.pyw^I^Isetf python
line 1626: 
line 1627: " Quixote (Python-based web framework)
line 1628: au BufNewFile,BufRead *.ptl^I^I^Isetf python
line 1629: 
line 1630: " Radiance
line 1631: au BufNewFile,BufRead *.rad,*.mat^I^Isetf radiance
line 1632: 
line 1633: " Ratpoison config/command files
line 1634: au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc^Isetf ratpoison
line 1635: 
line 1636: " RCS file
line 1637: au BufNewFile,BufRead *\,v^I^I^Isetf rcs
line 1638: 
line 1639: " Readline
line 1640: au BufNewFile,BufRead .inputrc,inputrc^I^Isetf readline
line 1641: 
line 1642: " Registry for MS-Windows
line 1644: au BufNewFile,BufRead *.reg if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif
line 1645: 
line 1646: " Renderman Interface Bytestream
line 1647: au BufNewFile,BufRead *.rib^I^I^Isetf rib
line 1648: 
line 1649: " Rexx
line 1650: au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit^Isetf rexx
line 1651: 
line 1652: " R (Splus)
line 1653: if has("fname_case")
line 1654:   au BufNewFile,BufRead *.s,*.S^I^I^Isetf r
line 1655: else
line 1656:   au BufNewFile,BufRead *.s^I^I^Isetf r
line 1657: endif
line 1658: 
line 1659: " R Help file
line 1660: if has("fname_case")
line 1661:   au BufNewFile,BufRead *.rd,*.Rd^I^Isetf rhelp
line 1662: else
line 1663:   au BufNewFile,BufRead *.rd^I^I^Isetf rhelp
line 1664: endif
line 1665: 
line 1666: " R noweb file
line 1667: if has("fname_case")
line 1668:   au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw^I^Isetf rnoweb
line 1669: else
line 1670:   au BufNewFile,BufRead *.rnw,*.snw^I^I^Isetf rnoweb
line 1671: endif
line 1672: 
line 1673: " R Markdown file
line 1674: if has("fname_case")
line 1675:   au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd^I^Isetf rmd
line 1676: else
line 1677:   au BufNewFile,BufRead *.rmd,*.smd^I^I^Isetf rmd
line 1678: endif
line 1679: 
line 1680: " R reStructuredText file
line 1681: if has("fname_case")
line 1682:   au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst^Isetf rrst
line 1683: else
line 1684:   au BufNewFile,BufRead *.rrst,*.srst^I^I^Isetf rrst
line 1685: endif
line 1686: 
line 1687: " Rexx, Rebol or R
line 1688: au BufNewFile,BufRead *.r,*.R^I^I^Icall s:FTr()
line 1689: 
line 1690: func! s:FTr()
line 1722: 
line 1723: " Remind
line 1724: au BufNewFile,BufRead .reminders,*.remind,*.rem^I^Isetf remind
line 1725: 
line 1726: " Resolv.conf
line 1727: au BufNewFile,BufRead resolv.conf^I^Isetf resolv
line 1728: 
line 1729: " Relax NG Compact
line 1730: au BufNewFile,BufRead *.rnc^I^I^Isetf rnc
line 1731: 
line 1732: " Relax NG XML
line 1733: au BufNewFile,BufRead *.rng^I^I^Isetf rng
line 1734: 
line 1735: " RPL/2
line 1736: au BufNewFile,BufRead *.rpl^I^I^Isetf rpl
line 1737: 
line 1738: " Robots.txt
line 1739: au BufNewFile,BufRead robots.txt^I^Isetf robots
line 1740: 
line 1741: " Rpcgen
line 1742: au BufNewFile,BufRead *.x^I^I^Isetf rpcgen
line 1743: 
line 1744: " reStructuredText Documentation Format
line 1745: au BufNewFile,BufRead *.rst^I^I^Isetf rst
line 1746: 
line 1747: " RTF
line 1748: au BufNewFile,BufRead *.rtf^I^I^Isetf rtf
line 1749: 
line 1750: " Interactive Ruby shell
line 1751: au BufNewFile,BufRead .irbrc,irbrc^I^Isetf ruby
line 1752: 
line 1753: " Ruby
line 1754: au BufNewFile,BufRead *.rb,*.rbw^I^Isetf ruby
line 1755: 
line 1756: " RubyGems
line 1757: au BufNewFile,BufRead *.gemspec^I^I^Isetf ruby
line 1758: 
line 1759: " Rackup
line 1760: au BufNewFile,BufRead *.ru^I^I^Isetf ruby
line 1761: 
line 1762: " Bundler
line 1763: au BufNewFile,BufRead Gemfile^I^I^Isetf ruby
line 1764: 
line 1765: " Ruby on Rails
line 1766: au BufNewFile,BufRead *.builder,*.rxml,*.rjs^Isetf ruby
line 1767: 
line 1768: " Rantfile and Rakefile is like Ruby
line 1769: au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake^Isetf ruby
line 1770: 
line 1771: " S-lang (or shader language, or SmallLisp)
line 1772: au BufNewFile,BufRead *.sl^I^I^Isetf slang
line 1773: 
line 1774: " Samba config
line 1775: au BufNewFile,BufRead smb.conf^I^I^Isetf samba
line 1776: 
line 1777: " SAS script
line 1778: au BufNewFile,BufRead *.sas^I^I^Isetf sas
line 1779: 
line 1780: " Sass
line 1781: au BufNewFile,BufRead *.sass^I^I^Isetf sass
line 1782: 
line 1783: " Sather
line 1784: au BufNewFile,BufRead *.sa^I^I^Isetf sather
line 1785: 
line 1786: " Scilab
line 1787: au BufNewFile,BufRead *.sci,*.sce^I^Isetf scilab
line 1788: 
line 1789: " SCSS
line 1790: au BufNewFile,BufRead *.scss^I^I^Isetf scss
line 1791: 
line 1792: " SD: Streaming Descriptors
line 1793: au BufNewFile,BufRead *.sd^I^I^Isetf sd
line 1794: 
line 1795: " SDL
line 1796: au BufNewFile,BufRead *.sdl,*.pr^I^Isetf sdl
line 1797: 
line 1798: " sed
line 1799: au BufNewFile,BufRead *.sed^I^I^Isetf sed
line 1800: 
line 1801: " Sieve (RFC 3028)
line 1802: au BufNewFile,BufRead *.siv^I^I^Isetf sieve
line 1803: 
line 1804: " Sendmail
line 1805: au BufNewFile,BufRead sendmail.cf^I^Isetf sm
line 1806: 
line 1807: " Sendmail .mc files are actually m4.  Could also be MS Message text file.
line 1808: au BufNewFile,BufRead *.mc^I^I^Icall s:McSetf()
line 1809: 
line 1810: func! s:McSetf()
line 1825: 
line 1826: " Services
line 1827: au BufNewFile,BufRead */etc/services^I^Isetf services
line 1828: 
line 1829: " Service Location config
line 1830: au BufNewFile,BufRead */etc/slp.conf^I^Isetf slpconf
line 1831: 
line 1832: " Service Location registration
line 1833: au BufNewFile,BufRead */etc/slp.reg^I^Isetf slpreg
line 1834: 
line 1835: " Service Location SPI
line 1836: au BufNewFile,BufRead */etc/slp.spi^I^Isetf slpspi
line 1837: 
line 1838: " Setserial config
line 1839: au BufNewFile,BufRead */etc/serial.conf^I^Isetf setserial
line 1840: 
line 1841: " SGML
line 1851: au BufNewFile,BufRead *.sgm,*.sgml if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |   setf sgmllnx | elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |   let b:docbk_type = "sgml" |   let b:docbk_ver = 4 |   setf docbk | else |   setf sgml | endif
line 1852: 
line 1853: " SGMLDECL
line 1857: au BufNewFile,BufRead *.decl,*.dcl,*.dec if getline(1).getline(2).getline(3) =~? '^<!SGML' |    setf sgmldecl | endif
line 1858: 
line 1859: " SGML catalog file
line 1860: au BufNewFile,BufRead catalog^I^I^Isetf catalog
line 1861: au BufNewFile,BufRead sgml.catalog*^I^Icall s:StarSetf('catalog')
line 1862: 
line 1863: " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
line 1864: " Gentoo ebuilds are actually bash scripts
line 1865: au BufNewFile,BufRead .bashrc*,bashrc,bash.bashrc,.bash[_-]profile*,.bash[_-]logout*,.bash[_-]aliases*,*.bash,*/{,.}bash[_-]completion{,.d,.sh}{,/*},*.ebuild,*.eclass call SetFileTypeSH("bash")
line 1866: au BufNewFile,BufRead .kshrc*,*.ksh call SetFileTypeSH("ksh")
line 1867: au BufNewFile,BufRead */etc/profile,.profile*,*.sh,*.env call SetFileTypeSH(getline(1))
line 1868: 
line 1869: " Also called from scripts.vim.
line 1870: func! SetFileTypeSH(name)
line 1913: 
line 1914: " For shell-like file types, check for an "exec" command hidden in a comment,
line 1915: " as used for Tcl.
line 1916: " Also called from scripts.vim, thus can't be local to this script.
line 1917: func! SetFileTypeShell(name)
line 1936: 
line 1937: " tcsh scripts
line 1938: au BufNewFile,BufRead .tcshrc*,*.tcsh,tcsh.tcshrc,tcsh.login^Icall SetFileTypeShell("tcsh")
line 1939: 
line 1940: " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
line 1941: au BufNewFile,BufRead .login*,.cshrc*,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call s:CSH()
line 1942: 
line 1943: func! s:CSH()
line 1952: 
line 1953: " Z-Shell script
line 1954: au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
line 1955: au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
line 1956: au BufNewFile,BufRead *.zsh^I^I^Isetf zsh
line 1957: 
line 1958: " Scheme
line 1959: au BufNewFile,BufRead *.scm,*.ss,*.rkt^I^Isetf scheme
line 1960: 
line 1961: " Screen RC
line 1962: au BufNewFile,BufRead .screenrc,screenrc^Isetf screen
line 1963: 
line 1964: " Simula
line 1965: au BufNewFile,BufRead *.sim^I^I^Isetf simula
line 1966: 
line 1967: " SINDA
line 1968: au BufNewFile,BufRead *.sin,*.s85^I^Isetf sinda
line 1969: 
line 1970: " SiSU
line 1971: au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
line 1972: au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu
line 1973: 
line 1974: " SKILL
line 1975: au BufNewFile,BufRead *.il,*.ils,*.cdf^I^Isetf skill
line 1976: 
line 1977: " SLRN
line 1978: au BufNewFile,BufRead .slrnrc^I^I^Isetf slrnrc
line 1979: au BufNewFile,BufRead *.score^I^I^Isetf slrnsc
line 1980: 
line 1981: " Smalltalk (and TeX)
line 1982: au BufNewFile,BufRead *.st^I^I^Isetf st
line 1990: au BufNewFile,BufRead *.cls if getline(1) =~ '^%' |  setf tex | elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |  setf rexx | else |  setf st | endif
line 1991: 
line 1992: " Smarty templates
line 1993: au BufNewFile,BufRead *.tpl^I^I^Isetf smarty
line 1994: 
line 1995: " SMIL or XML
line 2001: au BufNewFile,BufRead *.smil if getline(1) =~ '<?\s*xml.*?>' |   setf xml | else |   setf smil | endif
line 2002: 
line 2003: " SMIL or SNMP MIB file
line 2009: au BufNewFile,BufRead *.smi if getline(1) =~ '\<smil\>' |   setf smil | else |   setf mib | endif
line 2010: 
line 2011: " SMITH
line 2012: au BufNewFile,BufRead *.smt,*.smith^I^Isetf smith
line 2013: 
line 2014: " Snobol4 and spitbol
line 2015: au BufNewFile,BufRead *.sno,*.spt^I^Isetf snobol4
line 2016: 
line 2017: " SNMP MIB files
line 2018: au BufNewFile,BufRead *.mib,*.my^I^Isetf mib
line 2019: 
line 2020: " Snort Configuration
line 2021: au BufNewFile,BufRead *.hog,snort.conf,vision.conf^Isetf hog
line 2022: au BufNewFile,BufRead *.rules^I^I^Icall s:FTRules()
line 2023: 
line 2024: let s:ft_rules_udev_rules_pattern = '^\s*\cudev_rules\s*=\s*"\([^"]\{-1,}\)/*".*'
line 2025: func! s:FTRules()
line 2057: 
line 2058: 
line 2059: " Spec (Linux RPM)
line 2060: au BufNewFile,BufRead *.spec^I^I^Isetf spec
line 2061: 
line 2062: " Speedup (AspenTech plant simulator)
line 2063: au BufNewFile,BufRead *.speedup,*.spdata,*.spd^Isetf spup
line 2064: 
line 2065: " Slice
line 2066: au BufNewFile,BufRead *.ice^I^I^Isetf slice
line 2067: 
line 2068: " Spice
line 2069: au BufNewFile,BufRead *.sp,*.spice^I^Isetf spice
line 2070: 
line 2071: " Spyce
line 2072: au BufNewFile,BufRead *.spy,*.spi^I^Isetf spyce
line 2073: 
line 2074: " Squid
line 2075: au BufNewFile,BufRead squid.conf^I^Isetf squid
line 2076: 
line 2077: " SQL for Oracle Designer
line 2078: au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks^Isetf sql
line 2079: 
line 2080: " SQL
line 2081: au BufNewFile,BufRead *.sql^I^I^Icall s:SQL()
line 2082: 
line 2083: func! s:SQL()
line 2090: 
line 2091: " SQLJ
line 2092: au BufNewFile,BufRead *.sqlj^I^I^Isetf sqlj
line 2093: 
line 2094: " SQR
line 2095: au BufNewFile,BufRead *.sqr,*.sqi^I^Isetf sqr
line 2096: 
line 2097: " OpenSSH configuration
line 2098: au BufNewFile,BufRead ssh_config,*/.ssh/config^Isetf sshconfig
line 2099: 
line 2100: " OpenSSH server configuration
line 2101: au BufNewFile,BufRead sshd_config^I^Isetf sshdconfig
line 2102: 
line 2103: " Stata
line 2104: au BufNewFile,BufRead *.ado,*.class,*.do,*.imata,*.mata   setf stata
line 2105: 
line 2106: " SMCL
line 2107: au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl^Isetf smcl
line 2108: 
line 2109: " Stored Procedures
line 2110: au BufNewFile,BufRead *.stp^I^I^Isetf stp
line 2111: 
line 2112: " Standard ML
line 2113: au BufNewFile,BufRead *.sml^I^I^Isetf sml
line 2114: 
line 2115: " Sratus VOS command macro
line 2116: au BufNewFile,BufRead *.cm^I^I^Isetf voscm
line 2117: 
line 2118: " Sysctl
line 2119: au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf^Isetf sysctl
line 2120: 
line 2121: " Systemd unit files
line 2122: au BufNewFile,BufRead */systemd/*.{automount,mount,path,service,socket,swap,target,timer}^Isetf systemd
line 2123: 
line 2124: " Synopsys Design Constraints
line 2125: au BufNewFile,BufRead *.sdc^I^I^Isetf sdc
line 2126: 
line 2127: " Sudoers
line 2128: au BufNewFile,BufRead */etc/sudoers,sudoers.tmp^Isetf sudoers
line 2129: 
line 2130: " SVG (Scalable Vector Graphics)
line 2131: au BufNewFile,BufRead *.svg^I^I^Isetf svg
line 2132: 
line 2133: " If the file has an extension of 't' and is in a directory 't' or 'xt' then
line 2134: " it is almost certainly a Perl test file.
line 2135: " If the first line starts with '#' and contains 'perl' it's probably a Perl
line 2136: " file.
line 2137: " (Slow test) If a file contains a 'use' statement then it is almost certainly
line 2138: " a Perl file.
line 2139: func! s:FTperl()
line 2155: 
line 2156: " Tads (or Nroff or Perl test file)
line 2158: au BufNewFile,BufRead *.t if !s:FTnroff() && !s:FTperl() | setf tads | endif
line 2159: 
line 2160: " Tags
line 2161: au BufNewFile,BufRead tags^I^I^Isetf tags
line 2162: 
line 2163: " TAK
line 2164: au BufNewFile,BufRead *.tak^I^I^Isetf tak
line 2165: 
line 2166: " Task
line 2167: au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
line 2168: au BufRead,BufNewFile *.task^I^I^Isetf taskedit
line 2169: 
line 2170: " Tcl (JACL too)
line 2171: au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl^Isetf tcl
line 2172: 
line 2173: " TealInfo
line 2174: au BufNewFile,BufRead *.tli^I^I^Isetf tli
line 2175: 
line 2176: " Telix Salt
line 2177: au BufNewFile,BufRead *.slt^I^I^Isetf tsalt
line 2178: 
line 2179: " Tera Term Language
line 2180: au BufRead,BufNewFile *.ttl^I^I^Isetf teraterm
line 2181: 
line 2182: " Terminfo
line 2183: au BufNewFile,BufRead *.ti^I^I^Isetf terminfo
line 2184: 
line 2185: " TeX
line 2186: au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl^Isetf tex
line 2187: au BufNewFile,BufRead *.tex^I^I^Icall s:FTtex()
line 2188: 
line 2189: " Choose context, plaintex, or tex (LaTeX) based on these rules:
line 2190: " 1. Check the first line of the file for "%&<format>".
line 2191: " 2. Check the first 1000 non-comment lines for LaTeX or ConTeXt keywords.
line 2192: " 3. Default to "latex" or to g:tex_flavor, can be set in user's vimrc.
line 2193: func! s:FTtex()
line 2240: 
line 2241: " ConTeXt
line 2242: au BufNewFile,BufRead tex/context/*/*.tex,*.mkii,*.mkiv   setf context
line 2243: 
line 2244: " Texinfo
line 2245: au BufNewFile,BufRead *.texinfo,*.texi,*.txi^Isetf texinfo
line 2246: 
line 2247: " TeX configuration
line 2248: au BufNewFile,BufRead texmf.cnf^I^I^Isetf texmf
line 2249: 
line 2250: " Tidy config
line 2251: au BufNewFile,BufRead .tidyrc,tidyrc^I^Isetf tidy
line 2252: 
line 2253: " TF mud client
line 2254: au BufNewFile,BufRead *.tf,.tfrc,tfrc^I^Isetf tf
line 2255: 
line 2256: " TPP - Text Presentation Program
line 2257: au BufNewFile,BufReadPost *.tpp^I^I^Isetf tpp
line 2258: 
line 2259: " Treetop
line 2260: au BufRead,BufNewFile *.treetop^I^I^Isetf treetop
line 2261: 
line 2262: " Trustees
line 2263: au BufNewFile,BufRead trustees.conf^I^Isetf trustees
line 2264: 
line 2265: " TSS - Geometry
line 2266: au BufNewFile,BufReadPost *.tssgm^I^Isetf tssgm
line 2267: 
line 2268: " TSS - Optics
line 2269: au BufNewFile,BufReadPost *.tssop^I^Isetf tssop
line 2270: 
line 2271: " TSS - Command Line (temporary)
line 2272: au BufNewFile,BufReadPost *.tsscl^I^Isetf tsscl
line 2273: 
line 2274: " TWIG files
line 2275: au BufNewFile,BufReadPost *.twig^I^Isetf twig
line 2276: 
line 2277: " Motif UIT/UIL files
line 2278: au BufNewFile,BufRead *.uit,*.uil^I^Isetf uil
line 2279: 
line 2280: " Udev conf
line 2281: au BufNewFile,BufRead */etc/udev/udev.conf^Isetf udevconf
line 2282: 
line 2283: " Udev permissions
line 2284: au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
line 2285: "
line 2286: " Udev symlinks config
line 2287: au BufNewFile,BufRead */etc/udev/cdsymlinks.conf^Isetf sh
line 2288: 
line 2289: " UnrealScript
line 2290: au BufNewFile,BufRead *.uc^I^I^Isetf uc
line 2291: 
line 2292: " Updatedb
line 2293: au BufNewFile,BufRead */etc/updatedb.conf^Isetf updatedb
line 2294: 
line 2295: " Upstart (init(8)) config files
line 2296: au BufNewFile,BufRead */usr/share/upstart/*.conf^I       setf upstart
line 2297: au BufNewFile,BufRead */usr/share/upstart/*.override^I       setf upstart
line 2298: au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
line 2299: au BufNewFile,BufRead */.init/*.conf,*/.init/*.override        setf upstart
line 2300: au BufNewFile,BufRead */.config/upstart/*.conf^I^I       setf upstart
line 2301: au BufNewFile,BufRead */.config/upstart/*.override^I       setf upstart
line 2302: 
line 2303: " Vera
line 2304: au BufNewFile,BufRead *.vr,*.vri,*.vrh^I^Isetf vera
line 2305: 
line 2306: " Verilog HDL
line 2307: au BufNewFile,BufRead *.v^I^I^Isetf verilog
line 2308: 
line 2309: " Verilog-AMS HDL
line 2310: au BufNewFile,BufRead *.va,*.vams^I^Isetf verilogams
line 2311: 
line 2312: " SystemVerilog
line 2313: au BufNewFile,BufRead *.sv,*.svh^I^Isetf systemverilog
line 2314: 
line 2315: " VHDL
line 2316: au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl
line 2317: au BufNewFile,BufRead *.vhdl_[0-9]*^I^Icall s:StarSetf('vhdl')
line 2318: 
line 2319: " Vim script
line 2320: au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc^Isetf vim
line 2321: 
line 2322: " Viminfo file
line 2323: au BufNewFile,BufRead .viminfo,_viminfo^I^Isetf viminfo
line 2324: 
line 2325: " Virata Config Script File or Drupal module
line 2331: au BufRead,BufNewFile *.hw,*.module,*.pkg if getline(1) =~ '<?php' |   setf php | else |   setf virata | endif
line 2332: 
line 2333: " Visual Basic (also uses *.bas) or FORM
line 2334: au BufNewFile,BufRead *.frm^I^I^Icall s:FTVB("form")
line 2335: 
line 2336: " SaxBasic is close to Visual Basic
line 2337: au BufNewFile,BufRead *.sba^I^I^Isetf vb
line 2338: 
line 2339: " Vgrindefs file
line 2340: au BufNewFile,BufRead vgrindefs^I^I^Isetf vgrindefs
line 2341: 
line 2342: " VRML V1.0c
line 2343: au BufNewFile,BufRead *.wrl^I^I^Isetf vrml
line 2344: 
line 2345: " Vroom (vim testing and executable documentation)
line 2346: au BufNewFile,BufRead *.vroom^I^I^Isetf vroom
line 2347: 
line 2348: " Webmacro
line 2349: au BufNewFile,BufRead *.wm^I^I^Isetf webmacro
line 2350: 
line 2351: " Wget config
line 2352: au BufNewFile,BufRead .wgetrc,wgetrc^I^Isetf wget
line 2353: 
line 2354: " Website MetaLanguage
line 2355: au BufNewFile,BufRead *.wml^I^I^Isetf wml
line 2356: 
line 2357: " Winbatch
line 2358: au BufNewFile,BufRead *.wbt^I^I^Isetf winbatch
line 2359: 
line 2360: " WSML
line 2361: au BufNewFile,BufRead *.wsml^I^I^Isetf wsml
line 2362: 
line 2363: " WvDial
line 2364: au BufNewFile,BufRead wvdial.conf,.wvdialrc^Isetf wvdial
line 2365: 
line 2366: " CVS RC file
line 2367: au BufNewFile,BufRead .cvsrc^I^I^Isetf cvsrc
line 2368: 
line 2369: " CVS commit file
line 2370: au BufNewFile,BufRead cvs\d\+^I^I^Isetf cvs
line 2371: 
line 2372: " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
line 2373: " lines in a WEB file).
line 2379: au BufNewFile,BufRead *.web if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |   setf web | else |   setf winbatch | endif
line 2380: 
line 2381: " Windows Scripting Host and Windows Script Component
line 2382: au BufNewFile,BufRead *.ws[fc]^I^I^Isetf wsh
line 2383: 
line 2384: " XHTML
line 2385: au BufNewFile,BufRead *.xhtml,*.xht^I^Isetf xhtml
line 2386: 
line 2387: " X Pixmap (dynamically sets colors, use BufEnter to make it work better)
line 2393: au BufEnter *.xpm if getline(1) =~ "XPM2" |   setf xpm2 | else |   setf xpm | endif
line 2394: au BufEnter *.xpm2^I^I^I^Isetf xpm2
line 2395: 
line 2396: " XFree86 config
line 2401: au BufNewFile,BufRead XF86Config if getline(1) =~ '\<XConfigurator\>' |   let b:xf86conf_xfree86_version = 3 | endif | setf xf86conf
line 2404: au BufNewFile,BufRead */xorg.conf.d/*.conf let b:xf86conf_xfree86_version = 4 | setf xf86conf
line 2405: 
line 2406: " Xorg config
line 2407: au BufNewFile,BufRead xorg.conf,xorg.conf-4^Ilet b:xf86conf_xfree86_version = 4 | setf xf86conf
line 2408: 
line 2409: " Xinetd conf
line 2410: au BufNewFile,BufRead */etc/xinetd.conf^I^Isetf xinetd
line 2411: 
line 2412: " XS Perl extension interface language
line 2413: au BufNewFile,BufRead *.xs^I^I^Isetf xs
line 2414: 
line 2415: " X resources file
line 2416: au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults
line 2417: 
line 2418: " Xmath
line 2419: au BufNewFile,BufRead *.msc,*.msf^I^Isetf xmath
line 2421: au BufNewFile,BufRead *.ms if !s:FTnroff() | setf xmath | endif
line 2422: 
line 2423: " XML  specific variants: docbk and xbl
line 2424: au BufNewFile,BufRead *.xml^I^I^Icall s:FTxml()
line 2425: 
line 2426: func! s:FTxml()
line 2451: 
line 2452: " XMI (holding UML models) is also XML
line 2453: au BufNewFile,BufRead *.xmi^I^I^Isetf xml
line 2454: 
line 2455: " CSPROJ files are Visual Studio.NET's XML-based project config files
line 2456: au BufNewFile,BufRead *.csproj,*.csproj.user^Isetf xml
line 2457: 
line 2458: " Qt Linguist translation source and Qt User Interface Files are XML
line 2459: au BufNewFile,BufRead *.ts,*.ui^I^I^Isetf xml
line 2460: 
line 2461: " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
line 2462: au BufNewFile,BufRead *.tpm^I^I^Isetf xml
line 2463: 
line 2464: " Xdg menus
line 2465: au BufNewFile,BufRead */etc/xdg/menus/*.menu^Isetf xml
line 2466: 
line 2467: " ATI graphics driver configuration
line 2468: au BufNewFile,BufRead fglrxrc^I^I^Isetf xml
line 2469: 
line 2470: " XLIFF (XML Localisation Interchange File Format) is also XML
line 2471: au BufNewFile,BufRead *.xlf^I^I^Isetf xml
line 2472: au BufNewFile,BufRead *.xliff^I^I^Isetf xml
line 2473: 
line 2474: " XML User Interface Language
line 2475: au BufNewFile,BufRead *.xul^I^I^Isetf xml
line 2476: 
line 2477: " X11 xmodmap (also see below)
line 2478: au BufNewFile,BufRead *Xmodmap^I^I^Isetf xmodmap
line 2479: 
line 2480: " Xquery
line 2481: au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy^Isetf xquery
line 2482: 
line 2483: " XSD
line 2484: au BufNewFile,BufRead *.xsd^I^I^Isetf xsd
line 2485: 
line 2486: " Xslt
line 2487: au BufNewFile,BufRead *.xsl,*.xslt^I^Isetf xslt
line 2488: 
line 2489: " Yacc
line 2490: au BufNewFile,BufRead *.yy,*.yxx,*.y++^I^Isetf yacc
line 2491: 
line 2492: " Yacc or racc
line 2493: au BufNewFile,BufRead *.y^I^I^Icall s:FTy()
line 2494: 
line 2495: func! s:FTy()
line 2511: 
line 2512: 
line 2513: " Yaml
line 2514: au BufNewFile,BufRead *.yaml,*.yml^I^Isetf yaml
line 2515: 
line 2516: " yum conf (close enough to dosini)
line 2517: au BufNewFile,BufRead */etc/yum.conf^I^Isetf dosini
line 2518: 
line 2519: " Zimbu
line 2520: au BufNewFile,BufRead *.zu^I^I^Isetf zimbu
line 2521: " Zimbu Templates
line 2522: au BufNewFile,BufRead *.zut^I^I^Isetf zimbutempl
line 2523: 
line 2524: " Zope
line 2525: "   dtml (zope dynamic template markup language), pt (zope page template),
line 2526: "   cpt (zope form controller page template)
line 2527: au BufNewFile,BufRead *.dtml,*.pt,*.cpt^I^Icall s:FThtml()
line 2528: "   zsql (zope sql method)
line 2529: au BufNewFile,BufRead *.zsql^I^I^Icall s:SQL()
line 2530: 
line 2531: " Z80 assembler asz80
line 2532: au BufNewFile,BufRead *.z8a^I^I^Isetf z8a
line 2533: 
line 2534: augroup END
line 2535: 
line 2536: 
line 2537: " Source the user-specified filetype file, for backwards compatibility with
line 2538: " Vim 5.x.
line 2539: if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
line 2540:   execute "source " . myfiletypefile
line 2541: endif
line 2542: 
line 2543: 
line 2544: " Check for "*" after loading myfiletypefile, so that scripts.vim is only used
line 2545: " when there are no matching file name extensions.
line 2546: " Don't do this for compressed files.
line 2547: augroup filetypedetect
line 2550: au BufNewFile,BufRead * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif
line 2551: au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif
line 2552: 
line 2553: 
line 2554: " Extra checks for when no filetype has been detected now.  Mostly used for
line 2555: " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
line 2556: " script file.
line 2557: " Most of these should call s:StarSetf() to avoid names ending in .gz and the
line 2558: " like are used.
line 2559: 
line 2560: " More Apache config files
line 2561: au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*^Icall s:StarSetf('apache')
line 2562: au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.d/*.conf*^I^Icall s:StarSetf('apache')
line 2563: 
line 2564: " Asterisk config file
line 2565: au BufNewFile,BufRead *asterisk/*.conf*^I^Icall s:StarSetf('asterisk')
line 2566: au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')
line 2567: 
line 2568: " Bazaar version control
line 2569: au BufNewFile,BufRead bzr_log.*^I^I^Isetf bzr
line 2570: 
line 2571: " BIND zone
line 2572: au BufNewFile,BufRead */named/db.*,*/bind/db.*^Icall s:StarSetf('bindzone')
line 2573: 
line 2574: " Calendar
line 2577: au BufNewFile,BufRead */.calendar/*,*/share/calendar/*/calendar.*,*/share/calendar/calendar.*^I^I^I^I^Icall s:StarSetf('calendar')
line 2578: 
line 2579: " Changelog
line 2585: au BufNewFile,BufRead [cC]hange[lL]og* if getline(1) =~ '; urgency='|  call s:StarSetf('debchangelog')|else|  call s:StarSetf('changelog')|endif
line 2586: 
line 2587: " Crontab
line 2588: au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*^I^Icall s:StarSetf('crontab')
line 2589: 
line 2590: " dnsmasq(8) configuration
line 2591: au BufNewFile,BufRead */etc/dnsmasq.d/*^I^Icall s:StarSetf('dnsmasq')
line 2592: 
line 2593: " Dracula
line 2594: au BufNewFile,BufRead drac.*^I^I^Icall s:StarSetf('dracula')
line 2595: 
line 2596: " Fvwm
line 2597: au BufNewFile,BufRead */.fvwm/*^I^I^Icall s:StarSetf('fvwm')
line 2599: au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook let b:fvwm_version = 1 | call s:StarSetf('fvwm')
line 2605: au BufNewFile,BufRead *fvwm2rc* if expand("<afile>:e") == "m4"|  call s:StarSetf('fvwm2m4')|else|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')|endif
line 2606: 
line 2607: " Gedcom
line 2608: au BufNewFile,BufRead */tmp/lltmp*^I^Icall s:StarSetf('gedcom')
line 2609: 
line 2610: " GTK RC
line 2611: au BufNewFile,BufRead .gtkrc*,gtkrc*^I^Icall s:StarSetf('gtkrc')
line 2612: 
line 2613: " Jam
line 2614: au BufNewFile,BufRead Prl*.*,JAM*.*^I^Icall s:StarSetf('jam')
line 2615: 
line 2616: " Jargon
line 2620: au! BufNewFile,BufRead *jarg* if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'|  call s:StarSetf('jargon')|endif
line 2621: 
line 2622: " Kconfig
line 2623: au BufNewFile,BufRead Kconfig.*^I^I^Icall s:StarSetf('kconfig')
line 2624: 
line 2625: " Lilo: Linux loader
line 2626: au BufNewFile,BufRead lilo.conf*^I^Icall s:StarSetf('lilo')
line 2627: 
line 2628: " Logcheck
line 2629: au BufNewFile,BufRead */etc/logcheck/*.d*/*^Icall s:StarSetf('logcheck')
line 2630: 
line 2631: " Makefile
line 2632: au BufNewFile,BufRead [mM]akefile*^I^Icall s:StarSetf('make')
line 2633: 
line 2634: " Ruby Makefile
line 2635: au BufNewFile,BufRead [rR]akefile*^I^Icall s:StarSetf('ruby')
line 2636: 
line 2637: " Mail (also matches muttrc.vim, so this is below the other checks)
line 2638: au BufNewFile,BufRead mutt[[:alnum:]._-]\\\{6\}^Isetf mail
line 2639: 
line 2640: " Modconf
line 2644: au BufNewFile,BufRead */etc/modutils/* if executable(expand("<afile>")) != 1|  call s:StarSetf('modconf')|endif
line 2645: au BufNewFile,BufRead */etc/modprobe.*^I^Icall s:StarSetf('modconf')
line 2646: 
line 2647: " Mutt setup file
line 2648: au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*^Icall s:StarSetf('muttrc')
line 2649: au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*^I^Icall s:StarSetf('muttrc')
line 2650: 
line 2651: " Nroff macros
line 2652: au BufNewFile,BufRead tmac.*^I^I^Icall s:StarSetf('nroff')
line 2653: 
line 2654: " Pam conf
line 2655: au BufNewFile,BufRead */etc/pam.d/*^I^Icall s:StarSetf('pamconf')
line 2656: 
line 2657: " Printcap and Termcap
line 2661: au BufNewFile,BufRead *printcap* if !did_filetype()|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')|endif
line 2665: au BufNewFile,BufRead *termcap* if !did_filetype()|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')|endif
line 2666: 
line 2667: " ReDIF
line 2668: " Only used when the .rdf file was not detected to be XML.
line 2669: au BufRead,BufNewFile *.rdf^I^I^Icall s:Redif()
line 2670: func! s:Redif()
line 2680: 
line 2681: " Remind
line 2682: au BufNewFile,BufRead .reminders*^I^Icall s:StarSetf('remind')
line 2683: 
line 2684: " Vim script
line 2685: au BufNewFile,BufRead *vimrc*^I^I^Icall s:StarSetf('vim')
line 2686: 
line 2687: " Subversion commit file
line 2688: au BufNewFile,BufRead svn-commit*.tmp^I^Isetf svn
line 2689: 
line 2690: " X resources file
line 2691: au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')
line 2692: 
line 2693: " XFree86 config
line 2695: au BufNewFile,BufRead XF86Config-4* let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
line 2700: au BufNewFile,BufRead XF86Config* if getline(1) =~ '\<XConfigurator\>'|  let b:xf86conf_xfree86_version = 3|endif|call s:StarSetf('xf86conf')
line 2701: 
line 2702: " X11 xmodmap
line 2703: au BufNewFile,BufRead *xmodmap*^I^I^Icall s:StarSetf('xmodmap')
line 2704: 
line 2705: " Xinetd conf
line 2706: au BufNewFile,BufRead */etc/xinetd.d/*^I^Icall s:StarSetf('xinetd')
line 2707: 
line 2708: " yum conf (close enough to dosini)
line 2709: au BufNewFile,BufRead */etc/yum.repos.d/*^Icall s:StarSetf('dosini')
line 2710: 
line 2711: " Z-Shell script
line 2712: au BufNewFile,BufRead zsh*,zlog*^I^Icall s:StarSetf('zsh')
line 2713: 
line 2714: 
line 2715: " Plain text files, needs to be far down to not override others.  This avoids
line 2716: " the "conf" type being used if there is a line starting with '#'.
line 2717: au BufNewFile,BufRead *.txt,*.text,README^Isetf text
line 2718: 
line 2719: 
line 2720: " Use the filetype detect plugins.  They may overrule any of the previously
line 2721: " detected filetypes.
line 2722: runtime! ftdetect/*.vim
Searching for "ftdetect/*.vim" in "/home/ollpu/.vim,/home/ollpu/.vim/bundle/fu,/home/ollpu/.vim/bundle/lightline.vim,/home/ollpu/.vim/bundle/molokai,/home/ollpu/.vim/bundle/vim-autoclose,/home/ollpu/.vim/bundle/vim-surround,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/ollpu/.vim/after"
Searching for "/home/ollpu/.vim/ftdetect/*.vim"
Searching for "/home/ollpu/.vim/bundle/fu/ftdetect/*.vim"
Searching for "/home/ollpu/.vim/bundle/lightline.vim/ftdetect/*.vim"
Searching for "/home/ollpu/.vim/bundle/molokai/ftdetect/*.vim"
Searching for "/home/ollpu/.vim/bundle/vim-autoclose/ftdetect/*.vim"
Searching for "/home/ollpu/.vim/bundle/vim-surround/ftdetect/*.vim"
Searching for "/var/lib/vim/addons/ftdetect/*.vim"
Searching for "/usr/share/vim/vimfiles/ftdetect/*.vim"
Searching for "/usr/share/vim/vim74/ftdetect/*.vim"
Searching for "/usr/share/vim/vimfiles/after/ftdetect/*.vim"
Searching for "/var/lib/vim/addons/after/ftdetect/*.vim"
Searching for "/home/ollpu/.vim/after/ftdetect/*.vim"
not found in 'runtimepath': "ftdetect/*.vim"
line 2723: 
line 2724: " NOTE: The above command could have ended the filetypedetect autocmd group
line 2725: " and started another one. Let's make sure it has ended to get to a consistent
line 2726: " state.
line 2727: augroup END
line 2728: 
line 2729: " Generic configuration file (check this last, it's just guessing!)
line 2735: au filetypedetect BufNewFile,BufRead,StdinReadPost * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'^I|| getline(4) =~ '^#' || getline(5) =~ '^#') |   setf conf | endif
line 2736: 
line 2737: 
line 2738: " If the GUI is already running, may still need to install the Syntax menu.
line 2739: " Don't do it when the 'M' flag is included in 'guioptions'.
line 2741: if has("menu") && has("gui_running") && !exists("did_install_syntax_menu") && &guioptions !~# "M"
line 2742:   source <sfile>:p:h/menu.vim
line 2743: endif
line 2744: 
line 2745: " Function called for testing all functions defined here.  These are
line 2746: " script-local, thus need to be executed here.
line 2747: " Returns a string with error messages (hopefully empty).
line 2748: func! TestFiletypeFuncs(testlist)
line 2759: 
line 2760: " Restore 'cpoptions'
line 2761: let &cpo = s:cpo_save
line 2762: unlet s:cpo_save
finished sourcing /usr/share/vim/vim74/filetype.vim
continuing in function pathogen#infect[14]..pathogen#cycle_filetype
Searching for "/usr/share/vim/vimfiles/after/filetype.vim"
Searching for "/var/lib/vim/addons/after/filetype.vim"
Searching for "/home/ollpu/.vim/after/filetype.vim"
line 4:   endif
function pathogen#infect[14]..pathogen#cycle_filetype returning #0

continuing in function pathogen#infect

line 15:   if pathogen#is_disabled($MYVIMRC)
calling function pathogen#infect[15]..pathogen#is_disabled('/home/ollpu/.vimrc')

line 1:   if a:path =~# '\~$'
line 2:     return 1
line 3:   endif
line 4:   let sep = pathogen#slash()
calling function pathogen#infect[15]..pathogen#is_disabled[4]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[15]..pathogen#is_disabled[4]..pathogen#slash returning '/'

continuing in function pathogen#infect[15]..pathogen#is_disabled

line 5:   let blacklist = get(g:, 'pathogen_blacklist', get(g:, 'pathogen_disabled', [])) + pathogen#split($VIMBLACKLIST)
calling function pathogen#infect[15]..pathogen#is_disabled[5]..pathogen#split('')

line 1:   if type(a:path) == type([]) | return a:path | endif
line 1:  return a:path | endif
line 1:  endif
line 2:   if empty(a:path) | return [] | endif
line 2:  return [] | endif
function pathogen#infect[15]..pathogen#is_disabled[5]..pathogen#split returning []

continuing in function pathogen#infect[15]..pathogen#is_disabled

line 8:   if !empty(blacklist)
line 9:     call map(blacklist, 'substitute(v:val, "[\\/]$", "", "")')
line 10:   endif
line 11:   return index(blacklist, fnamemodify(a:path, ':t')) != -1 || index(blacklist, a:path) != -1
function pathogen#infect[15]..pathogen#is_disabled returning #0

continuing in function pathogen#infect

line 16:     return 'finish'
line 17:   endif
line 18:   return ''
function pathogen#infect returning ''

continuing in /home/ollpu/.vimrc

line 3: 
line 4: 
line 5: let mapleader=","
line 6: 
line 7: set nocompatible
line 8: 
line 9: set number
line 10: 
line 11: set wildmenu
line 12: 
line 13: set splitbelow
line 14: set splitright
line 15: 
line 16: set ruler
line 17: set incsearch
line 18: 
line 19: set autoread
line 20: 
line 21: set showcmd
line 22: set laststatus=2
line 23: 
line 24: syntax enable
line 24: so $VIMRUNTIME/syntax/syntax.vim
chdir(/usr/share/vim/vim74/syntax)
fchdir() to previous dir
line 24: sourcing "/usr/share/vim/vim74/syntax/syntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 04
line 4: 
line 5: " This file is used for ":syntax on".
line 6: " It installs the autocommands and starts highlighting for all buffers.
line 7: 
line 8: if !has("syntax")
line 9:   finish
line 10: endif
line 11: 
line 12: " If Syntax highlighting appears to be on already, turn it off first, so that
line 13: " any leftovers are cleared.
line 14: if exists("syntax_on") || exists("syntax_manual")
line 15:   so <sfile>:p:h/nosyntax.vim
chdir(/usr/share/vim/vim74/syntax)
fchdir() to previous dir
line 15: sourcing "/usr/share/vim/vim74/syntax/nosyntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2006 Apr 16
line 4: 
line 5: " This file is used for ":syntax off".
line 6: " It removes the autocommands and stops highlighting for all buffers.
line 7: 
line 8: if !has("syntax")
line 9:   finish
line 10: endif
line 11: 
line 12: " Remove all autocommands for the Syntax event.  This also avoids that
line 13: " "syntax=foo" in a modeline triggers the SynSet() function of synload.vim.
line 14: au! Syntax
line 15: 
line 16: " remove all syntax autocommands and remove the syntax for each buffer
line 17: augroup syntaxset
line 18:   au!
line 19:   au BufEnter * syn clear
line 20:   au BufEnter * if exists("b:current_syntax") | unlet b:current_syntax | endif
line 21:   doautoall syntaxset BufEnter *
line 22:   au!
line 23: augroup END
line 24: 
line 25: if exists("syntax_on")
line 26:   unlet syntax_on
line 27: endif
line 28: if exists("syntax_manual")
line 29:   unlet syntax_manual
line 30: endif
finished sourcing /usr/share/vim/vim74/syntax/nosyntax.vim
continuing in /usr/share/vim/vim74/syntax/syntax.vim
line 16: endif
line 17: 
line 18: " Load the Syntax autocommands and set the default methods for highlighting.
line 19: runtime syntax/synload.vim
Searching for "syntax/synload.vim" in "/home/ollpu/.vim,/home/ollpu/.vim/bundle/fu,/home/ollpu/.vim/bundle/lightline.vim,/home/ollpu/.vim/bundle/molokai,/home/ollpu/.vim/bundle/vim-autoclose,/home/ollpu/.vim/bundle/vim-surround,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/ollpu/.vim/after"
Searching for "/home/ollpu/.vim/syntax/synload.vim"
Searching for "/home/ollpu/.vim/bundle/fu/syntax/synload.vim"
Searching for "/home/ollpu/.vim/bundle/lightline.vim/syntax/synload.vim"
Searching for "/home/ollpu/.vim/bundle/molokai/syntax/synload.vim"
Searching for "/home/ollpu/.vim/bundle/vim-autoclose/syntax/synload.vim"
Searching for "/home/ollpu/.vim/bundle/vim-surround/syntax/synload.vim"
Searching for "/var/lib/vim/addons/syntax/synload.vim"
Searching for "/usr/share/vim/vimfiles/syntax/synload.vim"
Searching for "/usr/share/vim/vim74/syntax/synload.vim"
chdir(/usr/share/vim/vim74/syntax)
fchdir() to previous dir
line 19: sourcing "/usr/share/vim/vim74/syntax/synload.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2012 Sep 25
line 4: 
line 5: " This file sets up for syntax highlighting.
line 6: " It is loaded from "syntax.vim" and "manual.vim".
line 7: " 1. Set the default highlight groups.
line 8: " 2. Install Syntax autocommands for all the available syntax files.
line 9: 
line 10: if !has("syntax")
line 11:   finish
line 12: endif
line 13: 
line 14: " let others know that syntax has been switched on
line 15: let syntax_on = 1
line 16: 
line 17: " Set the default highlighting colors.  Use a color scheme if specified.
line 18: if exists("colors_name")
line 19:   exe "colors " . colors_name
line 20: else
line 21:   runtime! syntax/syncolor.vim
Searching for "syntax/syncolor.vim" in "/home/ollpu/.vim,/home/ollpu/.vim/bundle/fu,/home/ollpu/.vim/bundle/lightline.vim,/home/ollpu/.vim/bundle/molokai,/home/ollpu/.vim/bundle/vim-autoclose,/home/ollpu/.vim/bundle/vim-surround,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/ollpu/.vim/after"
Searching for "/home/ollpu/.vim/syntax/syncolor.vim"
Searching for "/home/ollpu/.vim/bundle/fu/syntax/syncolor.vim"
Searching for "/home/ollpu/.vim/bundle/lightline.vim/syntax/syncolor.vim"
Searching for "/home/ollpu/.vim/bundle/molokai/syntax/syncolor.vim"
Searching for "/home/ollpu/.vim/bundle/vim-autoclose/syntax/syncolor.vim"
Searching for "/home/ollpu/.vim/bundle/vim-surround/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim74/syntax/syncolor.vim"
chdir(/usr/share/vim/vim74/syntax)
fchdir() to previous dir
line 21: sourcing "/usr/share/vim/vim74/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 44: hi def Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 45: hi def Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 46: hi def Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 47: hi def Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 48: hi def Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 49: hi def PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 50: hi def Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 51: hi def Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 52: hi def Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi def Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi def Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi def link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi def link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi def link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi def link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi def link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi def link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi def link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi def link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi def link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi def link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi def link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi def link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi def link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi def link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi def link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi def link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi def link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi def link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi def link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi def link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi def link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi def link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi def link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi def link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/share/vim/vim74/syntax/syncolor.vim
continuing in /usr/share/vim/vim74/syntax/synload.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/after/syntax/syncolor.vim"
Searching for "/home/ollpu/.vim/after/syntax/syncolor.vim"
line 22: endif
line 23: 
line 24: " Line continuation is used here, remove 'C' from 'cpoptions'
line 25: let s:cpo_save = &cpo
line 26: set cpo&vim
line 27: 
line 28: " First remove all old syntax autocommands.
line 29: au! Syntax
line 30: 
line 31: au Syntax *^I^Icall s:SynSet()
line 32: 
line 33: fun! s:SynSet()
line 61: 
line 62: 
line 63: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
line 68: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif
line 69: 
line 70: 
line 71: " Source the user-specified syntax highlighting file
line 72: if exists("mysyntaxfile") && filereadable(expand(mysyntaxfile))
line 73:   execute "source " . mysyntaxfile
line 74: endif
line 75: 
line 76: " Restore 'cpoptions'
line 77: let &cpo = s:cpo_save
line 78: unlet s:cpo_save
finished sourcing /usr/share/vim/vim74/syntax/synload.vim
continuing in /usr/share/vim/vim74/syntax/syntax.vim
line 20: 
line 21: " Load the FileType autocommands if not done yet.
line 22: if exists("did_load_filetypes")
line 23:   let s:did_ft = 1
line 24: else
line 25:   filetype on
line 26:   let s:did_ft = 0
line 27: endif
line 28: 
line 29: " Set up the connection between FileType and Syntax autocommands.
line 30: " This makes the syntax automatically set when the file type is detected.
line 31: augroup syntaxset
line 32:   au! FileType *^Iexe "set syntax=" . expand("<amatch>")
line 33: augroup END
line 34: 
line 35: 
line 36: " Execute the syntax autocommands for the each buffer.
line 37: " If the filetype wasn't detected yet, do that now.
line 38: " Always do the syntaxset autocommands, for buffers where the 'filetype'
line 39: " already was set manually (e.g., help buffers).
line 40: doautoall syntaxset FileType
line 41: if !s:did_ft
line 42:   doautoall filetypedetect BufRead
line 43: endif
finished sourcing /usr/share/vim/vim74/syntax/syntax.vim
continuing in /home/ollpu/.vimrc
line 25: set encoding=utf8
line 26: 
line 27: set smarttab
line 28: set expandtab
line 29: set softtabstop=2
line 30: set shiftwidth=2
line 31: set tabstop=2
line 32: set ai
line 33: set si
line 34: autocmd FileType python setlocal softtabstop=4 shiftwidth=4 ts=4 cinwords=if,elif,else,for,while,try,except,finally,def,class
line 35: 
line 36: set colorcolumn=81
line 37: set cursorline
line 38: 
line 39: " Delete trailing white space on save, useful for Python and CoffeeScript ;)
line 40: func! DeleteTrailingWS()
line 45: autocmd BufWrite *.py :call DeleteTrailingWS()
line 46: autocmd BufWrite *.coffee :call DeleteTrailingWS()
line 47: 
line 48: colorscheme molokai
Searching for "colors/molokai.vim" in "/home/ollpu/.vim,/home/ollpu/.vim/bundle/fu,/home/ollpu/.vim/bundle/lightline.vim,/home/ollpu/.vim/bundle/molokai,/home/ollpu/.vim/bundle/vim-autoclose,/home/ollpu/.vim/bundle/vim-surround,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/ollpu/.vim/after"
Searching for "/home/ollpu/.vim/colors/molokai.vim"
chdir(/home/ollpu/.vim/colors)
fchdir() to previous dir
line 48: sourcing "/home/ollpu/.vim/colors/molokai.vim"
line 1: " Vim color file
line 2: "
line 3: " Author: Tomas Restrepo <tomas@winterdom.com>
line 4: " https://github.com/tomasr/molokai
line 5: "
line 6: " Note: Based on the Monokai theme for TextMate
line 7: " by Wimer Hazenberg and its darker variant
line 8: " by Hamish Stuart Macpherson
line 9: "
line 10: 
line 11: hi clear
Searching for "syntax/syncolor.vim" in "/home/ollpu/.vim,/home/ollpu/.vim/bundle/fu,/home/ollpu/.vim/bundle/lightline.vim,/home/ollpu/.vim/bundle/molokai,/home/ollpu/.vim/bundle/vim-autoclose,/home/ollpu/.vim/bundle/vim-surround,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/ollpu/.vim/after"
Searching for "/home/ollpu/.vim/syntax/syncolor.vim"
Searching for "/home/ollpu/.vim/bundle/fu/syntax/syncolor.vim"
Searching for "/home/ollpu/.vim/bundle/lightline.vim/syntax/syncolor.vim"
Searching for "/home/ollpu/.vim/bundle/molokai/syntax/syncolor.vim"
Searching for "/home/ollpu/.vim/bundle/vim-autoclose/syntax/syncolor.vim"
Searching for "/home/ollpu/.vim/bundle/vim-surround/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim74/syntax/syncolor.vim"
chdir(/usr/share/vim/vim74/syntax)
fchdir() to previous dir
line 11: sourcing "/usr/share/vim/vim74/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 44: hi Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 45: hi Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 46: hi Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 47: hi Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 48: hi Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 49: hi PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 50: hi Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 51: hi Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 52: hi Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/share/vim/vim74/syntax/syncolor.vim
continuing in /home/ollpu/.vim/colors/molokai.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/after/syntax/syncolor.vim"
Searching for "/home/ollpu/.vim/after/syntax/syncolor.vim"
line 12: 
line 13: if version > 580
line 14:     " no guarantees for version 5.8 and below, but this makes it stop
line 15:     " complaining
line 16:     hi clear
Searching for "syntax/syncolor.vim" in "/home/ollpu/.vim,/home/ollpu/.vim/bundle/fu,/home/ollpu/.vim/bundle/lightline.vim,/home/ollpu/.vim/bundle/molokai,/home/ollpu/.vim/bundle/vim-autoclose,/home/ollpu/.vim/bundle/vim-surround,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/ollpu/.vim/after"
Searching for "/home/ollpu/.vim/syntax/syncolor.vim"
Searching for "/home/ollpu/.vim/bundle/fu/syntax/syncolor.vim"
Searching for "/home/ollpu/.vim/bundle/lightline.vim/syntax/syncolor.vim"
Searching for "/home/ollpu/.vim/bundle/molokai/syntax/syncolor.vim"
Searching for "/home/ollpu/.vim/bundle/vim-autoclose/syntax/syncolor.vim"
Searching for "/home/ollpu/.vim/bundle/vim-surround/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim74/syntax/syncolor.vim"
chdir(/usr/share/vim/vim74/syntax)
fchdir() to previous dir
line 16: sourcing "/usr/share/vim/vim74/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 44: hi Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 45: hi Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 46: hi Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 47: hi Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 48: hi Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 49: hi PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 50: hi Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 51: hi Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 52: hi Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/share/vim/vim74/syntax/syncolor.vim
continuing in /home/ollpu/.vim/colors/molokai.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/after/syntax/syncolor.vim"
Searching for "/home/ollpu/.vim/after/syntax/syncolor.vim"
line 17:     if exists("syntax_on")
line 18:         syntax reset
line 18: runtime! syntax/syncolor.vim
Searching for "syntax/syncolor.vim" in "/home/ollpu/.vim,/home/ollpu/.vim/bundle/fu,/home/ollpu/.vim/bundle/lightline.vim,/home/ollpu/.vim/bundle/molokai,/home/ollpu/.vim/bundle/vim-autoclose,/home/ollpu/.vim/bundle/vim-surround,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/ollpu/.vim/after"
Searching for "/home/ollpu/.vim/syntax/syncolor.vim"
Searching for "/home/ollpu/.vim/bundle/fu/syntax/syncolor.vim"
Searching for "/home/ollpu/.vim/bundle/lightline.vim/syntax/syncolor.vim"
Searching for "/home/ollpu/.vim/bundle/molokai/syntax/syncolor.vim"
Searching for "/home/ollpu/.vim/bundle/vim-autoclose/syntax/syncolor.vim"
Searching for "/home/ollpu/.vim/bundle/vim-surround/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/syntax/syncolor.vim"
Searching for "/usr/share/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/share/vim/vim74/syntax/syncolor.vim"
chdir(/usr/share/vim/vim74/syntax)
fchdir() to previous dir
line 18: sourcing "/usr/share/vim/vim74/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 44: hi Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 45: hi Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 46: hi Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 47: hi Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 48: hi Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 49: hi PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 50: hi Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 51: hi Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 52: hi Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi! link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi! link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi! link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi! link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi! link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi! link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi! link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi! link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi! link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi! link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi! link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi! link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi! link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi! link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi! link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi! link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi! link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi! link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi! link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi! link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi! link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi! link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi! link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi! link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/share/vim/vim74/syntax/syncolor.vim
continuing in /home/ollpu/.vim/colors/molokai.vim
Searching for "/usr/share/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/var/lib/vim/addons/after/syntax/syncolor.vim"
Searching for "/home/ollpu/.vim/after/syntax/syncolor.vim"
line 19:     endif
line 20: endif
line 21: let g:colors_name="molokai"
line 22: 
line 23: if exists("g:molokai_original")
line 24:     let s:molokai_original = g:molokai_original
line 25: else
line 26:     let s:molokai_original = 0
line 27: endif
line 28: 
line 29: 
line 30: hi Boolean         guifg=#AE81FF
line 31: hi Character       guifg=#E6DB74
line 32: hi Number          guifg=#AE81FF
line 33: hi String          guifg=#E6DB74
line 34: hi Conditional     guifg=#F92672               gui=bold
line 35: hi Constant        guifg=#AE81FF               gui=bold
line 36: hi Cursor          guifg=#000000 guibg=#F8F8F0
line 37: hi iCursor         guifg=#000000 guibg=#F8F8F0
line 38: hi Debug           guifg=#BCA3A3               gui=bold
line 39: hi Define          guifg=#66D9EF
line 40: hi Delimiter       guifg=#8F8F8F
line 41: hi DiffAdd                       guibg=#13354A
line 42: hi DiffChange      guifg=#89807D guibg=#4C4745
line 43: hi DiffDelete      guifg=#960050 guibg=#1E0010
line 44: hi DiffText                      guibg=#4C4745 gui=italic,bold
line 45: 
line 46: hi Directory       guifg=#A6E22E               gui=bold
line 47: hi Error           guifg=#E6DB74 guibg=#1E0010
line 48: hi ErrorMsg        guifg=#F92672 guibg=#232526 gui=bold
line 49: hi Exception       guifg=#A6E22E               gui=bold
line 50: hi Float           guifg=#AE81FF
line 51: hi FoldColumn      guifg=#465457 guibg=#000000
line 52: hi Folded          guifg=#465457 guibg=#000000
line 53: hi Function        guifg=#A6E22E
line 54: hi Identifier      guifg=#FD971F
line 55: hi Ignore          guifg=#808080 guibg=bg
line 56: hi IncSearch       guifg=#C4BE89 guibg=#000000
line 57: 
line 58: hi Keyword         guifg=#F92672               gui=bold
line 59: hi Label           guifg=#E6DB74               gui=none
line 60: hi Macro           guifg=#C4BE89               gui=italic
line 61: hi SpecialKey      guifg=#66D9EF               gui=italic
line 62: 
line 63: hi MatchParen      guifg=#000000 guibg=#FD971F gui=bold
line 64: hi ModeMsg         guifg=#E6DB74
line 65: hi MoreMsg         guifg=#E6DB74
line 66: hi Operator        guifg=#F92672
line 67: 
line 68: " complete menu
line 69: hi Pmenu           guifg=#66D9EF guibg=#000000
line 70: hi PmenuSel                      guibg=#808080
line 71: hi PmenuSbar                     guibg=#080808
line 72: hi PmenuThumb      guifg=#66D9EF
line 73: 
line 74: hi PreCondit       guifg=#A6E22E               gui=bold
line 75: hi PreProc         guifg=#A6E22E
line 76: hi Question        guifg=#66D9EF
line 77: hi Repeat          guifg=#F92672               gui=bold
line 78: hi Search          guifg=#000000 guibg=#FFE792
line 79: " marks
line 80: hi SignColumn      guifg=#A6E22E guibg=#232526
line 81: hi SpecialChar     guifg=#F92672               gui=bold
line 82: hi SpecialComment  guifg=#7E8E91               gui=bold
line 83: hi Special         guifg=#66D9EF guibg=bg      gui=italic
line 84: if has("spell")
line 85:     hi SpellBad    guisp=#FF0000 gui=undercurl
line 86:     hi SpellCap    guisp=#7070F0 gui=undercurl
line 87:     hi SpellLocal  guisp=#70F0F0 gui=undercurl
line 88:     hi SpellRare   guisp=#FFFFFF gui=undercurl
line 89: endif
line 90: hi Statement       guifg=#F92672               gui=bold
line 91: hi StatusLine      guifg=#455354 guibg=fg
line 92: hi StatusLineNC    guifg=#808080 guibg=#080808
line 93: hi StorageClass    guifg=#FD971F               gui=italic
line 94: hi Structure       guifg=#66D9EF
line 95: hi Tag             guifg=#F92672               gui=italic
line 96: hi Title           guifg=#ef5939
line 97: hi Todo            guifg=#FFFFFF guibg=bg      gui=bold
line 98: 
line 99: hi Typedef         guifg=#66D9EF
line 100: hi Type            guifg=#66D9EF               gui=none
line 101: hi Underlined      guifg=#808080               gui=underline
line 102: 
line 103: hi VertSplit       guifg=#808080 guibg=#080808 gui=bold
line 104: hi VisualNOS                     guibg=#403D3D
line 105: hi Visual                        guibg=#403D3D
line 106: hi WarningMsg      guifg=#FFFFFF guibg=#333333 gui=bold
line 107: hi WildMenu        guifg=#66D9EF guibg=#000000
line 108: 
line 109: hi TabLineFill     guifg=#1B1D1E guibg=#1B1D1E
line 110: hi TabLine         guibg=#1B1D1E guifg=#808080 gui=none
line 111: 
line 112: if s:molokai_original == 1
line 113:    hi Normal          guifg=#F8F8F2 guibg=#272822
line 114:    hi Comment         guifg=#75715E
line 115:    hi CursorLine                    guibg=#3E3D32
line 116:    hi CursorLineNr    guifg=#FD971F               gui=none
line 117:    hi CursorColumn                  guibg=#3E3D32
line 118:    hi ColorColumn                   guibg=#3B3A32
line 119:    hi LineNr          guifg=#BCBCBC guibg=#3B3A32
line 120:    hi NonText         guifg=#75715E
line 121:    hi SpecialKey      guifg=#75715E
line 122: else
line 123:    hi Normal          guifg=#F8F8F2 guibg=#1B1D1E
line 124:    hi Comment         guifg=#7E8E91
line 125:    hi CursorLine                    guibg=#293739
line 126:    hi CursorLineNr    guifg=#FD971F               gui=none
line 127:    hi CursorColumn                  guibg=#293739
line 128:    hi ColorColumn                   guibg=#232526
line 129:    hi LineNr          guifg=#465457 guibg=#232526
line 130:    hi NonText         guifg=#465457
line 131:    hi SpecialKey      guifg=#465457
line 132: end
line 133: 
line 134: "
line 135: " Support for 256-color terminal
line 136: "
line 137: if &t_Co > 255
line 138:    if s:molokai_original == 1
line 139:       hi Normal                   ctermbg=234
line 140:       hi CursorLine               ctermbg=235   cterm=none
line 141:       hi CursorLineNr ctermfg=208               cterm=none
line 142:    else
line 143:       hi Normal       ctermfg=252 ctermbg=233
line 144:       hi CursorLine               ctermbg=234   cterm=none
line 145:       hi CursorLineNr ctermfg=208               cterm=none
line 146:    endif
line 147:    hi Boolean         ctermfg=135
line 148:    hi Character       ctermfg=144
line 149:    hi Number          ctermfg=135
line 150:    hi String          ctermfg=144
line 151:    hi Conditional     ctermfg=161               cterm=bold
line 152:    hi Constant        ctermfg=135               cterm=bold
line 153:    hi Cursor          ctermfg=16  ctermbg=253
line 154:    hi Debug           ctermfg=225               cterm=bold
line 155:    hi Define          ctermfg=81
line 156:    hi Delimiter       ctermfg=241
line 157: 
line 158:    hi DiffAdd                     ctermbg=24
line 159:    hi DiffChange      ctermfg=181 ctermbg=239
line 160:    hi DiffDelete      ctermfg=162 ctermbg=53
line 161:    hi DiffText                    ctermbg=102 cterm=bold
line 162: 
line 163:    hi Directory       ctermfg=118               cterm=bold
line 164:    hi Error           ctermfg=219 ctermbg=89
line 165:    hi ErrorMsg        ctermfg=199 ctermbg=16    cterm=bold
line 166:    hi Exception       ctermfg=118               cterm=bold
line 167:    hi Float           ctermfg=135
line 168:    hi FoldColumn      ctermfg=67  ctermbg=16
line 169:    hi Folded          ctermfg=67  ctermbg=16
line 170:    hi Function        ctermfg=118
line 171:    hi Identifier      ctermfg=208               cterm=none
line 172:    hi Ignore          ctermfg=244 ctermbg=232
line 173:    hi IncSearch       ctermfg=193 ctermbg=16
line 174: 
line 175:    hi keyword         ctermfg=161               cterm=bold
line 176:    hi Label           ctermfg=229               cterm=none
line 177:    hi Macro           ctermfg=193
line 178:    hi SpecialKey      ctermfg=81
line 179: 
line 180:    hi MatchParen      ctermfg=233  ctermbg=208 cterm=bold
line 181:    hi ModeMsg         ctermfg=229
line 182:    hi MoreMsg         ctermfg=229
line 183:    hi Operator        ctermfg=161
line 184: 
line 185:    " complete menu
line 186:    hi Pmenu           ctermfg=81  ctermbg=16
line 187:    hi PmenuSel        ctermfg=255 ctermbg=242
line 188:    hi PmenuSbar                   ctermbg=232
line 189:    hi PmenuThumb      ctermfg=81
line 190: 
line 191:    hi PreCondit       ctermfg=118               cterm=bold
line 192:    hi PreProc         ctermfg=118
line 193:    hi Question        ctermfg=81
line 194:    hi Repeat          ctermfg=161               cterm=bold
line 195:    hi Search          ctermfg=0   ctermbg=222   cterm=NONE
line 196: 
line 197:    " marks column
line 198:    hi SignColumn      ctermfg=118 ctermbg=235
line 199:    hi SpecialChar     ctermfg=161               cterm=bold
line 200:    hi SpecialComment  ctermfg=245               cterm=bold
line 201:    hi Special         ctermfg=81
line 202:    if has("spell")
line 203:        hi SpellBad                ctermbg=52
line 204:        hi SpellCap                ctermbg=17
line 205:        hi SpellLocal              ctermbg=17
line 206:        hi SpellRare  ctermfg=none ctermbg=none  cterm=reverse
line 207:    endif
line 208:    hi Statement       ctermfg=161               cterm=bold
line 209:    hi StatusLine      ctermfg=238 ctermbg=253
line 210:    hi StatusLineNC    ctermfg=244 ctermbg=232
line 211:    hi StorageClass    ctermfg=208
line 212:    hi Structure       ctermfg=81
line 213:    hi Tag             ctermfg=161
line 214:    hi Title           ctermfg=166
line 215:    hi Todo            ctermfg=231 ctermbg=232   cterm=bold
line 216: 
line 217:    hi Typedef         ctermfg=81
line 218:    hi Type            ctermfg=81                cterm=none
line 219:    hi Underlined      ctermfg=244               cterm=underline
line 220: 
line 221:    hi VertSplit       ctermfg=244 ctermbg=232   cterm=bold
line 222:    hi VisualNOS                   ctermbg=238
line 223:    hi Visual                      ctermbg=235
line 224:    hi WarningMsg      ctermfg=231 ctermbg=238   cterm=bold
line 225:    hi WildMenu        ctermfg=81  ctermbg=16
line 226: 
line 227:    hi Comment         ctermfg=59
line 228:    hi CursorColumn                ctermbg=236
line 229:    hi ColorColumn                 ctermbg=236
line 230:    hi LineNr          ctermfg=250 ctermbg=236
line 231:    hi NonText         ctermfg=59
line 232: 
line 233:    hi SpecialKey      ctermfg=59
line 234: 
line 235:    if exists("g:rehash256") && g:rehash256 == 1
line 236:        hi Normal       ctermfg=252 ctermbg=234
line 237:        hi CursorLine               ctermbg=236   cterm=none
line 238:        hi CursorLineNr ctermfg=208               cterm=none
line 239: 
line 240:        hi Boolean         ctermfg=141
line 241:        hi Character       ctermfg=222
line 242:        hi Number          ctermfg=141
line 243:        hi String          ctermfg=222
line 244:        hi Conditional     ctermfg=197               cterm=bold
line 245:        hi Constant        ctermfg=141               cterm=bold
line 246: 
line 247:        hi DiffDelete      ctermfg=125 ctermbg=233
line 248: 
line 249:        hi Directory       ctermfg=154               cterm=bold
line 250:        hi Error           ctermfg=222 ctermbg=233
line 251:        hi Exception       ctermfg=154               cterm=bold
line 252:        hi Float           ctermfg=141
line 253:        hi Function        ctermfg=154
line 254:        hi Identifier      ctermfg=208
line 255: 
line 256:        hi Keyword         ctermfg=197               cterm=bold
line 257:        hi Operator        ctermfg=197
line 258:        hi PreCondit       ctermfg=154               cterm=bold
line 259:        hi PreProc         ctermfg=154
line 260:        hi Repeat          ctermfg=197               cterm=bold
line 261: 
line 262:        hi Statement       ctermfg=197               cterm=bold
line 263:        hi Tag             ctermfg=197
line 264:        hi Title           ctermfg=203
line 265:        hi Visual                      ctermbg=238
line 266: 
line 267:        hi Comment         ctermfg=244
line 268:        hi LineNr          ctermfg=239 ctermbg=235
line 269:        hi NonText         ctermfg=239
line 270:        hi SpecialKey      ctermfg=239
line 271:    endif
line 272: end
line 273: 
line 274: " Must be at the end, because of ctermbg=234 bug.
line 275: " https://groups.google.com/forum/#!msg/vim_dev/afPqwAFNdrU/nqh6tOM87QUJ
line 276: set background=dark
finished sourcing /home/ollpu/.vim/colors/molokai.vim
continuing in /home/ollpu/.vimrc
line 49: set t_ut=
line 50: " highlight Normal ctermbg=none
line 51: highlight ColorColumn ctermbg=234
line 52: highlight CursorLine ctermbg=none cterm=none
line 53: highlight MatchParen ctermbg=232 ctermfg=208
line 54: 
line 55: inoremap <CR> <CR>x<BS>
line 56: nnoremap o ox<BS>
line 57: nnoremap O Ox<BS>
line 58: 
line 59: inoremap ¤ <Esc>
line 60: inoremap <S-Tab> <Esc><<i
line 61: inoremap <C-Tab> <Esc>>>i
line 62: 
line 63: inoremap {<CR> {<CR>}<Esc>Ox<BS>
finished sourcing $HOME/.vimrc
Searching for "plugin/**/*.vim" in "/home/ollpu/.vim,/home/ollpu/.vim/bundle/fu,/home/ollpu/.vim/bundle/lightline.vim,/home/ollpu/.vim/bundle/molokai,/home/ollpu/.vim/bundle/vim-autoclose,/home/ollpu/.vim/bundle/vim-surround,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/ollpu/.vim/after"
Searching for "/home/ollpu/.vim/plugin/**/*.vim"
Searching for "/home/ollpu/.vim/bundle/fu/plugin/**/*.vim"
Searching for "/home/ollpu/.vim/bundle/lightline.vim/plugin/**/*.vim"
chdir(/home/ollpu/.vim/bundle/lightline.vim/plugin)
fchdir() to previous dir
sourcing "/home/ollpu/.vim/bundle/lightline.vim/plugin/lightline.vim"
line 1: " =============================================================================
line 2: " Filename: plugin/lightline.vim
line 3: " Author: itchyny
line 4: " License: MIT License
line 5: " Last Change: 2016/03/14 03:31:58.
line 6: " =============================================================================
line 7: 
line 8: if exists('g:loaded_lightline') || v:version < 700
line 9:   finish
line 10: endif
line 11: let g:loaded_lightline = 1
line 12: 
line 13: let s:save_cpo = &cpo
line 14: set cpo&vim
line 15: 
line 16: augroup lightline
line 17:   autocmd!
line 18:   autocmd WinEnter,BufWinEnter,FileType,ColorScheme,SessionLoadPost * call lightline#update()
line 19:   autocmd ColorScheme,SessionLoadPost * call lightline#highlight()
line 20:   autocmd CursorMoved,BufUnload * call lightline#update_once()
line 21: augroup END
line 22: 
line 23: let &cpo = s:save_cpo
line 24: unlet s:save_cpo
finished sourcing /home/ollpu/.vim/bundle/lightline.vim/plugin/lightline.vim
Searching for "/home/ollpu/.vim/bundle/molokai/plugin/**/*.vim"
Searching for "/home/ollpu/.vim/bundle/vim-autoclose/plugin/**/*.vim"
chdir(/home/ollpu/.vim/bundle/vim-autoclose/plugin)
fchdir() to previous dir
sourcing "/home/ollpu/.vim/bundle/vim-autoclose/plugin/AutoClose.vim"
line 1: scriptencoding utf-8
line 2: """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
line 3: " AutoClose.vim - Automatically close pair of characters: ( with ), [ with ], { with }, etc.
line 4: " Version: 2.0
line 5: " Author: Thiago Alves <talk@thiagoalves.com.br>
line 6: " Maintainer: Thiago Alves <talk@thiagoalves.com.br>
line 7: " URL: http://thiagoalves.com.br
line 8: " Licence: This script is released under the Vim License.
line 9: " Last modified: 02/02/2011
line 10: """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
line 11: 
line 12: " check if script is already loaded
line 13: if !exists("g:debug_AutoClose") && exists("g:loaded_AutoClose")
line 14:     finish "stop loading the script"
line 15: endif
line 16: let g:loaded_AutoClose = 1
line 17: 
line 18: let s:global_cpo = &cpo " store compatible-mode in local variable
line 19: set cpo&vim             " go into nocompatible-mode
line 20: 
line 21: if !exists('g:AutoClosePreserveDotReg')
line 22:     let g:AutoClosePreserveDotReg = 1
line 23: endif
line 24: 
line 25: if g:AutoClosePreserveDotReg
line 26:     " Because dot register preservation code remaps escape we have to remap
line 27:     " some terminal specific escape sequences first
line 28:     if &term =~ 'xterm' || &term =~ 'rxvt' || &term =~ 'screen' || &term =~ 'linux' || &term =~ 'gnome'
line 29:         imap <silent> <Esc>OA <Up>
line 30:         imap <silent> <Esc>OB <Down>
line 31:         imap <silent> <Esc>OC <Right>
line 32:         imap <silent> <Esc>OD <Left>
line 33:         imap <silent> <Esc>OH <Home>
line 34:         imap <silent> <Esc>OF <End>
line 35:         imap <silent> <Esc>[5~ <PageUp>
line 36:         imap <silent> <Esc>[6~ <PageDown>
line 37:     endif
line 38: endif
line 39: 
line 40: """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
line 41: " Functions
line 42: """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
line 43: function! s:GetCharAhead(len)
line 49: 
line 50: function! s:GetCharBehind(len)
line 56: 
line 57: function! s:GetNextChar()
line 60: 
line 61: function! s:GetPrevChar()
line 64: 
line 65: " used to implement automatic deletion of closing character when opening
line 66: " counterpart is deleted and by space expansion
line 67: function! s:IsEmptyPair()
line 72: 
line 73: function! s:GetCurrentSyntaxRegion()
line 76: 
line 77: function! s:GetCurrentSyntaxRegionIf(char)
line 85: 
line 86: function! s:IsForbidden(char)
line 95: 
line 96: function! s:AllowQuote(char, isBS)
line 118: 
line 119: function! s:CountQuotes(char)
line 151: 
line 152: " The auto-close buffer is used in a fix of the redo functionality.
line 153: " As we insert characters after cursor, we remember them and at the moment
line 154: " that vim would normally collect the last entered string into dot register
line 155: " (:help ".) - i.e. when esc or a motion key is typed in insert mode - we
line 156: " erase the inserted symbols and pretend that we have just now typed them.
line 157: " This way vim picks them up into dot register as well and user can repeat the
line 158: " typed bit with . command.
line 159: function! s:PushBuffer(char)
line 165: 
line 166: function! s:PopBuffer()
line 171: 
line 172: function! s:EmptyBuffer()
line 177: 
line 178: function! s:FlushBuffer()
line 190: 
line 191: function! s:InsertStringAtCursor(str)
line 201: 
line 202: function! s:EraseNCharsAtCursor(len)
line 212: 
line 213: " returns the opener, after having inserted its closer if necessary
line 214: function! s:InsertPair(opener)
line 233: 
line 234: " returns the closer, after having eaten identical one if necessary
line 235: function! s:ClosePair(closer)
line 247: 
line 248: " in case closer is identical with its opener - heuristically decide which one
line 249: " is being typed and act accordingly
line 250: function! s:OpenOrCloseTwinPair(char)
line 259: 
line 260: " maintain auto-close buffer when delete key is pressed
line 261: function! s:Delete()
line 272: 
line 273: " when backspace is pressed:
line 274: " - erase an empty pair if backspacing from inside one
line 275: " - maintain auto-close buffer
line 276: function! s:Backspace()
line 290: 
line 291: function! s:Space()
line 299: 
line 300: function! s:Enter()
line 309: 
line 310: function! s:ToggleAutoClose()
line 318: 
line 319: " Parse a whitespace separated line of pairs
line 320: " single characters are assumed to be twin pairs (closer identical to
line 321: " opener)
line 322: function! AutoClose#ParsePairs(string)
Searching for "autoload/AutoClose.vim" in "/home/ollpu/.vim,/home/ollpu/.vim/bundle/fu,/home/ollpu/.vim/bundle/lightline.vim,/home/ollpu/.vim/bundle/molokai,/home/ollpu/.vim/bundle/vim-autoclose,/home/ollpu/.vim/bundle/vim-surround,/var/lib/vim/addons,/usr/share/vim/vimfiles,/usr/share/vim/vim74,/usr/share/vim/vimfiles/after,/var/lib/vim/addons/after,/home/ollpu/.vim/after"
Searching for "/home/ollpu/.vim/autoload/AutoClose.vim"
Searching for "/home/ollpu/.vim/bundle/fu/autoload/AutoClose.vim"
Searching for "/home/ollpu/.vim/bundle/lightline.vim/autoload/AutoClose.vim"
Searching for "/home/ollpu/.vim/bundle/molokai/autoload/AutoClose.vim"
Searching for "/home/ollpu/.vim/bundle/vim-autoclose/autoload/AutoClose.vim"
Searching for "/home/ollpu/.vim/bundle/vim-surround/autoload/AutoClose.vim"
Searching for "/var/lib/vim/addons/autoload/AutoClose.vim"
Searching for "/usr/share/vim/vimfiles/autoload/AutoClose.vim"
Searching for "/usr/share/vim/vim74/autoload/AutoClose.vim"
Searching for "/usr/share/vim/vimfiles/after/autoload/AutoClose.vim"
Searching for "/var/lib/vim/addons/after/autoload/AutoClose.vim"
Searching for "/home/ollpu/.vim/after/autoload/AutoClose.vim"
not found in 'runtimepath': "autoload/AutoClose.vim"
line 347: 
line 348: " this function is made visible for the sake of users
line 349: function! AutoClose#DefaultPairs()
line 352: 
line 353: function! s:ModifyPairsList(list, pairsToAdd, openersToRemove)
line 358: 
line 359: function! AutoClose#DefaultPairsModified(pairsToAdd,openersToRemove)
line 362: 
line 363: " Define variables (in the buffer namespace).
line 364: function! s:DefineVariables()
line 427: 
line 428: function! s:CreatePairsMaps()
line 451: 
line 452: function! s:CreateExtraMaps()
line 482: 
line 483: function! s:CreateMaps()
line 491: 
line 492: function! s:IsLoadedOnBuffer()
line 495: 
line 496: " map some characters to their key names
line 497: function! s:keyName(char)
line 501: 
line 502: " escape some characters for use in strings
line 503: function! s:quoteAndEscape(char)
line 507: 
line 508: 
line 509: """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
line 510: " Configuration
line 511: """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
line 512: let s:AutoClosePairs_FactoryDefaults = AutoClose#ParsePairs("() {} [] ` \" '")
calling function AutoClose#ParsePairs('() {} [] ` " ''')

line 1:     if type(a:string) == type({})
line 2:         return a:string
line 3:     elseif type(a:string) != type("")
line 4:         echoerr "AutoClose#ParsePairs(): Argument not a dictionary or a string"
line 5:         return {}
line 6:     endif
line 7: 
line 8:     let l:dict = {}
line 9:     for pair in split(a:string)
line 10:         " strlen is length in bytes, we want in (wide) characters
line 11:         let l:pairLen = strlen(substitute(pair,'.','x','g'))
line 12:         if l:pairLen == 1
line 13:             " assume a twin pair
line 14:             let l:dict[pair] = pair
line 15:         elseif l:pairLen == 2
line 16:             let l:dict[pair[0]] = pair[1]
line 17:         else
line 18:             echoerr "AutoClose: Bad pair string - a pair longer then two character"
line 19:             echoerr " `- String: " . a:sring
line 20:             echoerr " `- Pair: " . pair . " Pair len: " . l:pairLen
line 21:         endif
line 22:     endfor
line 9:     for pair in split(a:string)
line 10:         " strlen is length in bytes, we want in (wide) characters
line 11:         let l:pairLen = strlen(substitute(pair,'.','x','g'))
line 12:         if l:pairLen == 1
line 13:             " assume a twin pair
line 14:             let l:dict[pair] = pair
line 15:         elseif l:pairLen == 2
line 16:             let l:dict[pair[0]] = pair[1]
line 17:         else
line 18:             echoerr "AutoClose: Bad pair string - a pair longer then two character"
line 19:             echoerr " `- String: " . a:sring
line 20:             echoerr " `- Pair: " . pair . " Pair len: " . l:pairLen
line 21:         endif
line 22:     endfor
line 9:     for pair in split(a:string)
line 10:         " strlen is length in bytes, we want in (wide) characters
line 11:         let l:pairLen = strlen(substitute(pair,'.','x','g'))
line 12:         if l:pairLen == 1
line 13:             " assume a twin pair
line 14:             let l:dict[pair] = pair
line 15:         elseif l:pairLen == 2
line 16:             let l:dict[pair[0]] = pair[1]
line 17:         else
line 18:             echoerr "AutoClose: Bad pair string - a pair longer then two character"
line 19:             echoerr " `- String: " . a:sring
line 20:             echoerr " `- Pair: " . pair . " Pair len: " . l:pairLen
line 21:         endif
line 22:     endfor
line 9:     for pair in split(a:string)
line 10:         " strlen is length in bytes, we want in (wide) characters
line 11:         let l:pairLen = strlen(substitute(pair,'.','x','g'))
line 12:         if l:pairLen == 1
line 13:             " assume a twin pair
line 14:             let l:dict[pair] = pair
line 15:         elseif l:pairLen == 2
line 16:             let l:dict[pair[0]] = pair[1]
line 17:         else
line 18:             echoerr "AutoClose: Bad pair string - a pair longer then two character"
line 19:             echoerr " `- String: " . a:sring
line 20:             echoerr " `- Pair: " . pair . " Pair len: " . l:pairLen
line 21:         endif
line 22:     endfor
line 9:     for pair in split(a:string)
line 10:         " strlen is length in bytes, we want in (wide) characters
line 11:         let l:pairLen = strlen(substitute(pair,'.','x','g'))
line 12:         if l:pairLen == 1
line 13:             " assume a twin pair
line 14:             let l:dict[pair] = pair
line 15:         elseif l:pairLen == 2
line 16:             let l:dict[pair[0]] = pair[1]
line 17:         else
line 18:             echoerr "AutoClose: Bad pair string - a pair longer then two character"
line 19:             echoerr " `- String: " . a:sring
line 20:             echoerr " `- Pair: " . pair . " Pair len: " . l:pairLen
line 21:         endif
line 22:     endfor
line 9:     for pair in split(a:string)
line 10:         " strlen is length in bytes, we want in (wide) characters
line 11:         let l:pairLen = strlen(substitute(pair,'.','x','g'))
line 12:         if l:pairLen == 1
line 13:             " assume a twin pair
line 14:             let l:dict[pair] = pair
line 15:         elseif l:pairLen == 2
line 16:             let l:dict[pair[0]] = pair[1]
line 17:         else
line 18:             echoerr "AutoClose: Bad pair string - a pair longer then two character"
line 19:             echoerr " `- String: " . a:sring
line 20:             echoerr " `- Pair: " . pair . " Pair len: " . l:pairLen
line 21:         endif
line 22:     endfor
line 9:     for pair in split(a:string)
line 10:         " strlen is length in bytes, we want in (wide) characters
line 11:         let l:pairLen = strlen(substitute(pair,'.','x','g'))
line 12:         if l:pairLen == 1
line 13:             " assume a twin pair
line 14:             let l:dict[pair] = pair
line 15:         elseif l:pairLen == 2
line 16:             let l:dict[pair[0]] = pair[1]
line 17:         else
line 18:             echoerr "AutoClose: Bad pair string - a pair longer then two character"
line 19:             echoerr " `- String: " . a:sring
line 20:             echoerr " `- Pair: " . pair . " Pair len: " . l:pairLen
line 21:         endif
line 22:     endfor
line 23:     return l:dict
function AutoClose#ParsePairs returning {'`': '`', '"': '"', '[': ']', '''': '''', '(': ')', '{': '}'}

continuing in /home/ollpu/.vim/bundle/vim-autoclose/plugin/AutoClose.vim

line 513: if !exists("g:AutoClosePairs_add") | let g:AutoClosePairs_add = "" | endif
line 513:  let g:AutoClosePairs_add = "" | endif
line 513:  endif
line 514: if !exists("g:AutoClosePairs_del") | let g:AutoClosePairs_del = "" | endif
line 514:  let g:AutoClosePairs_del = "" | endif
line 514:  endif
line 515: if !exists("g:AutoClosePairs")
line 519:     let g:AutoClosePairs = s:ModifyPairsList( s:AutoClosePairs_FactoryDefaults, g:AutoClosePairs_add, g:AutoClosePairs_del )
calling function <SNR>13_ModifyPairsList({'`': '`', '"': '"', '[': ']', '''': '''', '(': ')', '{': '}'}, '', '')

line 1:     return filter( extend(a:list, AutoClose#ParsePairs(a:pairsToAdd), "force"), "stridx(a:openersToRemove,v:key)<0")
calling function <SNR>13_ModifyPairsList[1]..AutoClose#ParsePairs('')

line 1:     if type(a:string) == type({})
line 2:         return a:string
line 3:     elseif type(a:string) != type("")
line 4:         echoerr "AutoClose#ParsePairs(): Argument not a dictionary or a string"
line 5:         return {}
line 6:     endif
line 7: 
line 8:     let l:dict = {}
line 9:     for pair in split(a:string)
line 10:         " strlen is length in bytes, we want in (wide) characters
line 11:         let l:pairLen = strlen(substitute(pair,'.','x','g'))
line 12:         if l:pairLen == 1
line 13:             " assume a twin pair
line 14:             let l:dict[pair] = pair
line 15:         elseif l:pairLen == 2
line 16:             let l:dict[pair[0]] = pair[1]
line 17:         else
line 18:             echoerr "AutoClose: Bad pair string - a pair longer then two character"
line 19:             echoerr " `- String: " . a:sring
line 20:             echoerr " `- Pair: " . pair . " Pair len: " . l:pairLen
line 21:         endif
line 22:     endfor
line 23:     return l:dict
function <SNR>13_ModifyPairsList[1]..AutoClose#ParsePairs returning {}

continuing in function <SNR>13_ModifyPairsList

function <SNR>13_ModifyPairsList returning {'`': '`', '"': '"', '[': ']', '''': '''', '(': ')', '{': '}'}

continuing in /home/ollpu/.vim/bundle/vim-autoclose/plugin/AutoClose.vim

line 520: endif
line 521: 
line 522: let s:movementKeys = split('ESC UP DOWN LEFT RIGHT HOME END PAGEUP PAGEDOWN')
line 523: " list of keys that get mapped to themselves for pumvisible()
line 524: let s:pumMovementKeys = split('UP DOWN PAGEUP PAGEDOWN')
line 525: 
line 526: 
line 527: if has("gui_macvim")
line 528:     call extend(s:movementKeys, split("D-LEFT D-RIGHT D-UP D-DOWN M-LEFT M-RIGHT M-UP M-DOWN"))
line 529: endif
line 530: 
line 531: augroup <Plug>(autoclose)
line 532: autocmd!
line 533: autocmd BufNewFile,BufRead,BufEnter * if !<SID>IsLoadedOnBuffer() | call <SID>CreateMaps() | endif
line 534: autocmd InsertEnter * call <SID>EmptyBuffer()
line 535: autocmd BufEnter * if mode() == 'i' | call <SID>EmptyBuffer() | endif
line 536: augroup END
line 537: 
line 538: " Define convenient commands
line 539: command! AutoCloseOn :let b:AutoCloseOn = 1
line 540: command! AutoCloseOff :let b:AutoCloseOn = 0
line 541: command! AutoCloseToggle :call s:ToggleAutoClose()
line 542: " vim:sw=4:sts=4:
finished sourcing /home/ollpu/.vim/bundle/vim-autoclose/plugin/AutoClose.vim
Searching for "/home/ollpu/.vim/bundle/vim-surround/plugin/**/*.vim"
chdir(/home/ollpu/.vim/bundle/vim-surround/plugin)
fchdir() to previous dir
sourcing "/home/ollpu/.vim/bundle/vim-surround/plugin/surround.vim"
line 1: " surround.vim - Surroundings
line 2: " Author:       Tim Pope <http://tpo.pe/>
line 3: " Version:      2.1
line 4: " GetLatestVimScripts: 1697 1 :AutoInstall: surround.vim
line 5: 
line 6: if exists("g:loaded_surround") || &cp || v:version < 700
line 7:   finish
line 8: endif
line 9: let g:loaded_surround = 1
line 10: 
line 11: " Input functions {{{1
line 12: 
line 13: function! s:getchar()
line 20: 
line 21: function! s:inputtarget()
line 35: 
line 36: function! s:inputreplacement()
line 47: 
line 48: function! s:beep()
line 52: 
line 53: function! s:redraw()
line 57: 
line 58: " }}}1
line 59: 
line 60: " Wrapping functions {{{1
line 61: 
line 62: function! s:extractbefore(str)
line 69: 
line 70: function! s:extractafter(str)
line 77: 
line 78: function! s:fixindent(str,spc)
line 87: 
line 88: function! s:process(string)
line 126: 
line 127: function! s:wrap(string,char,type,removed,special)
line 297: 
line 298: function! s:wrapreg(reg,char,removed,special)
line 304: " }}}1
line 305: 
line 306: function! s:insert(...) " {{{1
line 348: 
line 349: function! s:reindent() " {{{1
line 354: 
line 355: function! s:dosurround(...) " {{{1
line 468: 
line 469: function! s:changesurround(...) " {{{1
line 480: 
line 481: function! s:opfunc(type,...) " {{{1
line 543: 
line 544: function! s:opfunc2(arg)
line 547: 
line 548: function! s:closematch(str) " {{{1
line 563: 
line 564: nnoremap <silent> <Plug>SurroundRepeat .
line 565: nnoremap <silent> <Plug>Dsurround  :<C-U>call <SID>dosurround(<SID>inputtarget())<CR>
line 566: nnoremap <silent> <Plug>Csurround  :<C-U>call <SID>changesurround()<CR>
line 567: nnoremap <silent> <Plug>CSurround  :<C-U>call <SID>changesurround(1)<CR>
line 568: nnoremap <silent> <Plug>Yssurround :<C-U>call <SID>opfunc(v:count1)<CR>
line 569: nnoremap <silent> <Plug>YSsurround :<C-U>call <SID>opfunc2(v:count1)<CR>
line 570: " <C-U> discards the numerical argument but there's not much we can do with it
line 571: nnoremap <silent> <Plug>Ysurround  :<C-U>set opfunc=<SID>opfunc<CR>g@
line 572: nnoremap <silent> <Plug>YSurround  :<C-U>set opfunc=<SID>opfunc2<CR>g@
line 573: vnoremap <silent> <Plug>VSurround  :<C-U>call <SID>opfunc(visualmode(),visualmode() ==# 'V' ? 1 : 0)<CR>
line 574: vnoremap <silent> <Plug>VgSurround :<C-U>call <SID>opfunc(visualmode(),visualmode() ==# 'V' ? 0 : 1)<CR>
line 575: inoremap <silent> <Plug>Isurround  <C-R>=<SID>insert()<CR>
line 576: inoremap <silent> <Plug>ISurround  <C-R>=<SID>insert(1)<CR>
line 577: 
line 578: if !exists("g:surround_no_mappings") || ! g:surround_no_mappings
line 579:   nmap ds  <Plug>Dsurround
line 580:   nmap cs  <Plug>Csurround
line 581:   nmap cS  <Plug>CSurround
line 582:   nmap ys  <Plug>Ysurround
line 583:   nmap yS  <Plug>YSurround
line 584:   nmap yss <Plug>Yssurround
line 585:   nmap ySs <Plug>YSsurround
line 586:   nmap ySS <Plug>YSsurround
line 587:   xmap S   <Plug>VSurround
line 588:   xmap gS  <Plug>VgSurround
line 589:   if !exists("g:surround_no_insert_mappings") || ! g:surround_no_insert_mappings
line 590:     if !hasmapto("<Plug>Isurround","i") && "" == mapcheck("<C-S>","i")
line 591:       imap    <C-S> <Plug>Isurround
line 592:     endif
line 593:     imap      <C-G>s <Plug>Isurround
line 594:     imap      <C-G>S <Plug>ISurround
line 595:   endif
line 596: endif
line 597: 
line 598: " vim:set ft=vim sw=2 sts=2 et:
finished sourcing /home/ollpu/.vim/bundle/vim-surround/plugin/surround.vim
Searching for "/var/lib/vim/addons/plugin/**/*.vim"
Searching for "/usr/share/vim/vimfiles/plugin/**/*.vim"
Searching for "/usr/share/vim/vim74/plugin/**/*.vim"
chdir(/usr/share/vim/vim74/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim74/plugin/getscriptPlugin.vim"
line 1: " ---------------------------------------------------------------------
line 2: " getscriptPlugin.vim
line 3: "  Author:^ICharles E. Campbell
line 4: "  Date:^INov 29, 2013
line 5: "  Installing:^I:help glvs-install
line 6: "  Usage:^I:help glvs
line 7: "
line 8: " GetLatestVimScripts: 642 1 :AutoInstall: getscript.vim
line 9: "
line 10: " (Rom 15:11 WEB) Again, "Praise the Lord, all you Gentiles!  Let
line 11: " all the peoples praise Him."
line 12: " ---------------------------------------------------------------------
line 13: " Initialization:^I{{{1
line 14: " if you're sourcing this file, surely you can't be
line 15: " expecting vim to be in its vi-compatible mode
line 16: if exists("g:loaded_getscriptPlugin")
line 17:  finish
line 18: endif
line 19: if &cp
line 20:  if &verbose
line 21:   echo "GetLatestVimScripts is not vi-compatible; not loaded (you need to set nocp)"
line 22:  endif
line 23:  finish
line 24: endif
line 25: let g:loaded_getscriptPlugin = "v36"
line 26: let s:keepcpo                = &cpo
line 27: set cpo&vim
line 28: 
line 29: " ---------------------------------------------------------------------
line 30: "  Public Interface: {{{1
line 31: com!        -nargs=0 GetLatestVimScripts call getscript#GetLatestVimScripts()
line 32: com!        -nargs=0 GetScripts          call getscript#GetLatestVimScripts()
line 33: silent! com -nargs=0 GLVS                call getscript#GetLatestVimScripts()
line 34: 
line 35: " ---------------------------------------------------------------------
line 36: " Restore Options: {{{1
line 37: let &cpo= s:keepcpo
line 38: unlet s:keepcpo
line 39: 
line 40: " ---------------------------------------------------------------------
line 41: " vim: ts=8 sts=2 fdm=marker nowrap
finished sourcing /usr/share/vim/vim74/plugin/getscriptPlugin.vim
chdir(/usr/share/vim/vim74/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim74/plugin/gzip.vim"
line 1: " Vim plugin for editing compressed files.
line 2: " Maintainer: Bram Moolenaar <Bram@vim.org>
line 3: " Last Change: 2010 Mar 10
line 4: 
line 5: " Exit quickly when:
line 6: " - this plugin was already loaded
line 7: " - when 'compatible' is set
line 8: " - some autocommands are already taking care of compressed files
line 9: if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
line 10:   finish
line 11: endif
line 12: let loaded_gzip = 1
line 13: 
line 14: augroup gzip
line 15:   " Remove all gzip autocommands
line 16:   au!
line 17: 
line 18:   " Enable editing of gzipped files.
line 19:   " The functions are defined in autoload/gzip.vim.
line 20:   "
line 21:   " Set binary mode before reading the file.
line 22:   " Use "gzip -d", gunzip isn't always available.
line 23:   autocmd BufReadPre,FileReadPre^I*.gz,*.bz2,*.Z,*.lzma,*.xz setlocal bin
line 24:   autocmd BufReadPost,FileReadPost^I*.gz  call gzip#read("gzip -dn")
line 25:   autocmd BufReadPost,FileReadPost^I*.bz2 call gzip#read("bzip2 -d")
line 26:   autocmd BufReadPost,FileReadPost^I*.Z   call gzip#read("uncompress")
line 27:   autocmd BufReadPost,FileReadPost^I*.lzma call gzip#read("lzma -d")
line 28:   autocmd BufReadPost,FileReadPost^I*.xz  call gzip#read("xz -d")
line 29:   autocmd BufWritePost,FileWritePost^I*.gz  call gzip#write("gzip")
line 30:   autocmd BufWritePost,FileWritePost^I*.bz2 call gzip#write("bzip2")
line 31:   autocmd BufWritePost,FileWritePost^I*.Z   call gzip#write("compress -f")
line 32:   autocmd BufWritePost,FileWritePost^I*.lzma call gzip#write("lzma -z")
line 33:   autocmd BufWritePost,FileWritePost^I*.xz  call gzip#write("xz -z")
line 34:   autocmd FileAppendPre^I^I^I*.gz  call gzip#appre("gzip -dn")
line 35:   autocmd FileAppendPre^I^I^I*.bz2 call gzip#appre("bzip2 -d")
line 36:   autocmd FileAppendPre^I^I^I*.Z   call gzip#appre("uncompress")
line 37:   autocmd FileAppendPre^I^I^I*.lzma call gzip#appre("lzma -d")
line 38:   autocmd FileAppendPre^I^I^I*.xz   call gzip#appre("xz -d")
line 39:   autocmd FileAppendPost^I^I*.gz  call gzip#write("gzip")
line 40:   autocmd FileAppendPost^I^I*.bz2 call gzip#write("bzip2")
line 41:   autocmd FileAppendPost^I^I*.Z   call gzip#write("compress -f")
line 42:   autocmd FileAppendPost^I^I*.lzma call gzip#write("lzma -z")
line 43:   autocmd FileAppendPost^I^I*.xz call gzip#write("xz -z")
line 44: augroup END
finished sourcing /usr/share/vim/vim74/plugin/gzip.vim
chdir(/usr/share/vim/vim74/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim74/plugin/logiPat.vim"
line 1: " LogiPat:
line 2: "   Author:  Charles E. Campbell
line 3: "   Date:    Mar 13, 2013
line 4: "   Version: 3
line 5: "   Purpose: to do Boolean-logic based regular expression pattern matching
line 6: " Copyright:    Copyright (C) 1999-2011 Charles E. Campbell {{{1
line 7: "               Permission is hereby granted to use and distribute this code,
line 8: "               with or without modifications, provided that this copyright
line 9: "               notice is copied with it. Like most anything else that's free,
line 10: "               LogiPat.vim is provided *as is* and comes with no warranty
line 11: "               of any kind, either expressed or implied. By using this
line 12: "               plugin, you agree that in no event will the copyright
line 13: "               holder be liable for any damages resulting from the use
line 14: "               of this software.
line 15: "
line 16: "   Usage: {{{1
line 17: "       :LogiPat ...
line 18: "
line 19: "         Boolean logic supported:
line 20: "            () grouping operators
line 21: "            !  not the following pattern
line 22: "            |  logical or
line 23: "            &  logical and
line 24: "            "..pattern.."
line 25: "^IExample: {{{1
line 26: "^I^I:LogiPat !("january"|"february")
line 27: "^I^I  would match all strings not containing the strings january
line 28: "^I^I  or february
line 29: "^IGetLatestVimScripts: 1290 1 :AutoInstall: LogiPat.vim
line 30: "
line 31: "  Behold, you will conceive in your womb, and bring forth a son, {{{1
line 32: "  and will call his name Jesus. He will be great, and will be
line 33: "  called the Son of the Most High. The Lord God will give him the
line 34: "  throne of his father, David, and he will reign over the house of
line 35: "  Jacob forever. There will be no end to his kingdom. (Luke 1:31-33 WEB)
line 36: 
line 37: " ---------------------------------------------------------------------
line 38: " Load Once: {{{1
line 39: if &cp || exists("loaded_logipat")
line 40:  finish
line 41: endif
line 42: let g:loaded_LogiPat = "v3"
line 43: let s:keepcpo        = &cpo
line 44: set cpo&vim
line 45: "DechoRemOn
line 46: 
line 47: " ---------------------------------------------------------------------
line 48: " Public Interface: {{{1
line 49: com!        -nargs=* LogiPat^I^Icall   LogiPat(<q-args>,1)
line 50: silent! com -nargs=* LP^I^I^I^Icall   LogiPat(<q-args>,1)
line 51: com!        -nargs=+ ELP^I^I^Iechomsg   LogiPat(<q-args>)
line 52: com!        -nargs=+ LogiPatFlags^Ilet  s:LogiPatFlags="<args>"
line 53: silent! com -nargs=+ LPF^I^I^Ilet  s:LogiPatFlags="<args>"
line 54: 
line 55: " =====================================================================
line 56: " Functions: {{{1
line 57: 
line 58: " ---------------------------------------------------------------------
line 59: " LogiPat: this function interprets the boolean-logic pattern {{{2
line 60: fun! LogiPat(pat,...)
line 142: 
line 143: " ---------------------------------------------------------------------
line 144: " s:String: Vim6.4 doesn't have string() {{{2
line 145: func! s:String(str)
line 148: 
line 149: " ---------------------------------------------------------------------
line 150: " LP_PatPush: {{{2
line 151: fun! s:LP_PatPush(pat)
line 158: 
line 159: " ---------------------------------------------------------------------
line 160: " LP_PatPop: pop a number/variable from LogiPat's pattern stack {{{2
line 161: fun! s:LP_PatPop(lookup)
line 174: 
line 175: " ---------------------------------------------------------------------
line 176: " LP_OpPush: {{{2
line 177: fun! s:LP_OpPush(op)
line 228: 
line 229: " ---------------------------------------------------------------------
line 230: " LP_Execute: execute operators from opstack using pattern stack {{{2
line 231: fun! s:LP_Execute(preclvl)
line 261: 
line 262: " ---------------------------------------------------------------------
line 263: " LP_Not: writes a logical-not for a pattern {{{2
line 264: fun! s:LP_Not(pat)
line 275: 
line 276: " ---------------------------------------------------------------------
line 277: " LP_Or: writes a logical-or branch using two patterns {{{2
line 278: fun! s:LP_Or(pat1,pat2)
line 284: 
line 285: " ---------------------------------------------------------------------
line 286: " LP_And: writes a logical-and concat using two patterns {{{2
line 287: fun! s:LP_And(pat1,pat2)
line 293: 
line 294: " ---------------------------------------------------------------------
line 295: " StackLook: {{{2
line 296: fun! s:StackLook(description)
line 330: 
line 331: " ---------------------------------------------------------------------
line 332: "  Cleanup And Modeline: {{{1
line 333: let &cpo= s:keepcpo
line 334: unlet s:keepcpo
line 335: " vim: ts=4 fdm=marker
finished sourcing /usr/share/vim/vim74/plugin/logiPat.vim
chdir(/usr/share/vim/vim74/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim74/plugin/matchparen.vim"
line 1: " Vim plugin for showing matching parens
line 2: " Maintainer:  Bram Moolenaar <Bram@vim.org>
line 3: " Last Change: 2016 Feb 16
line 4: 
line 5: " Exit quickly when:
line 6: " - this plugin was already loaded (or disabled)
line 7: " - when 'compatible' is set
line 8: " - the "CursorMoved" autocmd event is not available.
line 9: if exists("g:loaded_matchparen") || &cp || !exists("##CursorMoved")
line 10:   finish
line 11: endif
line 12: let g:loaded_matchparen = 1
line 13: 
line 14: if !exists("g:matchparen_timeout")
line 15:   let g:matchparen_timeout = 300
line 16: endif
line 17: if !exists("g:matchparen_insert_timeout")
line 18:   let g:matchparen_insert_timeout = 60
line 19: endif
line 20: 
line 21: augroup matchparen
line 22:   " Replace all matchparen autocommands
line 23:   autocmd! CursorMoved,CursorMovedI,WinEnter * call s:Highlight_Matching_Pair()
line 24:   if exists('##TextChanged')
line 25:     autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
line 26:   endif
line 27: augroup END
line 28: 
line 29: " Skip the rest if it was already done.
line 30: if exists("*s:Highlight_Matching_Pair")
line 31:   finish
line 32: endif
line 33: 
line 34: let s:cpo_save = &cpo
line 35: set cpo-=C
line 36: 
line 37: " The function that is invoked (very often) to define a ":match" highlighting
line 38: " for any matching paren.
line 39: function! s:Highlight_Matching_Pair()
line 187: 
line 188: " Define commands that will disable and enable the plugin.
line 190: command! NoMatchParen windo silent! call matchdelete(3) | unlet! g:loaded_matchparen | au! matchparen
line 191: command! DoMatchParen runtime plugin/matchparen.vim | windo doau CursorMoved
line 192: 
line 193: let &cpo = s:cpo_save
line 194: unlet s:cpo_save
finished sourcing /usr/share/vim/vim74/plugin/matchparen.vim
chdir(/usr/share/vim/vim74/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim74/plugin/netrwPlugin.vim"
line 1: " netrwPlugin.vim: Handles file transfer and remote directory listing across a network
line 2: "            PLUGIN SECTION
line 3: " Date:^I^IFeb 08, 2016
line 4: " Maintainer:^ICharles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
line 5: " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
line 6: " Copyright:    Copyright (C) 1999-2013 Charles E. Campbell {{{1
line 7: "               Permission is hereby granted to use and distribute this code,
line 8: "               with or without modifications, provided that this copyright
line 9: "               notice is copied with it. Like anything else that's free,
line 10: "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
line 11: "               *as is* and comes with no warranty of any kind, either
line 12: "               expressed or implied. By using this plugin, you agree that
line 13: "               in no event will the copyright holder be liable for any damages
line 14: "               resulting from the use of this software.
line 15: "
line 16: "  But be doers of the Word, and not only hearers, deluding your own selves {{{1
line 17: "  (James 1:22 RSV)
line 18: " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
line 19: " Load Once: {{{1
line 20: if &cp || exists("g:loaded_netrwPlugin")
line 21:  finish
line 22: endif
line 23: let g:loaded_netrwPlugin = "v155"
line 24: let s:keepcpo = &cpo
line 25: set cpo&vim
line 26: "DechoRemOn
line 27: 
line 28: " ---------------------------------------------------------------------
line 29: " Public Interface: {{{1
line 30: 
line 31: " Local Browsing Autocmds: {{{2
line 32: augroup FileExplorer
line 33:  au!
line 34:  au BufLeave *  if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
line 35:  au BufEnter *^Isil call s:LocalBrowse(expand("<amatch>"))
line 36:  au VimEnter *^Isil call s:VimEnter(expand("<amatch>"))
line 37:  if has("win32") || has("win95") || has("win64") || has("win16")
line 38:   au BufEnter .* sil call s:LocalBrowse(expand("<amatch>"))
line 39:  endif
line 40: augroup END
line 41: 
line 42: " Network Browsing Reading Writing: {{{2
line 43: augroup Network
line 44:  au!
line 45:  au BufReadCmd   file://*^I^I^I^I^I^I^I^I^I^I^Icall netrw#FileUrlRead(expand("<amatch>"))
line 46:  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))
line 47:  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))
line 48:  au BufWriteCmd  ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))
line 49:  au FileWriteCmd ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))
line 50:  try                                                       
line 51:   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))
line 52:  catch /^Vim\%((\a\+)\)\=:E216/                            
line 53:   au SourcePre   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))
line 54:  endtry
line 55: augroup END
line 56: 
line 57: " Commands: :Nread, :Nwrite, :NetUserPass {{{2
line 58: com! -count=1 -nargs=*^INread^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call winrestview(s:svpos)
line 59: com! -range=% -nargs=*^INwrite^I^Ilet s:svpos= winsaveview()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call winrestview(s:svpos)
line 60: com! -nargs=*^I^INetUserPass^Icall NetUserPass(<f-args>)
line 61: com! -nargs=*^I        Nsource^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetSource(<f-args>)<bar>call winrestview(s:svpos)
line 62: com! -nargs=?^I^INtree^I^Icall netrw#SetTreetop(<q-args>)
line 63: 
line 64: " Commands: :Explore, :Sexplore, Hexplore, Vexplore, Lexplore {{{2
line 65: com! -nargs=* -bar -bang -count=0 -complete=dir^IExplore^I^Icall netrw#Explore(<count>,0,0+<bang>0,<q-args>)
line 66: com! -nargs=* -bar -bang -count=0 -complete=dir^ISexplore^Icall netrw#Explore(<count>,1,0+<bang>0,<q-args>)
line 67: com! -nargs=* -bar -bang -count=0 -complete=dir^IHexplore^Icall netrw#Explore(<count>,1,2+<bang>0,<q-args>)
line 68: com! -nargs=* -bar -bang -count=0 -complete=dir^IVexplore^Icall netrw#Explore(<count>,1,4+<bang>0,<q-args>)
line 69: com! -nargs=* -bar       -count=0 -complete=dir^ITexplore^Icall netrw#Explore(<count>,0,6        ,<q-args>)
line 70: com! -nargs=* -bar -bang^I^I^INexplore^Icall netrw#Explore(-1,0,0,<q-args>)
line 71: com! -nargs=* -bar -bang^I^I^IPexplore^Icall netrw#Explore(-2,0,0,<q-args>)
line 72: com! -nargs=* -bar -bang -count=0 -complete=dir Lexplore^Icall netrw#Lexplore(<count>,<bang>0,<q-args>)
line 73: 
line 74: " Commands: NetrwSettings {{{2
line 75: com! -nargs=0^INetrwSettings^Icall netrwSettings#NetrwSettings()
line 76: com! -bang^INetrwClean^Icall netrw#Clean(<bang>0)
line 77: 
line 78: " Maps:
line 79: if !exists("g:netrw_nogx")
line 80:  if maparg('gx','n') == ""
line 81:   if !hasmapto('<Plug>NetrwBrowseX')
line 82:    nmap <unique> gx <Plug>NetrwBrowseX
line 83:   endif
line 84:   nno <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(expand((exists("g:netrw_gx")? g:netrw_gx : '<cfile>')),netrw#CheckIfRemote())<cr>
line 85:  endif
line 86:  if maparg('gx','v') == ""
line 87:   if !hasmapto('<Plug>NetrwBrowseXVis')
line 88:    vmap <unique> gx <Plug>NetrwBrowseXVis
line 89:   endif
line 90:   vno <silent> <Plug>NetrwBrowseXVis :<c-u>call netrw#BrowseXVis()<cr>
line 91:  endif
line 92: endif
line 93: if exists("g:netrw_usetab") && g:netrw_usetab
line 94:  if maparg('<c-tab>','n') == ""
line 95:   nmap <unique> <c-tab> <Plug>NetrwShrink
line 96:  endif
line 97:  nno <silent> <Plug>NetrwShrink :call netrw#Shrink()<cr>
line 98: endif
line 99: 
line 100: " ---------------------------------------------------------------------
line 101: " LocalBrowse: invokes netrw#LocalBrowseCheck() on directory buffers {{{2
line 102: fun! s:LocalBrowse(dirname)
line 148: 
line 149: " ---------------------------------------------------------------------
line 150: " s:VimEnter: after all vim startup stuff is done, this function is called. {{{2
line 151: "             Its purpose: to look over all windows and run s:LocalBrowse() on
line 152: "             them, which checks if they're directories and will create a directory
line 153: "             listing when appropriate.
line 154: "             It also sets s:vimentered, letting s:LocalBrowse() know that s:VimEnter()
line 155: "             has already been called.
line 156: fun! s:VimEnter(dirname)
line 164: 
line 165: " ---------------------------------------------------------------------
line 166: " NetrwStatusLine: {{{1
line 167: fun! NetrwStatusLine()
line 178: 
line 179: " ------------------------------------------------------------------------
line 180: " NetUserPass: set username and password for subsequent ftp transfer {{{1
line 181: "   Usage:  :call NetUserPass()^I^I^I-- will prompt for userid and password
line 182: "^I    :call NetUserPass("uid")^I^I-- will prompt for password
line 183: "^I    :call NetUserPass("uid","password") -- sets global userid and password
line 184: fun! NetUserPass(...)
line 208: 
line 209: " ------------------------------------------------------------------------
line 210: " Modelines And Restoration: {{{1
line 211: let &cpo= s:keepcpo
line 212: unlet s:keepcpo
line 213: " vim:ts=8 fdm=marker
finished sourcing /usr/share/vim/vim74/plugin/netrwPlugin.vim
chdir(/usr/share/vim/vim74/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim74/plugin/rrhelper.vim"
line 1: " Vim plugin with helper function(s) for --remote-wait
line 2: " Maintainer: Flemming Madsen <fma@cci.dk>
line 3: " Last Change: 2008 May 29
line 4: 
line 5: " Has this already been loaded?
line 6: if exists("loaded_rrhelper") || !has("clientserver")
line 7:   finish
finished sourcing /usr/share/vim/vim74/plugin/rrhelper.vim
chdir(/usr/share/vim/vim74/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim74/plugin/spellfile.vim"
line 1: " Vim plugin for downloading spell files
line 2: " Maintainer:  Bram Moolenaar <Bram@vim.org>
line 3: " Last Change: 2006 Feb 01
line 4: 
line 5: " Exit quickly when:
line 6: " - this plugin was already loaded
line 7: " - when 'compatible' is set
line 8: " - some autocommands are already taking care of spell files
line 9: if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
line 10:   finish
line 11: endif
line 12: let loaded_spellfile_plugin = 1
line 13: 
line 14: " The function is in the autoload directory.
line 15: autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))
finished sourcing /usr/share/vim/vim74/plugin/spellfile.vim
chdir(/usr/share/vim/vim74/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim74/plugin/tarPlugin.vim"
line 1: " tarPlugin.vim -- a Vim plugin for browsing tarfiles
line 2: " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
line 3: " Modified by Charles E. Campbell
line 4: " Distributed under the GNU General Public License.
line 5: "
line 6: " Updates are available from <http://michael.toren.net/code/>.  If you
line 7: " find this script useful, or have suggestions for improvements, please
line 8: " let me know.
line 9: " Also look there for further comments and documentation.
line 10: "
line 11: " This part only sets the autocommands.  The functions are in autoload/tar.vim.
line 12: " ---------------------------------------------------------------------
line 13: "  Load Once: {{{1
line 14: if &cp || exists("g:loaded_tarPlugin")
line 15:  finish
line 16: endif
line 17: let g:loaded_tarPlugin = "v29"
line 18: let s:keepcpo          = &cpo
line 19: set cpo&vim
line 20: 
line 21: " ---------------------------------------------------------------------
line 22: "  Public Interface: {{{1
line 23: augroup tar
line 24:   au!
line 25:   au BufReadCmd   tarfile::*^Icall tar#Read(expand("<amatch>"), 1)
line 26:   au FileReadCmd  tarfile::*^Icall tar#Read(expand("<amatch>"), 0)
line 27:   au BufWriteCmd  tarfile::*^Icall tar#Write(expand("<amatch>"))
line 28:   au FileWriteCmd tarfile::*^Icall tar#Write(expand("<amatch>"))
line 29: 
line 30:   if has("unix")
line 31:    au BufReadCmd   tarfile::*/*^Icall tar#Read(expand("<amatch>"), 1)
line 32:    au FileReadCmd  tarfile::*/*^Icall tar#Read(expand("<amatch>"), 0)
line 33:    au BufWriteCmd  tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 34:    au FileWriteCmd tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 35:   endif
line 36: 
line 37:   au BufReadCmd   *.tar.gz^I^Icall tar#Browse(expand("<amatch>"))
line 38:   au BufReadCmd   *.tar^I^I^Icall tar#Browse(expand("<amatch>"))
line 39:   au BufReadCmd   *.lrp^I^I^Icall tar#Browse(expand("<amatch>"))
line 40:   au BufReadCmd   *.tar.bz2^I^Icall tar#Browse(expand("<amatch>"))
line 41:   au BufReadCmd   *.tar.Z^I^Icall tar#Browse(expand("<amatch>"))
line 42:   au BufReadCmd   *.tgz^I^I^Icall tar#Browse(expand("<amatch>"))
line 43:   au BufReadCmd   *.tar.lzma^Icall tar#Browse(expand("<amatch>"))
line 44:   au BufReadCmd   *.tar.xz^I^Icall tar#Browse(expand("<amatch>"))
line 45:   au BufReadCmd   *.txz^I^I^Icall tar#Browse(expand("<amatch>"))
line 46: augroup END
line 47: com! -nargs=? -complete=file Vimuntar call tar#Vimuntar(<q-args>)
line 48: 
line 49: " ---------------------------------------------------------------------
line 50: " Restoration And Modelines: {{{1
line 51: " vim: fdm=marker
line 52: let &cpo= s:keepcpo
line 53: unlet s:keepcpo
finished sourcing /usr/share/vim/vim74/plugin/tarPlugin.vim
chdir(/usr/share/vim/vim74/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim74/plugin/tohtml.vim"
line 1: " Vim plugin for converting a syntax highlighted file to HTML.
line 2: " Maintainer: Ben Fritz <fritzophrenic@gmail.com>
line 3: " Last Change: 2015 Sep 08
line 4: "
line 5: " The core of the code is in $VIMRUNTIME/autoload/tohtml.vim and
line 6: " $VIMRUNTIME/syntax/2html.vim
line 7: "
line 8: " TODO: {{{
line 9: "   * Options for generating the CSS in external style sheets. New :TOcss
line 10: "     command to convert the current color scheme into a (mostly) generic CSS
line 11: "     stylesheet which can be re-used. Alternate stylesheet support? Good start
line 12: "     by Erik Falor
line 13: "     ( https://groups.google.com/d/topic/vim_use/7XTmC4D22dU/discussion ).
line 14: "   * Add optional argument to :TOhtml command to specify mode (gui, cterm,
line 15: "     term) to use for the styling. Suggestion by "nacitar".
line 16: "   * Add way to override or specify which RGB colors map to the color numbers
line 17: "     in cterm. Get better defaults than just guessing? Suggestion by "nacitar".
line 18: "   * Disable filetype detection until after all processing is done.
line 19: "   * Add option for not generating the hyperlink on stuff that looks like a
line 20: "     URL? Or just color the link to fit with the colorscheme (and only special
line 21: "     when hovering)?
line 22: "   * Bug: Opera does not allow printing more than one page if uncopyable
line 23: "     regions is turned on. Possible solution: Add normal text line numbers with
line 24: "     display:none, set to display:inline for print style sheets, and hide
line 25: "     <input> elements for print, to allow Opera printing multiple pages (and
line 26: "     other uncopyable areas?). May need to make the new text invisible to IE
line 27: "     with conditional comments to prevent copying it, IE for some reason likes
line 28: "     to copy hidden text. Other browsers too?
line 29: "   * Bug: still a 1px gap throughout the fold column when html_prevent_copy is
line 30: "     "fn" in some browsers. Specifically, in Chromium on Ubuntu (but not Chrome
line 31: "     on Windows). Perhaps it is font related?
line 32: "   * Bug: still some gaps in the fold column when html_prevent_copy contains
line 33: "     'd' and showing the whole diff (observed in multiple browsers). Only gaps
line 34: "     on diff lines though.
line 35: "   * Undercurl support via CSS3, with fallback to dotted or something:
line 36: "^Ihttps://groups.google.com/d/topic/vim_use/BzXA6He1pHg/discussion
line 37: "   * Redo updates for modified default foldtext (v11) when/if the patch is
line 38: "     accepted to modify it.
line 39: "   * Test case +diff_one_file-dynamic_folds+expand_tabs-hover_unfold
line 40: "^I^I+ignore_conceal-ignore_folding+no_foldcolumn+no_pre+no_progress
line 41: "^I^I+number_lines-pre_wrap-use_css+use_xhtml+whole_filler.xhtml
line 42: "     does not show the whole diff filler as it is supposed to?
line 43: "   * Bug: when 'isprint' is wrong for the current encoding, will generate
line 44: "     invalid content. Can/should anything be done about this? Maybe a separate
line 45: "     plugin to correct 'isprint' based on encoding?
line 46: "   * Check to see if the windows-125\d encodings actually work in Unix without
line 47: "     the 8bit- prefix. Add prefix to autoload dictionaries for Unix if not.
line 48: "   * Font auto-detection similar to
line 49: "     http://www.vim.org/scripts/script.php?script_id=2384 but for a variety of
line 50: "     platforms.
line 51: "   * Error thrown when sourcing 2html.vim directly when plugins are not loaded.
line 52: "   * Pull in code from http://www.vim.org/scripts/script.php?script_id=3113 :
line 53: "^I- listchars support
line 54: "^I- full-line background highlight
line 55: "^I- other?
line 56: "   * Make it so deleted lines in a diff don't create side-scrolling (get it
line 57: "     free with full-line background highlight above).
line 58: "   * Restore open/closed folds and cursor position after processing each file
line 59: "     with option not to restore for speed increase.
line 60: "   * Add extra meta info (generation time, etc.)?
line 61: "   * Tidy up so we can use strict doctype in even more situations
line 62: "   * Implementation detail: add threshold for writing the lines to the html
line 63: "     buffer before we're done (5000 or so lines should do it)
line 64: "   * TODO comments for code cleanup scattered throughout
line 65: "}}}
line 66: 
line 67: if exists('g:loaded_2html_plugin')
line 68:   finish
line 69: endif
line 70: let g:loaded_2html_plugin = 'vim7.4_v2'
line 71: 
line 72: "
line 73: " Changelog: {{{
line 74: "   7.4_v2  (this version): Fix error raised when converting a diff containing
line 75: "                           an empty buffer. Jan Stocker: allow g:html_font to
line 76: "                           take a list so it is easier to specfiy fallback
line 77: "                           fonts in the generated CSS.
line 78: "   7.4_v1  (Vim 7.4.0000): Fix modeline mangling for new "Vim:" format, and
line 79: "^I^I^I    also for version-specific modelines like "vim>703:".
line 80: "
line 81: "   7.3 updates: {{{
line 82: "   7.3_v14 (Vim 7.3.1246): Allow suppressing line number anchors using
line 83: "^I^I^I    g:html_line_ids=0. Allow customizing
line 84: "^I^I^I    important IDs (like line IDs and fold IDs) using
line 85: "^I^I^I    g:html_id_expr evalutated when the buffer conversion
line 86: "^I^I^I    is started.
line 87: "   7.3_v13 (Vim 7.3.1088): Keep foldmethod at manual in the generated file and
line 88: "^I^I^I    insert modeline to set it to manual.
line 89: "^I^I^I    Fix bug: diff mode with 2 unsaved buffers creates a
line 90: "^I^I^I    duplicate of one buffer instead of including both.
line 91: "^I^I^I    Add anchors to each line so you can put '#L123'
line 92: "^I^I^I    or '#123' at the end of the URL to jump to line 123
line 93: "^I^I^I    (idea by Andy Spencer). Add javascript to open folds
line 94: "^I^I^I    to show the anchor being jumped to if it is hidden.
line 95: "^I^I^I    Fix XML validation error: &nsbp; not part of XML.
line 96: "^I^I^I    Allow TOhtml to chain together with other commands
line 97: "^I^I^I    using |.
line 98: "   7.3_v12 (Vim 7.3.0616): Fix modeline mangling to also work for when multiple
line 99: "^I^I^I    highlight groups make up the start-of-modeline text.
line 100: "^I^I^I    Improve render time of page with uncopyable regions
line 101: "^I^I^I    by not using one-input-per-char. Change name of
line 102: "^I^I^I    uncopyable option from html_unselectable to
line 103: "^I^I^I    html_prevent_copy. Added html_no_invalid option and
line 104: "^I^I^I    default to inserting invalid markup for uncopyable
line 105: "^I^I^I    regions to prevent MS Word from pasting undeletable
line 106: "^I^I^I    <input> elements. Fix 'cpo' handling (Thilo Six).
line 107: "^I^I 7.3_v12b1: Add html_unselectable option. Rework logic to
line 108: "^I^I^I    eliminate post-processing substitute commands in
line 109: "^I^I^I    favor of doing the work up front. Remove unnecessary
line 110: "^I^I^I    special treatment of 'LineNr' highlight group. Minor
line 111: "^I^I^I    speed improvements. Fix modeline mangling in
line 112: "^I^I^I    generated output so it works for text in the first
line 113: "^I^I^I    column. Fix missing line number and fold column in
line 114: "^I^I^I    diff filler lines. Fix that some fonts have a 1px
line 115: "^I^I^I    gap (using a dirty hack, improvements welcome). Add
line 116: "^I^I^I    "colorscheme" meta tag. Does NOT include support for
line 117: "^I^I^I    the new default foldtext added in v11, as the patch
line 118: "^I^I^I    adding it has not yet been included in Vim.
line 119: "   7.3_v11 ( unreleased ): Support new default foldtext from patch by Christian
line 120: "^I^I^I    Brabandt in
line 121: "^I^I^I    http://groups.google.com/d/topic/vim_dev/B6FSGfq9VoI/discussion.
line 122: "^I^I^I    This patch has not yet been included in Vim, thus
line 123: "^I^I^I    these changes are removed in the next version.
line 124: "   7.3_v10 (Vim 7.3.0227): Fix error E684 when converting a range wholly inside
line 125: "^I^I^I    multiple nested folds with dynamic folding on.
line 126: "^I^I^I    Also fix problem with foldtext in this situation.
line 127: "   7.3_v9  (Vim 7.3.0170): Add html_pre_wrap option active with html_use_css
line 128: "^I^I^I    and without html_no_pre, default value same as
line 129: "^I^I^I    'wrap' option, (Andy Spencer). Don't use
line 130: "^I^I^I    'fileencoding' for converted document encoding if
line 131: "^I^I^I    'buftype' indicates a special buffer which isn't
line 132: "^I^I^I    written.
line 133: "   7.3_v8  (Vim 7.3.0100): Add html_expand_tabs option to allow leaving tab
line 134: "^I^I^I    characters in generated output (Andy Spencer).
line 135: "^I^I^I    Escape text that looks like a modeline so Vim
line 136: "^I^I^I    doesn't use anything in the converted HTML as a
line 137: "^I^I^I    modeline. Bugfixes: Fix folding when a fold starts
line 138: "^I^I^I    before the conversion range. Remove fold column when
line 139: "^I^I^I    there are no folds.
line 140: "   7.3_v7  (Vim 7-3-0063): see betas released on vim_dev below:
line 141: "^I^I  7.3_v7b3: Fixed bug, convert Unicode to UTF-8 all the way.
line 142: "^I^I  7.3_v7b2: Remove automatic detection of encodings that are not
line 143: "^I^I^I    supported by all major browsers according to
line 144: "^I^I^I    http://wiki.whatwg.org/wiki/Web_Encodings and
line 145: "^I^I^I    convert to UTF-8 for all Unicode encodings. Make
line 146: "^I^I^I    HTML encoding to Vim encoding detection be
line 147: "^I^I^I    case-insensitive for built-in pairs.
line 148: "^I^I  7.3_v7b1: Remove use of setwinvar() function which cannot be
line 149: "^I^I^I    called in restricted mode (Andy Spencer). Use
line 150: "^I^I^I    'fencoding' instead of 'encoding' to determine by
line 151: "^I^I^I    charset, and make sure the 'fenc' of the generated
line 152: "^I^I^I    file matches its indicated charset. Add charsets for
line 153: "^I^I^I    all of Vim's natively supported encodings.
line 154: "   7.3_v6  (Vim 7.3.0000): Really fix bug with 'nowrapscan', 'magic' and other
line 155: "^I^I^I    user settings interfering with diff mode generation,
line 156: "^I^I^I    trailing whitespace (e.g. line number column) when
line 157: "^I^I^I    using html_no_pre, and bugs when using
line 158: "^I^I^I    html_hover_unfold.
line 159: "   7.3_v5  ( unreleased ): Fix bug with 'nowrapscan' and also with out-of-sync
line 160: "^I^I^I    folds in diff mode when first line was folded.
line 161: "   7.3_v4  (Vim 7.3.0000): Bugfixes, especially for xhtml markup, and diff mode
line 162: "   7.3_v3  (Vim 7.3.0000): Refactor option handling and make html_use_css
line 163: "^I^I^I    default to true when not set to anything. Use strict
line 164: "^I^I^I    doctypes where possible. Rename use_xhtml option to
line 165: "^I^I^I    html_use_xhtml for consistency. Use .xhtml extension
line 166: "^I^I^I    when using this option. Add meta tag for settings.
line 167: "   7.3_v2  (Vim 7.3.0000): Fix syntax highlighting in diff mode to use both the
line 168: "^I^I^I    diff colors and the normal syntax colors
line 169: "   7.3_v1  (Vim 7.3.0000): Add conceal support and meta tags in output
line 170: "}}}
line 171: "}}}
line 172: 
line 173: " Define the :TOhtml command when:
line 174: " - 'compatible' is not set
line 175: " - this plugin was not already loaded
line 176: " - user commands are available. {{{
line 177: if !&cp && !exists(":TOhtml") && has("user_commands")
line 178:   command -range=% -bar TOhtml :call tohtml#Convert2HTML(<line1>, <line2>)
line 179: endif "}}}
line 180: 
line 181: " Make sure any patches will probably use consistent indent
line 182: "   vim: ts=8 sw=2 sts=2 noet fdm=marker
finished sourcing /usr/share/vim/vim74/plugin/tohtml.vim
chdir(/usr/share/vim/vim74/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim74/plugin/vimballPlugin.vim"
line 1: " vimballPlugin : construct a file containing both paths and files
line 2: " Author: Charles E. Campbell, Jr.
line 3: " Copyright: (c) 2004-2010 by Charles E. Campbell, Jr.
line 4: "            The VIM LICENSE applies to Vimball.vim, and Vimball.txt
line 5: "            (see |copyright|) except use "Vimball" instead of "Vim".
line 6: "            No warranty, express or implied.
line 7: "  *** ***   Use At-Your-Own-Risk!   *** ***
line 8: "
line 9: " (Rom 2:1 WEB) Therefore you are without excuse, O man, whoever you are who
line 10: "      judge. For in that which you judge another, you condemn yourself. For
line 11: "      you who judge practice the same things.
line 12: " GetLatestVimScripts: 1502 1 :AutoInstall: vimball.vim
line 13: 
line 14: " ---------------------------------------------------------------------
line 15: "  Load Once: {{{1
line 16: if &cp || exists("g:loaded_vimballPlugin")
line 17:  finish
line 18: endif
line 19: let g:loaded_vimballPlugin = "v35"
line 20: let s:keepcpo              = &cpo
line 21: set cpo&vim
line 22: 
line 23: " ------------------------------------------------------------------------------
line 24: " Public Interface: {{{1
line 25: com! -ra   -complete=file -na=+ -bang MkVimball^I^I^I^Icall vimball#MkVimball(<line1>,<line2>,<bang>0,<f-args>)
line 26: com! -na=? -complete=dir  UseVimball^I^I^I^I^I^Icall vimball#Vimball(1,<f-args>)
line 27: com! -na=0                VimballList^I^I^I^I^I^Icall vimball#Vimball(0)
line 28: com! -na=* -complete=dir  RmVimball^I^I^I^I^I^I^Icall vimball#SaveSettings()|call vimball#RmVimball(<f-args>)|call vimball#RestoreSettings()
line 29: au BufEnter  *.vba,*.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz^Isetlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")
line 30: au SourceCmd *.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if expand("%")!=expand("<afile>")|close|endif
line 31: au SourceCmd *.vba^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
line 32: au BufEnter  *.vmb,*.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz^Isetlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")
line 33: au SourceCmd *.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if expand("%")!=expand("<afile>")|close|endif
line 34: au SourceCmd *.vmb^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
line 35: 
line 36: " =====================================================================
line 37: " Restoration And Modelines: {{{1
line 38: " vim: fdm=marker
line 39: let &cpo= s:keepcpo
line 40: unlet s:keepcpo
finished sourcing /usr/share/vim/vim74/plugin/vimballPlugin.vim
chdir(/usr/share/vim/vim74/plugin)
fchdir() to previous dir
sourcing "/usr/share/vim/vim74/plugin/zipPlugin.vim"
line 1: " zipPlugin.vim: Handles browsing zipfiles
line 2: "            PLUGIN PORTION
line 3: " Date:^I^I^IJun 07, 2013
line 4: " Maintainer:^ICharles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
line 5: " License:^I^IVim License  (see vim's :help license)
line 6: " Copyright:    Copyright (C) 2005-2013 Charles E. Campbell {{{1
line 7: "               Permission is hereby granted to use and distribute this code,
line 8: "               with or without modifications, provided that this copyright
line 9: "  